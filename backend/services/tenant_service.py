# backend/services/tenant_service.py
import logging
from typing import List, Optional, Dict, Any, Tuple
from uuid import UUID # For type hinting UUID
from fastapi import BackgroundTasks
from fastapi.concurrency import run_in_threadpool # Added
from supabase import Client
from backend.models.tenant_models import TenantCreatePayload, TenantUpdatePayload
from backend.services.vertex_ai_client import create_rag_corpus # Added
# from backend.config import settings # Not directly used here, but create_rag_corpus uses it

logger = logging.getLogger(__name__)
TENANTS_TABLE = "tenants" # Table name constant

async def trigger_create_rag_corpus_and_update_tenant(tenant_id: UUID, display_name: str, db: Client):
    logger_service = logging.getLogger(__name__) # Use local logger instance
    logger_service.info(f"Background task: Attempting to create RAG Corpus for tenant {tenant_id} with display name '{display_name}'.")

    corpus_resource_name = await create_rag_corpus(display_name=display_name) # Uses project/location from settings

    if corpus_resource_name:
        logger_service.info(f"RAG Corpus created with resource name: {corpus_resource_name} for tenant {tenant_id}. Updating tenant record.")

        def update_tenant_db_sync(tid_to_update: UUID, c_id: str, d_name: str):
            logger_service.info(f"Updating tenant {tid_to_update} with rag_corpus_id={c_id}")
            try:
                response = db.table(TENANTS_TABLE).update({
                    "rag_corpus_id": c_id,
                    "rag_corpus_display_name": d_name
                }).eq("tenant_id", str(tid_to_update)).execute()

                if response.data and len(response.data) > 0:
                    logger_service.info(f"Tenant {tid_to_update} successfully updated with RAG corpus info.")
                else:
                    logger_service.error(f"Failed to update tenant {tid_to_update} or tenant not found. Supabase response: {response}")
            except Exception as e_db:
                logger_service.error(f"DB error updating tenant {tid_to_update} with RAG info: {e_db}", exc_info=True)

        await run_in_threadpool(update_tenant_db_sync, tenant_id, corpus_resource_name, display_name)

    else:
        logger_service.error(f"RAG Corpus creation failed for tenant {tenant_id} (display_name: {display_name}). Tenant record not updated with RAG ID.")
        # Further error handling/notification could be added here

async def create_tenant(db: Client, payload: TenantCreatePayload, background_tasks: BackgroundTasks) -> Optional[Dict[str, Any]]:
    """
    Creates a new tenant. tenant_id is auto-generated by the database.
    Returns the created tenant record as a dictionary, or None on failure.
    """
    try:
        data_to_insert = payload.model_dump()
        # tenant_id is expected to be defaulted by gen_random_uuid() in the DB schema
        response = db.table(TENANTS_TABLE).insert(data_to_insert).execute()

        if response.data and len(response.data) > 0:
            created_tenant_dict = response.data[0]
            logger.info(f"Tenant created: {created_tenant_dict.get('company_name')} (ID: {created_tenant_dict.get('tenant_id')})")

            tenant_id_uuid = created_tenant_dict.get('tenant_id')
            company_name = created_tenant_dict.get('company_name')

            if tenant_id_uuid and company_name:
                try:
                    # Attempt to convert string UUID to UUID object for the task
                    tenant_uuid_obj = UUID(tenant_id_uuid)
                    display_name_for_corpus = f"{company_name} RAG Corpus ({tenant_id_uuid[:8]})"
                    background_tasks.add_task(
                        trigger_create_rag_corpus_and_update_tenant,
                        tenant_id=tenant_uuid_obj,
                        display_name=display_name_for_corpus,
                        db=db
                    )
                    logger.info(f"Enqueued background task to create RAG corpus for tenant {tenant_id_uuid}.")
                except ValueError:
                    logger.error(f"Invalid UUID format for tenant_id: {tenant_id_uuid}. Cannot enqueue RAG corpus creation task.")
                except Exception as e_task:
                    logger.error(f"Error enqueuing RAG corpus creation task for tenant {tenant_id_uuid}: {e_task}", exc_info=True)

            return created_tenant_dict
        else:
            logger.error(
                f"Failed to create tenant, Supabase response did not contain data. Payload: {payload.model_dump_json()}. "
                f"Response: {response.model_dump_json() if hasattr(response, 'model_dump_json') else str(response)}"
            )
            return None
    except Exception as e: # Consider catching specific Supabase/PostgREST exceptions if available
        logger.error(f"Exception creating tenant ({payload.company_name}): {e}", exc_info=True)
        return None

async def get_tenant(db: Client, tenant_id: UUID) -> Optional[Dict[str, Any]]:
    """
    Retrieves a specific tenant by its UUID.
    Returns the tenant record as a dictionary, or None if not found.
    """
    try:
        response = db.table(TENANTS_TABLE).select("*").eq("tenant_id", str(tenant_id)).maybe_single().execute()
        # maybe_single() returns data as dict if found, None if no rows (and no error raised for 0 rows)
        if response.data:
            logger.debug(f"Tenant found: {tenant_id}")
            return response.data
        else:
            logger.debug(f"Tenant not found: {tenant_id}")
            return None
    except Exception as e:
        logger.error(f"Exception retrieving tenant {tenant_id}: {e}", exc_info=True)
        return None

async def list_tenants(
    db: Client, skip: int = 0, limit: int = 20, show_deleted: bool = False
) -> Tuple[List[Dict[str, Any]], int]:
    """
    Lists tenants with pagination and an option to include logically deleted ones.
    Returns a tuple: (list of tenant records, total_count).
    """
    try:
        query = db.table(TENANTS_TABLE).select("*", count="exact")
        if not show_deleted:
            query = query.eq("is_deleted", False)

        query = query.order("company_name", desc=False).range(skip, skip + limit - 1) # Default sort by company_name asc
        response = query.execute()

        tenants = response.data if response.data else []
        total_count = response.count if response.count is not None else 0
        logger.debug(f"Listed {len(tenants)} tenants (total: {total_count}, skip: {skip}, limit: {limit}, show_deleted: {show_deleted})")
        return tenants, total_count
    except Exception as e:
        logger.error(f"Exception listing tenants: {e}", exc_info=True)
        return [], 0

async def update_tenant(
    db: Client, tenant_id: UUID, payload: TenantUpdatePayload
) -> Optional[Dict[str, Any]]:
    """
    Updates an existing tenant. Only fields present in the payload are updated.
    Returns the updated tenant record as a dictionary, or None if not found or update failed.
    Assumes updated_at is handled by a DB trigger.
    """
    try:
        data_to_update = payload.model_dump(exclude_unset=True)
        if not data_to_update:
            logger.info(f"No fields to update for tenant_id: {tenant_id}. Returning current record.")
            return await get_tenant(db, tenant_id)

        response = db.table(TENANTS_TABLE).update(data_to_update).eq("tenant_id", str(tenant_id)).execute()

        if response.data and len(response.data) > 0:
            updated_tenant = response.data[0]
            logger.info(f"Tenant updated: {tenant_id}. New company name: {updated_tenant.get('company_name')}")
            return updated_tenant
        else:
            logger.warning(
                f"Failed to update tenant {tenant_id} (it may not exist or no data returned). "
                f"Update payload: {data_to_update}. Supabase response: {response.model_dump_json() if hasattr(response, 'model_dump_json') else str(response)}"
            )
            return None
    except Exception as e:
        logger.error(f"Exception updating tenant {tenant_id}: {e}", exc_info=True)
        return None

async def delete_tenant(db: Client, tenant_id: UUID, hard_delete: bool = False) -> bool:
    """
    Logically or physically deletes a tenant.
    For logical delete, sets is_deleted = True.
    Returns True if operation was successful (or record already in desired state for logical delete),
    False on error or if record not found for hard delete.
    """
    try:
        if hard_delete:
            logger.warning(f"Performing HARD delete for tenant_id: {tenant_id}")
            response = db.table(TENANTS_TABLE).delete().eq("tenant_id", str(tenant_id)).execute()
            # For hard delete, success means data was returned (i.e., something was deleted)
            if response.data and len(response.data) > 0:
                 logger.info(f"Tenant hard deleted: {tenant_id}")
                 return True
            logger.warning(f"Tenant {tenant_id} not found for hard delete, or no data returned from operation.")
            return False # Nothing was deleted
        else: # Logical delete
            # Check if already deleted to avoid unnecessary update and log spam
            current_tenant = await get_tenant(db, tenant_id)
            if current_tenant is None:
                logger.warning(f"Tenant {tenant_id} not found for logical delete.")
                return False # Not found
            if current_tenant.get("is_deleted") is True:
                logger.info(f"Tenant {tenant_id} is already logically deleted.")
                return True # Already in desired state

            response = db.table(TENANTS_TABLE).update({"is_deleted": True}).eq("tenant_id", str(tenant_id)).execute()
            if response.data and len(response.data) > 0:
                logger.info(f"Tenant logically deleted: {tenant_id}")
                return True
            logger.warning(f"Failed to logically delete tenant {tenant_id} (no data returned from update).")
            return False # Update didn't affect any rows as expected

    except Exception as e:
        logger.error(f"Exception during delete operation for tenant {tenant_id} (hard_delete={hard_delete}): {e}", exc_info=True)
        return False
