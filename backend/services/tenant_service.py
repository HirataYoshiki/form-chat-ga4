# backend/services/tenant_service.py
import logging
from typing import List, Optional, Dict, Any, Tuple
from uuid import UUID # For type hinting UUID
from supabase import Client
from backend.models.tenant_models import TenantCreatePayload, TenantUpdatePayload
# from datetime import datetime, timezone # Not explicitly setting updated_at here, relying on DB trigger

logger = logging.getLogger(__name__)
TENANTS_TABLE = "tenants" # Table name constant

async def create_tenant(db: Client, payload: TenantCreatePayload) -> Optional[Dict[str, Any]]:
    """
    Creates a new tenant. tenant_id is auto-generated by the database.
    Returns the created tenant record as a dictionary, or None on failure.
    """
    try:
        data_to_insert = payload.model_dump()
        # tenant_id is expected to be defaulted by gen_random_uuid() in the DB schema
        response = db.table(TENANTS_TABLE).insert(data_to_insert).execute()

        if response.data and len(response.data) > 0:
            created_tenant = response.data[0]
            logger.info(f"Tenant created: {created_tenant.get('company_name')} (ID: {created_tenant.get('tenant_id')})")
            return created_tenant
        else:
            logger.error(
                f"Failed to create tenant, Supabase response did not contain data. Payload: {payload.model_dump_json()}. "
                f"Response: {response.model_dump_json() if hasattr(response, 'model_dump_json') else str(response)}"
            )
            return None
    except Exception as e: # Consider catching specific Supabase/PostgREST exceptions if available
        logger.error(f"Exception creating tenant ({payload.company_name}): {e}", exc_info=True)
        return None

async def get_tenant(db: Client, tenant_id: UUID) -> Optional[Dict[str, Any]]:
    """
    Retrieves a specific tenant by its UUID.
    Returns the tenant record as a dictionary, or None if not found.
    """
    try:
        response = db.table(TENANTS_TABLE).select("*").eq("tenant_id", str(tenant_id)).maybe_single().execute()
        # maybe_single() returns data as dict if found, None if no rows (and no error raised for 0 rows)
        if response.data:
            logger.debug(f"Tenant found: {tenant_id}")
            return response.data
        else:
            logger.debug(f"Tenant not found: {tenant_id}")
            return None
    except Exception as e:
        logger.error(f"Exception retrieving tenant {tenant_id}: {e}", exc_info=True)
        return None

async def list_tenants(
    db: Client, skip: int = 0, limit: int = 20, show_deleted: bool = False
) -> Tuple[List[Dict[str, Any]], int]:
    """
    Lists tenants with pagination and an option to include logically deleted ones.
    Returns a tuple: (list of tenant records, total_count).
    """
    try:
        query = db.table(TENANTS_TABLE).select("*", count="exact")
        if not show_deleted:
            query = query.eq("is_deleted", False)

        query = query.order("company_name", desc=False).range(skip, skip + limit - 1) # Default sort by company_name asc
        response = query.execute()

        tenants = response.data if response.data else []
        total_count = response.count if response.count is not None else 0
        logger.debug(f"Listed {len(tenants)} tenants (total: {total_count}, skip: {skip}, limit: {limit}, show_deleted: {show_deleted})")
        return tenants, total_count
    except Exception as e:
        logger.error(f"Exception listing tenants: {e}", exc_info=True)
        return [], 0

async def update_tenant(
    db: Client, tenant_id: UUID, payload: TenantUpdatePayload
) -> Optional[Dict[str, Any]]:
    """
    Updates an existing tenant. Only fields present in the payload are updated.
    Returns the updated tenant record as a dictionary, or None if not found or update failed.
    Assumes updated_at is handled by a DB trigger.
    """
    try:
        data_to_update = payload.model_dump(exclude_unset=True)
        if not data_to_update:
            logger.info(f"No fields to update for tenant_id: {tenant_id}. Returning current record.")
            return await get_tenant(db, tenant_id)

        response = db.table(TENANTS_TABLE).update(data_to_update).eq("tenant_id", str(tenant_id)).execute()

        if response.data and len(response.data) > 0:
            updated_tenant = response.data[0]
            logger.info(f"Tenant updated: {tenant_id}. New company name: {updated_tenant.get('company_name')}")
            return updated_tenant
        else:
            logger.warning(
                f"Failed to update tenant {tenant_id} (it may not exist or no data returned). "
                f"Update payload: {data_to_update}. Supabase response: {response.model_dump_json() if hasattr(response, 'model_dump_json') else str(response)}"
            )
            return None
    except Exception as e:
        logger.error(f"Exception updating tenant {tenant_id}: {e}", exc_info=True)
        return None

async def delete_tenant(db: Client, tenant_id: UUID, hard_delete: bool = False) -> bool:
    """
    Logically or physically deletes a tenant.
    For logical delete, sets is_deleted = True.
    Returns True if operation was successful (or record already in desired state for logical delete),
    False on error or if record not found for hard delete.
    """
    try:
        if hard_delete:
            logger.warning(f"Performing HARD delete for tenant_id: {tenant_id}")
            response = db.table(TENANTS_TABLE).delete().eq("tenant_id", str(tenant_id)).execute()
            # For hard delete, success means data was returned (i.e., something was deleted)
            if response.data and len(response.data) > 0:
                 logger.info(f"Tenant hard deleted: {tenant_id}")
                 return True
            logger.warning(f"Tenant {tenant_id} not found for hard delete, or no data returned from operation.")
            return False # Nothing was deleted
        else: # Logical delete
            # Check if already deleted to avoid unnecessary update and log spam
            current_tenant = await get_tenant(db, tenant_id)
            if current_tenant is None:
                logger.warning(f"Tenant {tenant_id} not found for logical delete.")
                return False # Not found
            if current_tenant.get("is_deleted") is True:
                logger.info(f"Tenant {tenant_id} is already logically deleted.")
                return True # Already in desired state

            response = db.table(TENANTS_TABLE).update({"is_deleted": True}).eq("tenant_id", str(tenant_id)).execute()
            if response.data and len(response.data) > 0:
                logger.info(f"Tenant logically deleted: {tenant_id}")
                return True
            logger.warning(f"Failed to logically delete tenant {tenant_id} (no data returned from update).")
            return False # Update didn't affect any rows as expected

    except Exception as e:
        logger.error(f"Exception during delete operation for tenant {tenant_id} (hard_delete={hard_delete}): {e}", exc_info=True)
        return False
