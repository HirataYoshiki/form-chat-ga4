{
  "files": [
    {
      "path": ".env.example",
      "content": "# .env.example - Environment variables for the Contact Form Widget application\n\n# --- AI Agent Settings ---\n\n# Specifies the Gemini model to be used by the AI agent.\n# Default is \"gemini-1.5-flash-latest\" if not set here and not overridden in code.\nGEMINI_MODEL_NAME=\"gemini-1.5-flash-latest\"\n\n# Google API Key for accessing Google Cloud services, including the Gemini API.\n# This is optional if Application Default Credentials (ADC) are already set up\n# in the environment where the application runs, as the Google ADK might pick those up.\n# If you have a specific API key you need to use, uncomment the line below and provide your key.\n# GOOGLE_API_KEY=\"\"\n\n# --- Supabase Connection Settings (Ensure these are set if using Supabase) ---\n# SUPABASE_URL=\"YOUR_SUPABASE_URL\"\n# SUPABASE_SERVICE_ROLE_KEY=\"YOUR_SUPABASE_SERVICE_ROLE_KEY\"\n\n# --- Supabase Auth Settings ---\n# JWKS URI for verifying Supabase JWTs. Usually: YOUR_SUPABASE_URL/auth/v1/jwks\n# SUPABASE_JWKS_URI=\"YOUR_SUPABASE_PROJECT_URL/.well-known/jwks.json\" # Or YOUR_SUPABASE_URL/auth/v1/jwks\n\n# Supabase JWT Audience (usually 'authenticated')\nSUPABASE_JWT_AUDIENCE=\"authenticated\"\n# Supabase JWT Issuer (e.g., https://your-project-ref.supabase.co/auth/v1)\n# This can often be derived from SUPABASE_URL, but explicit is fine too.\n# If your SUPABASE_URL is https://<project-ref>.supabase.co, then issuer is SUPABASE_URL + /auth/v1\n# SUPABASE_JWT_ISSUER=\"YOUR_SUPABASE_PROJECT_URL/auth/v1\"\n\n# --- AI Agent Retry Settings ---\n# Maximum number of retry attempts for AI agent calls\nAI_AGENT_RETRY_ATTEMPTS=3\n# Initial wait time in seconds before the first retry\nAI_AGENT_RETRY_WAIT_INITIAL_SECONDS=1\n# Maximum wait time in seconds between retries (using exponential backoff)\nAI_AGENT_RETRY_WAIT_MAX_SECONDS=10\n# Multiplier for exponential backoff (e.g., 2 means 1s, 2s, 4s, ...)\nAI_AGENT_RETRY_WAIT_MULTIPLIER=2\n\n# --- Other Potential Settings (Examples - Not currently in use by config.py but good for future) ---\n# DATABASE_URL=\"postgresql://user:pass@host:port/dbname\"\n# LOG_LEVEL=\"INFO\"\n"
    },
    {
      "path": ".gitignore",
      "content": "# Environment variables\n.env\n\n# Python bytecode\n__pycache__/\n*.pyc\n*.pyo\n*.pyd\n\n# OS-specific\n.DS_Store\nThumbs.db\n\n# IDE specific\n.vscode/\n.idea/\n"
    },
    {
      "path": ".sample.env",
      "content": "# .sample.env\n# Rename this file to .env and fill in your actual values.\n# Do NOT commit your .env file to version control.\n\n# Configuration for the AI Agent\nGEMINI_MODEL_NAME=\"gemini-2.0-flash\"\n\n# Google Cloud API Key (if using API key authentication for Gemini)\n# Ensure this key has permissions for the Gemini API or Vertex AI API.\nGOOGLE_API_KEY=\"YOUR_GOOGLE_API_KEY_HERE\"\n\n# Alternatively, for Application Default Credentials (ADC), \n# you might set GOOGLE_APPLICATION_CREDENTIALS in your environment\n# to point to your service account JSON key file.\n# GOOGLE_APPLICATION_CREDENTIALS=\"/path/to/your/service-account-file.json\"\n"
    },
    {
      "path": "Makefile",
      "content": "# Makefile for Contact Form Widget Project\n\n.PHONY: dev build test clean logs restart help\n\ndev:\n\t@echo \"Makefile: Starting development environment (placeholder)...\"\n\t@echo \"Typically, this would run: docker-compose up --build -d\"\n\t@echo \"Then you might want to tail logs with 'make logs'\"\n\nbuild:\n\t@echo \"Makefile: Building production assets (placeholder)...\"\n\t@echo \"For frontend: cd frontend && npm install && npm run build (or yarn build)\"\n\t@echo \"For backend: Potentially 'docker build -t contact-widget-backend backend' and 'docker build -t contact-widget-frontend frontend'\"\n\t@echo \"This target might also include steps like code generation or other pre-compilation tasks.\"\n\ntest:\n\t@echo \"Makefile: Running tests (placeholder)...\"\n\t@echo \"For frontend: cd frontend && npm test (or yarn test)\"\n\t@echo \"For backend: cd backend && pytest (or your chosen Python test runner)\"\n\t@echo \"Consider running linters and formatters here too.\"\n\nclean:\n\t@echo \"Makefile: Cleaning up (e.g., removing Docker containers, build artifacts, caches) (placeholder)...\"\n\t@echo \"Typically, this would run: docker-compose down -v --remove-orphans\"\n\t@echo \"Also consider removing: node_modules, __pycache__, .pytest_cache, build artifacts etc.\"\n\t@echo \"Example: rm -rf frontend/node_modules frontend/dist backend/__pycache__\"\n\nlogs:\n\t@echo \"Makefile: Tailing logs from services (placeholder)...\"\n\t@echo \"Typically, this would run: docker-compose logs -f\"\n\t@echo \"You can also target specific services, e.g., 'docker-compose logs -f backend_service'\"\n\nrestart:\n\t@echo \"Makefile: Restarting services (placeholder)...\"\n\t@echo \"Typically, this would run: docker-compose restart\"\n\t@echo \"Or for specific services: docker-compose restart backend_service frontend_service\"\n\nhelp:\n\t@echo \"Available commands for Contact Form Widget Project:\"\n\t@echo \"\"\n\t@echo \"  Development:\"\n\t@echo \"    make dev      - Start the development environment (e.g., using Docker Compose).\"\n\t@echo \"    make logs     - View live logs from running services.\"\n\t@echo \"    make restart  - Restart all or specific services.\"\n\t@echo \"    make clean    - Stop services, remove containers, volumes, and build artifacts.\"\n\t@echo \"\"\n\t@echo \"  Build & Test:\"\n\t@echo \"    make build    - Build frontend and backend assets for production.\"\n\t@echo \"    make test     - Run automated tests for frontend and backend.\"\n\t@echo \"\"\n\t@echo \"  General:\"\n\t@echo \"    make help     - Show this help message.\"\n\t@echo \"\"\n\t@echo \"Note: Most commands are currently placeholders. Actual commands will be added later.\"\n"
    },
    {
      "path": "README.md",
      "content": "# ğŸ“ Contact Form Widget\n\n**1è¡Œã®ã‚³ãƒ¼ãƒ‰ã§åŸ‹ã‚è¾¼ã¿å¯èƒ½ãªãŠå•ã„åˆã‚ã›ãƒ•ã‚©ãƒ¼ãƒ ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆ**\n\né›¶ç´°ä¸­å°ä¼æ¥­å‘ã‘ã«è¨­è¨ˆã•ã‚ŒãŸã€ç°¡å˜å°å…¥ãƒ»é«˜æ©Ÿèƒ½ãªãŠå•ã„åˆã‚ã›ãƒ•ã‚©ãƒ¼ãƒ ã‚µãƒ¼ãƒ“ã‚¹ã§ã™ã€‚\n\n## âœ¨ ç‰¹å¾´\n\n- ğŸš€ **1è¡ŒåŸ‹ã‚è¾¼ã¿**: `<script>`ã‚¿ã‚°1ã¤ã§å³åº§ã«å°å…¥å®Œäº†\n- ğŸ“± **ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ**: ãƒ¢ãƒã‚¤ãƒ«ãƒ»ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—è‡ªå‹•èª¿æ•´\n- ğŸ¨ **ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºå¯èƒ½**: ãƒ†ãƒ¼ãƒãƒ»ä½ç½®ãƒ»æ–‡è¨€ã‚’è‡ªç”±è¨­å®š\n- âœ… **ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³**: å…¥åŠ›ã‚¨ãƒ©ãƒ¼ã‚’å³åº§ã«è¡¨ç¤º\n- ğŸ“§ **è‡ªå‹•é€šçŸ¥**: Slackãƒ»ãƒ¡ãƒ¼ãƒ«ãƒ»è‡ªå‹•è¿”ä¿¡ã«å¯¾å¿œ\n- ğŸ›¡ï¸ **ã‚¹ã‚¿ã‚¤ãƒ«éš”é›¢**: Shadow DOMã§æ—¢å­˜ã‚µã‚¤ãƒˆã¨å¹²æ¸‰ã—ãªã„\n- ğŸ’¾ **ãƒ‡ãƒ¼ã‚¿ä¿å­˜**: Supabaseé€£æºã§ç¢ºå®Ÿã«ãƒ‡ãƒ¼ã‚¿ã‚’ä¿ç®¡\n- ğŸ“ˆ **GA4é€£æº**: Google Analytics 4ã¸ã®ã‚¤ãƒ™ãƒ³ãƒˆé€ä¿¡ï¼ˆMeasurement ProtocolçµŒç”±ï¼‰ã«å¯¾å¿œã—ã€ãƒªãƒ¼ãƒ‰ç²å¾—çŠ¶æ³ã‚„é¡§å®¢ã‚¨ãƒ³ã‚²ãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆã‚’ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°ã€‚\n- âš¡ **é«˜é€Ÿè¡¨ç¤º**: æœ€é©åŒ–ã•ã‚ŒãŸãƒãƒ³ãƒ‰ãƒ«ã‚µã‚¤ã‚º\n\n## ğŸš€ ã‚¯ã‚¤ãƒƒã‚¯ã‚¹ã‚¿ãƒ¼ãƒˆ\n\n### 1. åŸºæœ¬çš„ãªåŸ‹ã‚è¾¼ã¿\n\nãŠå®¢æ§˜ã®ã‚µã‚¤ãƒˆã«ä»¥ä¸‹ã®1è¡Œã‚’è¿½åŠ ã™ã‚‹ã ã‘ï¼š\n\n```html\n<script src=\"https://yourservice.com/contact-widget.js\" data-form-id=\"default-form\"></script>\n```\n\n### 2. ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã—ãŸåŸ‹ã‚è¾¼ã¿\n\n```html\n<script src=\"https://yourservice.com/contact-widget.js\" \n        data-form-id=\"product-inquiry\"\n        data-theme=\"dark\"\n        data-position=\"bottom-left\"\n        data-title=\"è£½å“ã«ã¤ã„ã¦\"\n        data-button-text=\"è£½å“ã‚’å•ã„åˆã‚ã›ã‚‹\"></script>\n```\n\n## ğŸ“‹ è¨­å®šã‚ªãƒ—ã‚·ãƒ§ãƒ³\n\n| ã‚ªãƒ—ã‚·ãƒ§ãƒ³ | èª¬æ˜ | ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ | ä¾‹ |\n|-----------|------|-------------|-----|\n| `data-form-id` | ãƒ•ã‚©ãƒ¼ãƒ IDï¼ˆå¿…é ˆï¼‰ | - | `\"default-form\"` |\n| `data-api-endpoint` | APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ | æœ¬ç•ªURL | `\"https://api.example.com\"` |\n| `data-theme` | ãƒ†ãƒ¼ãƒ | `\"light\"` | `\"light\"` / `\"dark\"` |\n| `data-position` | è¡¨ç¤ºä½ç½® | `\"bottom-right\"` | `\"bottom-right\"` / `\"bottom-left\"` / `\"center\"` |\n| `data-title` | ãƒ•ã‚©ãƒ¼ãƒ ã‚¿ã‚¤ãƒˆãƒ« | `\"ãŠå•ã„åˆã‚ã›\"` | `\"è£½å“ã«ã¤ã„ã¦\"` |\n| `data-button-text` | ãƒœã‚¿ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ | `\"ãŠå•ã„åˆã‚ã›\"` | `\"ä»Šã™ãç›¸è«‡\"` |\n\n## ğŸ’» JavaScript API\n\nãƒ—ãƒ­ã‚°ãƒ©ãƒãƒ†ã‚£ãƒƒã‚¯ãªåˆ¶å¾¡ã‚‚å¯èƒ½ï¼š\n\n```javascript\n// ãƒ•ã‚©ãƒ¼ãƒ ã‚’è¡¨ç¤º\nwindow.ContactFormWidget.init({\n  formId: 'dynamic-form',\n  theme: 'light',\n  position: 'center',\n  title: 'ãŠå•ã„åˆã‚ã›',\n  buttonText: 'ãŠå•ã„åˆã‚ã›ã™ã‚‹'\n});\n\n// ãƒ•ã‚©ãƒ¼ãƒ ã‚’éè¡¨ç¤º\nwindow.ContactFormWidget.destroy();\n```\n\n## ğŸ¯ ä½¿ç”¨ä¾‹\n\n### WordPress\n```php\n// functions.phpã«è¿½åŠ \nfunction add_contact_form_widget() {\n    echo '<script src=\"https://yourservice.com/contact-widget.js\" data-form-id=\"wordpress-form\"></script>';\n}\nadd_action('wp_footer', 'add_contact_form_widget');\n```\n\n### Shopify\n```html\n<!-- theme.liquidã«è¿½åŠ  -->\n<script src=\"https://yourservice.com/contact-widget.js\" \n        data-form-id=\"shopify-form\"\n        data-title=\"å•†å“ã«ã¤ã„ã¦\"></script>\n```\n\n### æ¡ä»¶ä»˜ãè¡¨ç¤º\n```javascript\n// 10ç§’å¾Œã«è‡ªå‹•è¡¨ç¤º\nsetTimeout(() => {\n  window.ContactFormWidget.init({\n    formId: 'auto-popup',\n    title: 'ã¾ã ãŠæ¢ã—ã§ã™ã‹ï¼Ÿ'\n  });\n}, 10000);\n```\n\n## ğŸ”§ é–‹ç™ºç’°å¢ƒã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—\n\n### å‰ææ¡ä»¶\n\n- Node.js 18+\n- Python 3.11+\n- Docker & Docker Compose\n\n### 1. ãƒªãƒã‚¸ãƒˆãƒªã‚’ã‚¯ãƒ­ãƒ¼ãƒ³\n\n```bash\ngit clone https://github.com/yourcompany/contact-form-widget.git\ncd contact-form-widget\n```\n\n### 2. ç’°å¢ƒå¤‰æ•°ã‚’è¨­å®š\n\n```bash\ncp .env.example .env\n# .envãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç·¨é›†ã—ã¦Supabaseã®æ¥ç¶šæƒ…å ±ã‚„ãã®ä»–ã®APIã‚­ãƒ¼ã‚’è¨­å®š\n# ä¾‹:\n# SUPABASE_URL=\"YOUR_SUPABASE_URL\"\n# SUPABASE_SERVICE_ROLE_KEY=\"YOUR_SUPABASE_SERVICE_ROLE_KEY\"\n# GEMINI_MODEL_NAME=\"gemini-1.5-flash-latest\"\n# # GOOGLE_API_KEY=\"YOUR_GOOGLE_API_KEY\" # (AI Agentç”¨ã€ADCãŒãªã‘ã‚Œã°)\n# # GA4é–¢é€£ã®APIã‚­ãƒ¼ã¨æ¸¬å®šIDã¯ã€APIçµŒç”±ã§ãƒ•ã‚©ãƒ¼ãƒ ã”ã¨ã«è¨­å®šã—ã¾ã™ã€‚\n```\n\n### 3. é–‹ç™ºç’°å¢ƒã‚’èµ·å‹•\n\n```bash\n# Docker Composeã§èµ·å‹•\nmake dev\n\n# ã¾ãŸã¯æ‰‹å‹•ã§èµ·å‹•\ndocker-compose up --build\n```\n\n### 4. ã‚¢ã‚¯ã‚»ã‚¹ç¢ºèª\n\n- **ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ï¼ˆç®¡ç†ç”»é¢ï¼‰**: http://localhost:3000\n- **ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆé–‹ç™ºã‚µãƒ¼ãƒãƒ¼**: http://localhost:5173\n- **ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰API**: http://localhost:8000\n- **API ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ**: http://localhost:8000/docs\n\n## ğŸ”— APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆæ¦‚è¦\n\nä¸»è¦ãªAPIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚è©³ç´°ã¯ `/docs` (Swagger UI) ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚\n\n-   **`POST /submit`**:\n    -   ãŠå•ã„åˆã‚ã›ãƒ•ã‚©ãƒ¼ãƒ ã‹ã‚‰ã®ãƒ‡ãƒ¼ã‚¿ã‚’å—ã‘ä»˜ã‘ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ä¿å­˜ã—ã¾ã™ã€‚\n    -   ä¿å­˜æˆåŠŸå¾Œã€GA4ã« `generate_lead` ã‚¤ãƒ™ãƒ³ãƒˆã‚’é€ä¿¡ã—ã¾ã™ï¼ˆãƒ•ã‚©ãƒ¼ãƒ ã«GA4è¨­å®šãŒã•ã‚Œã¦ã„ã‚‹å ´åˆï¼‰ã€‚\n-   **`POST /chat`**:\n    -   AIãƒãƒ£ãƒƒãƒˆãƒœãƒƒãƒˆã¨ã®å¯¾è©±ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‡¦ç†ã—ã¾ã™ã€‚\n-   **`POST /api/v1/ga_configurations`**:\n    -   æ–°ã—ã„ãƒ•ã‚©ãƒ¼ãƒ ã«å¯¾ã™ã‚‹GA4è¨­å®šï¼ˆæ¸¬å®šIDã€APIã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆç­‰ï¼‰ã‚’ç™»éŒ²ã—ã¾ã™ã€‚\n-   **`GET /api/v1/ga_configurations`**:\n    -   ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹å…¨ã¦ã®ãƒ•ã‚©ãƒ¼ãƒ GA4è¨­å®šã‚’ãƒªã‚¹ãƒˆã—ã¾ã™ã€‚\n-   **`GET /api/v1/ga_configurations/{form_id}`**:\n    -   æŒ‡å®šã•ã‚ŒãŸ `form_id` ã®GA4è¨­å®šã‚’å–å¾—ã—ã¾ã™ã€‚\n-   **`PUT /api/v1/ga_configurations/{form_id}`**:\n    -   æŒ‡å®šã•ã‚ŒãŸ `form_id` ã®GA4è¨­å®šã‚’æ›´æ–°ã—ã¾ã™ã€‚\n-   **`DELETE /api/v1/ga_configurations/{form_id}`**:\n    -   æŒ‡å®šã•ã‚ŒãŸ `form_id` ã®GA4è¨­å®šã‚’å‰Šé™¤ã—ã¾ã™ã€‚\n-   **`PATCH /api/v1/submissions/{submission_id}/status`**:\n    -   æŒ‡å®šã•ã‚ŒãŸå•ã„åˆã‚ã› (`submission_id`) ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’æ›´æ–°ã—ã¾ã™ã€‚\n    -   ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å¤‰æ›´ã«å¿œã˜ã¦ã€é©åˆ‡ãªã‚¤ãƒ™ãƒ³ãƒˆã‚’GA4ã«é€ä¿¡ã—ã¾ã™ï¼ˆãƒ•ã‚©ãƒ¼ãƒ ã«GA4è¨­å®šãŒã•ã‚Œã¦ã„ã‚‹å ´åˆï¼‰ã€‚\n\n## ğŸ“ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹æˆ\n\n```\ncontact-form-widget/\nâ”œâ”€â”€ frontend/                          # React ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰\nâ”‚   â””â”€â”€ src/ # ... (è©³ç´°ã¯çœç•¥)\nâ”œâ”€â”€ backend/\nâ”‚   â”œâ”€â”€ routers/\nâ”‚   â”‚   â”œâ”€â”€ form_ga_config_router.py   # GA4è¨­å®šç®¡ç†APIãƒ«ãƒ¼ã‚¿ãƒ¼\nâ”‚   â”‚   â””â”€â”€ submission_router.py       # å•ã„åˆã‚ã›ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç®¡ç†APIãƒ«ãƒ¼ã‚¿ãƒ¼\nâ”‚   â”œâ”€â”€ services/\nâ”‚   â”‚   â”œâ”€â”€ form_ga_config_service.py  # GA4è¨­å®šç®¡ç†ã‚µãƒ¼ãƒ“ã‚¹\nâ”‚   â”‚   â”œâ”€â”€ ga4_mp_service.py          # GA4 MPã‚¤ãƒ™ãƒ³ãƒˆé€ä¿¡ã‚µãƒ¼ãƒ“ã‚¹\nâ”‚   â”‚   â””â”€â”€ submission_service.py      # å•ã„åˆã‚ã›ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç®¡ç†ã‚µãƒ¼ãƒ“ã‚¹\nâ”‚   â”œâ”€â”€ models/\nâ”‚   â”‚   â”œâ”€â”€ ga4_config_models.py       # GA4è¨­å®šAPIç”¨Pydanticãƒ¢ãƒ‡ãƒ«\nâ”‚   â”‚   â””â”€â”€ submission_models.py       # å•ã„åˆã‚ã›ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹APIç”¨Pydanticãƒ¢ãƒ‡ãƒ«\nâ”‚   â”œâ”€â”€ contact_api.py                 # FastAPIãƒ¡ã‚¤ãƒ³ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³\nâ”‚   â”œâ”€â”€ ai_agent.py                    # AIãƒãƒ£ãƒƒãƒˆãƒœãƒƒãƒˆãƒ­ã‚¸ãƒƒã‚¯\nâ”‚   â”œâ”€â”€ config.py                      # ç’°å¢ƒå¤‰æ•°ãƒ»è¨­å®šç®¡ç†\nâ”‚   â”œâ”€â”€ db.py                          # Supabaseã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆåˆæœŸåŒ–\nâ”‚   â””â”€â”€ requirements.txt               # Pythonä¾å­˜é–¢ä¿‚\nâ”œâ”€â”€ database/\nâ”‚   â”œâ”€â”€ contact_form_schema.sql        # å•ã„åˆã‚ã›ãƒ‡ãƒ¼ã‚¿ãƒ†ãƒ¼ãƒ–ãƒ«ã‚¹ã‚­ãƒ¼ãƒ\nâ”‚   â””â”€â”€ form_ga_configurations_schema.sql # GA4è¨­å®šãƒ†ãƒ¼ãƒ–ãƒ«ã‚¹ã‚­ãƒ¼ãƒ (Added)\nâ”œâ”€â”€ examples/                          # å„ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã®ä½¿ç”¨ä¾‹\nâ”‚   â”œâ”€â”€ form_widget_loader.ts\nâ”‚   â””â”€â”€ usage_examples.html\nâ”œâ”€â”€ docker-compose.yml                 # Docker Composeè¨­å®š\nâ”œâ”€â”€ Makefile                           # é–‹ç™ºç”¨Makefile\nâ””â”€â”€ README.md                          # æœ¬ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ\n```\n\n## ğŸ› ï¸ åˆ©ç”¨å¯èƒ½ãªã‚³ãƒãƒ³ãƒ‰\n\n```bash\nmake dev          # é–‹ç™ºç’°å¢ƒèµ·å‹•\nmake build        # æœ¬ç•ªãƒ“ãƒ«ãƒ‰\nmake test         # ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ\nmake clean        # ã‚³ãƒ³ãƒ†ãƒŠå‰Šé™¤\nmake logs         # ãƒ­ã‚°ç¢ºèª\nmake restart      # å†èµ·å‹•\n```\n\n## ğŸš€ ãƒ‡ãƒ—ãƒ­ã‚¤\n\n### Vercel (ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰)\n\n```bash\ncd frontend\nvercel --prod\n```\n\n### Railway (ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰)\n\n```bash\ncd backend\nrailway deploy\n```\n\n### Supabase (ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹)\n\n1. [Supabase](https://supabase.com)ã§ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä½œæˆ\n2. `database/contact_form_schema.sql`ã‚’å®Ÿè¡Œ\n3. ç’°å¢ƒå¤‰æ•°ã«URLãƒ»KEYã‚’è¨­å®š\n\n## ğŸ“Š æ©Ÿèƒ½ä¸€è¦§\n\n### ãƒ•ã‚©ãƒ¼ãƒ æ©Ÿèƒ½\n- [x] åŸºæœ¬é …ç›®ï¼ˆåå‰ãƒ»ãƒ¡ãƒ¼ãƒ«ãƒ»ä¼šç¤¾ãƒ»é›»è©±ãƒ»ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼‰\n- [x] ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³\n- [x] é€ä¿¡ä¸­ãƒ»å®Œäº†çŠ¶æ…‹ã®è¡¨ç¤º\n- [x] ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ‡ã‚¶ã‚¤ãƒ³\n\n### é€šçŸ¥æ©Ÿèƒ½\n- [ ] ç®¡ç†è€…ãƒ¡ãƒ¼ãƒ«é€šçŸ¥ (é–‹ç™ºå„ªå…ˆåº¦ ä½)\n- [ ] é¡§å®¢è‡ªå‹•è¿”ä¿¡ãƒ¡ãƒ¼ãƒ« (é–‹ç™ºå„ªå…ˆåº¦ ä½)\n- [ ] Slacké€šçŸ¥ (é–‹ç™ºå„ªå…ˆåº¦ ä½)\n- [ ] SMSé€šçŸ¥ (é–‹ç™ºå„ªå…ˆåº¦ ä½)\n- [ ] Discordé€šçŸ¥ (é–‹ç™ºå„ªå…ˆåº¦ ä½)\n\n### ç®¡ç†æ©Ÿèƒ½\n- [x] é€ä¿¡ãƒ‡ãƒ¼ã‚¿ã®ä¿å­˜\n- [ ] ãƒ‡ãƒ¼ã‚¿åˆ†æ (GA4é€£æºã«ã‚ˆã‚Šé«˜åº¦ãªåˆ†æãŒå¯èƒ½)\n- [ ] ç®¡ç†ç”»é¢UIï¼ˆé–‹ç™ºä¸­ï¼‰\n- [ ] è©³ç´°åˆ†æ (GA4ã‚’æ´»ç”¨)\n\n### ğŸ“ˆ GA4é€£æºæ©Ÿèƒ½\n- [x] ãƒ•ã‚©ãƒ¼ãƒ é€ä¿¡æ™‚ã« `generate_lead` ã‚¤ãƒ™ãƒ³ãƒˆã‚’GA4ã«é€ä¿¡ (Measurement ProtocolçµŒç”±)\n- [x] å•ã„åˆã‚ã›ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å¤‰æ›´æ™‚ã«å¯¾å¿œã™ã‚‹GA4ã‚¤ãƒ™ãƒ³ãƒˆã‚’é€ä¿¡ (ä¾‹: `working_lead`, `qualify_lead`, `close_convert_lead`)\n- [x] ãƒ•ã‚©ãƒ¼ãƒ ã”ã¨ã®GA4æ¸¬å®šIDãƒ»APIã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆè¨­å®šæ©Ÿèƒ½ (å°‚ç”¨APIçµŒç”±ã§ç®¡ç†)\n\n\n\n---\n\n**Made with â¤ï¸ for small businesses**\n"
    },
    {
      "path": "docker-compose.yml",
      "content": "version: '3.8'\n\n# This is a basic placeholder docker-compose.yml for development.\n#\n# Key considerations for a real setup:\n# 1. Dockerfiles: Each service (frontend, backend) will need its own Dockerfile\n#    (e.g., Dockerfile.dev or simply Dockerfile) in its respective directory.\n#    These files define how the application image is built, dependencies installed,\n#    and how the application starts.\n# 2. Build vs. Image: The commented-out 'build' sections are what you'd use\n#    when you have Dockerfiles. For this placeholder, pre-built images are used.\n# 3. Volumes: Volumes are crucial for development as they map your local code\n#    into the container, allowing for live reloading.\n# 4. Environment Variables: Use .env files for sensitive or environment-specific\n#    configurations and reference them here.\n# 5. Networking: For services to communicate by name (e.g., frontend calling backend),\n#    Docker Compose sets up a default network. More complex network configurations\n#    can be defined if needed.\n# 6. Database: A database service (e.g., Postgres for Supabase compatibility)\n#    could be defined here if you were running it locally. Since this project\n#    targets Supabase, the database is external.\n# 7. Production: For production, you'd typically have a separate docker-compose.prod.yml\n#    or use different settings within the Dockerfiles (multi-stage builds).\n\nservices:\n  frontend:\n    # build:\n    #   context: ./frontend\n    #   dockerfile: Dockerfile.dev  # Placeholder: Dockerfile needs to be created in ./frontend\n    image: node:18-alpine  # Using a pre-built Node.js image for placeholder\n    container_name: contact_form_frontend_dev\n    command: sh -c \"echo 'Frontend container running (placeholder). In a real setup, this would run your dev server (e.g., npm start).' && tail -f /dev/null\"\n    ports:\n      - \"3000:3000\"  # Standard port for React/Vue/Angular dev servers\n    volumes:\n      # Mount the local frontend directory into the container for live reloading.\n      # The Dockerfile would typically set /app as the working directory and copy package.json, run npm install, etc.\n      - ./frontend:/app\n      # Example for node_modules (can improve performance on some systems, but often not needed initially):\n      # - /app/node_modules\n    working_dir: /app # Assumes your frontend Dockerfile sets this up and runs npm install\n    environment:\n      - NODE_ENV=development\n      # Add other frontend specific environment variables here\n      # e.g., REACT_APP_API_URL=http://localhost:8000/api\n    restart: unless-stopped\n\n  backend:\n    # build:\n    #   context: ./backend\n    #   dockerfile: Dockerfile.dev  # Placeholder: Dockerfile needs to be created in ./backend\n    image: python:3.11-slim  # Using a pre-built Python image for placeholder\n    container_name: contact_form_backend_dev\n    command: sh -c \"echo 'Backend container running (placeholder). In a real setup, this would run your FastAPI/uvicorn server.' && tail -f /dev/null\"\n    ports:\n      - \"8000:8000\"  # Standard port for Python web frameworks like FastAPI/Flask\n    volumes:\n      # Mount the local backend directory into the container for live reloading.\n      # The Dockerfile would typically set /app as the working directory, copy requirements.txt, run pip install, etc.\n      - ./backend:/app\n    working_dir: /app # Assumes your backend Dockerfile sets this up and runs pip install\n    environment:\n      - PYTHONUNBUFFERED=1 # Ensures print statements and logs are sent straight to terminal\n      - APP_ENV=development\n      # Add other backend specific environment variables here\n      # e.g., DATABASE_URL, API_KEYS (preferably via .env file and docker-compose env_file property)\n    restart: unless-stopped\n\n# Notes on further development:\n# - Create Dockerfile.dev for both frontend and backend.\n# - Frontend Dockerfile: Copy package.json, run npm install, expose port, set CMD for dev server.\n# - Backend Dockerfile: Copy requirements.txt, run pip install, expose port, set CMD for uvicorn.\n# - Consider adding a database service if local testing against Postgres is desired.\n# - For production, create Dockerfile (optimized for smaller size, security) and potentially a\n#   separate docker-compose.prod.yml or override file.\n"
    },
    {
      "path": "backend/README.md",
      "content": "# Contact Form Widget - Backend\n\nã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯ã€Contact Form Widgetãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«é–¢ã™ã‚‹æŠ€è¡“çš„ãªè©³ç´°ã€ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—æ‰‹é †ã€APIä»•æ§˜ã«ã¤ã„ã¦èª¬æ˜ã—ã¾ã™ã€‚\n\n## 1. æ¦‚è¦ (Overview)\n\nãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯ã€Contact Form Widgetã‹ã‚‰é€ä¿¡ã•ã‚Œã‚‹ãŠå•ã„åˆã‚ã›ãƒ‡ãƒ¼ã‚¿ã®å—ä»˜ã€ä¿å­˜ã€ãŠã‚ˆã³ç®¡ç†æ©Ÿèƒ½ã‚’æä¾›ã—ã¾ã™ã€‚ãƒãƒ«ãƒãƒ†ãƒŠãƒ³ãƒˆã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã‚’æ¡ç”¨ã—ã¦ãŠã‚Šã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆä¼æ¥­ï¼ˆãƒ†ãƒŠãƒ³ãƒˆï¼‰ã”ã¨ã«ãƒ‡ãƒ¼ã‚¿ã‚’åˆ†é›¢ãƒ»ç®¡ç†ã§ãã¾ã™ã€‚ã¾ãŸã€AIãƒãƒ£ãƒƒãƒˆãƒœãƒƒãƒˆæ©Ÿèƒ½ã€Google Analytics 4 (GA4) ã¸ã®ã‚¤ãƒ™ãƒ³ãƒˆé€ä¿¡æ©Ÿèƒ½ã‚‚æ‹…ã„ã¾ã™ã€‚\n\nä¸»ãªæ©Ÿèƒ½ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚\n\n-   **ãƒãƒ«ãƒãƒ†ãƒŠãƒ³ãƒˆå¯¾å¿œ**: å„ãƒ†ãƒŠãƒ³ãƒˆã¯è‡ªèº«ã®ãƒ•ã‚©ãƒ¼ãƒ ã€å•ã„åˆã‚ã›ãƒ‡ãƒ¼ã‚¿ã€GA4è¨­å®šã‚’ç‹¬ç«‹ã—ã¦ç®¡ç†ã§ãã¾ã™ã€‚\n-   **ãƒ•ã‚©ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿å‡¦ç†**: ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆã‹ã‚‰ã®å•ã„åˆã‚ã›ãƒ‡ãƒ¼ã‚¿ï¼ˆåå‰ã€ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç­‰ï¼‰ã‚’å—ä¿¡ã—ã€ãƒ†ãƒŠãƒ³ãƒˆã”ã¨ã«ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ä¿å­˜ã—ã¾ã™ã€‚\n-   **AIãƒãƒ£ãƒƒãƒˆãƒœãƒƒãƒˆé€£æº**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰ã®è³ªå•ã«å¯¾ã—ã¦AIï¼ˆGeminiãƒ¢ãƒ‡ãƒ«ã‚’åˆ©ç”¨ï¼‰ãŒå¿œç­”ã™ã‚‹ãƒãƒ£ãƒƒãƒˆæ©Ÿèƒ½ã‚’æä¾›ã—ã¾ã™ã€‚AIã¨ã®é€šä¿¡æ™‚ã«ã¯ã€è¨­å®šã«åŸºã¥ã„ãŸãƒªãƒˆãƒ©ã‚¤å‡¦ç†ãŒå®Ÿè¡Œã•ã‚Œã€ä¸€æ™‚çš„ãªé€šä¿¡ã‚¨ãƒ©ãƒ¼ã«å¯¾ã™ã‚‹å …ç‰¢æ€§ã‚’é«˜ã‚ã¦ã„ã¾ã™ã€‚\n-   **GA4 Measurement Protocolé€£æº**: ãƒ•ã‚©ãƒ¼ãƒ é€ä¿¡æ™‚ã‚„å•ã„åˆã‚ã›ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å¤‰æ›´æ™‚ã«ã€ãƒªãƒ¼ãƒ‰ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³é–¢é€£ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’GA4ã«é€ä¿¡ã—ã¾ã™ã€‚ã“ã®æ©Ÿèƒ½ã‚‚ãƒ†ãƒŠãƒ³ãƒˆã”ã¨ã«è¨­å®šå¯èƒ½ã§ã™ã€‚\n-   **GA4è¨­å®šç®¡ç†**: ãƒ†ãƒŠãƒ³ãƒˆå†…ã®ãƒ•ã‚©ãƒ¼ãƒ ã”ã¨ã«GA4ã®æ¸¬å®šIDã¨APIã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã‚’è¨­å®šãƒ»ç®¡ç†ã™ã‚‹ãŸã‚ã®APIã‚’æä¾›ã—ã¾ã™ã€‚\n-   **å•ã„åˆã‚ã›ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç®¡ç†**: å•ã„åˆã‚ã›ã®é€²æ—ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ï¼ˆæ–°è¦ã€é€£çµ¡æ¸ˆã¿ã€æˆç´„ãªã©ï¼‰ã‚’ç®¡ç†ã—ã€ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å¤‰æ›´ã‚’è¡Œã†ãŸã‚ã®APIã‚’ãƒ†ãƒŠãƒ³ãƒˆã”ã¨ã«æä¾›ã—ã¾ã™ã€‚\n-   **ãƒ†ãƒŠãƒ³ãƒˆç®¡ç† (ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒ¦ãƒ¼ã‚¶ãƒ¼é™å®š)**: ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒ¦ãƒ¼ã‚¶ãƒ¼å‘ã‘ã«ã€ãƒ†ãƒŠãƒ³ãƒˆï¼ˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆä¼æ¥­ã‚¢ã‚«ã‚¦ãƒ³ãƒˆï¼‰ã®ä½œæˆã€ä¸€è¦§è¡¨ç¤ºã€æ›´æ–°ã€å‰Šé™¤ã‚’è¡Œã†APIã‚’æä¾›ã—ã¾ã™ã€‚\n\nã“ã®ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã¯ã€ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã®åŸ‹ã‚è¾¼ã¿ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆã¨é€£æºã—ã¦å‹•ä½œã™ã‚‹ã‚ˆã†ã«è¨­è¨ˆã•ã‚Œã¦ã„ã¾ã™ã€‚èªè¨¼ã¯Supabase Authã‚’åˆ©ç”¨ã—ãŸJWTãƒ™ãƒ¼ã‚¹ã§è¡Œã‚ã‚Œã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«ï¼ˆ`user`, `superuser`ï¼‰ã«å¿œã˜ãŸã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡ãŒé©ç”¨ã•ã‚Œã¾ã™ã€‚\n\n## 2. æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯ (Tech Stack)\n\nãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚·ã‚¹ãƒ†ãƒ ã¯ä»¥ä¸‹ã®ä¸»è¦ãªæŠ€è¡“ã§æ§‹æˆã•ã‚Œã¦ã„ã¾ã™ã€‚\n\n-   **ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èª**: Python 3.11+\n-   **ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯**: FastAPI - é«˜ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãªéåŒæœŸWebãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã€‚\n-   **ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹**: Supabase (PostgreSQL) - `supabase-py` ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’é€šã˜ã¦é€£æºã€‚\n-   **ãƒ‡ãƒ¼ã‚¿ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³**: Pydantic V2 - APIãƒªã‚¯ã‚¨ã‚¹ãƒˆ/ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®å‹å®šç¾©ã¨ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã€‚\n-   **HTTPã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ**: `httpx` - GA4 Measurement Protocol APIãªã©ã€å¤–éƒ¨APIã¨ã®éåŒæœŸé€šä¿¡ã«ä½¿ç”¨ã€‚\n-   **AIé€£æº**: Google Agent Development Kit (ADK) - Geminiãƒ¢ãƒ‡ãƒ«ã‚’åˆ©ç”¨ã—ãŸAIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆæ©Ÿèƒ½ã€‚\n-   **èªè¨¼**: Supabase Auth (JWTãƒ™ãƒ¼ã‚¹ã®èªè¨¼)\n-   **JWTå‡¦ç†**: python-jose[cryptography] (JWTã®ãƒ‡ã‚³ãƒ¼ãƒ‰ã¨æ¤œè¨¼)\n-   **ãƒªãƒˆãƒ©ã‚¤å‡¦ç†**: tenacity - AI Agentãªã©ã®å¤–éƒ¨APIå‘¼ã³å‡ºã—ã«ãŠã‘ã‚‹ãƒªãƒˆãƒ©ã‚¤å‡¦ç†ã«ä½¿ç”¨ã€‚\n-   **ASGIã‚µãƒ¼ãƒãƒ¼**: Uvicorn - FastAPIã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®å®Ÿè¡Œã€‚\n-   **ä¾å­˜é–¢ä¿‚ç®¡ç†**: `pip` ã¨ `requirements.txt`ã€‚\n\n## 3. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹é€  (Project Structure)\n\n`backend/` ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå†…ã®ä¸»è¦ãªã‚µãƒ–ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¨ãƒ•ã‚¡ã‚¤ãƒ«ã®å½¹å‰²ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚\n\n```\nbackend/\nâ”œâ”€â”€ .gitkeep                     # ç©ºãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’Gitç®¡ç†ã™ã‚‹ãŸã‚ã®ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ (ã‚ã‚Œã°)\nâ”œâ”€â”€ ai_agent.py                  # AIãƒãƒ£ãƒƒãƒˆãƒœãƒƒãƒˆã®ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆADKã€Geminié€£æºï¼‰\nâ”œâ”€â”€ auth.py                      # JWTèªè¨¼ãƒ»èªå¯ãƒ­ã‚¸ãƒƒã‚¯\nâ”œâ”€â”€ config.py                    # ç’°å¢ƒå¤‰æ•°ç®¡ç†ï¼ˆPydantic Settingsã«ã‚ˆã‚‹è¨­å®šèª­ã¿è¾¼ã¿ï¼‰\nâ”œâ”€â”€ contact_api.py               # ãƒ¡ã‚¤ãƒ³FastAPIã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å®šç¾©ã€ä¸»è¦ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆï¼ˆ/submit, /chatï¼‰ã€ãƒ«ãƒ¼ã‚¿ãƒ¼ç™»éŒ²\nâ”œâ”€â”€ db.py                        # Supabaseã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®åˆæœŸåŒ–ã¨FastAPIä¾å­˜æ€§æ³¨å…¥ã®æä¾›\nâ”œâ”€â”€ models/                      # Pydanticãƒ¢ãƒ‡ãƒ«å®šç¾©ç”¨ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª\nâ”‚   â”œâ”€â”€ ga4_config_models.py     # GA4è¨­å®šç®¡ç†APIç”¨ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆ/ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ¢ãƒ‡ãƒ«\nâ”‚   â”œâ”€â”€ submission_models.py     # å•ã„åˆã‚ã›ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°APIç”¨ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒ¢ãƒ‡ãƒ«\nâ”‚   â””â”€â”€ tenant_models.py         # ãƒ†ãƒŠãƒ³ãƒˆç®¡ç†APIç”¨ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆ/ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ¢ãƒ‡ãƒ«\nâ”œâ”€â”€ requirements.txt             # Pythonã®ä¾å­˜ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãƒªã‚¹ãƒˆ\nâ”œâ”€â”€ routers/                     # APIãƒ«ãƒ¼ã‚¿ãƒ¼ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ç”¨ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª\nâ”‚   â”œâ”€â”€ form_ga_config_router.py # GA4è¨­å®šç®¡ç†APIã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆå®šç¾©\nâ”‚   â”œâ”€â”€ submission_router.py     # å•ã„åˆã‚ã›ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°APIã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆå®šç¾©\nâ”‚   â””â”€â”€ tenant_router.py         # ãƒ†ãƒŠãƒ³ãƒˆç®¡ç†APIã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆå®šç¾©\nâ”œâ”€â”€ services/                    # ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯å±¤ç”¨ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª\nâ”‚   â”œâ”€â”€ form_ga_config_service.py# GA4è¨­å®šã®CRUDå‡¦ç†ãƒ­ã‚¸ãƒƒã‚¯\nâ”‚   â”œâ”€â”€ ga4_mp_service.py        # GA4 Measurement Protocol APIã¸ã®ã‚¤ãƒ™ãƒ³ãƒˆé€ä¿¡ãƒ­ã‚¸ãƒƒã‚¯\nâ”‚   â”œâ”€â”€ submission_service.py    # å•ã„åˆã‚ã›ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°å‡¦ç†ãƒ­ã‚¸ãƒƒã‚¯\nâ”‚   â””â”€â”€ tenant_service.py        # ãƒ†ãƒŠãƒ³ãƒˆç®¡ç†ã®CRUDå‡¦ç†ãƒ­ã‚¸ãƒƒã‚¯\nâ””â”€â”€ tests/                       # è‡ªå‹•ãƒ†ã‚¹ãƒˆç”¨ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª\n    â”œâ”€â”€ test_contact_api.py      # /submit API (/chat APIã¯æœªå®Ÿè£…) ã®ãƒ†ã‚¹ãƒˆ\n    â”œâ”€â”€ test_form_ga_config_api.py # GA4è¨­å®šç®¡ç†APIã®ãƒ†ã‚¹ãƒˆ\n    â”œâ”€â”€ test_submission_api.py   # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ãƒ»ä¸€è¦§å–å¾—APIã®ãƒ†ã‚¹ãƒˆ\n    â”œâ”€â”€ test_ai_agent.py         # AI Agenté–¢é€£ãƒ­ã‚¸ãƒƒã‚¯ã®ãƒ†ã‚¹ãƒˆ\n    â””â”€â”€ test_tenant_api.py       # ãƒ†ãƒŠãƒ³ãƒˆç®¡ç†APIã®ãƒ†ã‚¹ãƒˆ\n```\n\n-   **`contact_api.py`**: FastAPIã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ (`app`) ã‚’ç”Ÿæˆã—ã€ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã®è¨­å®šã€ä¸»è¦ãªã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆï¼ˆ`/submit`, `/chat`ï¼‰ã€ãŠã‚ˆã³å„æ©Ÿèƒ½ãƒ«ãƒ¼ã‚¿ãƒ¼ã®ç™»éŒ²ã‚’è¡Œã„ã¾ã™ã€‚èªè¨¼æ©Ÿèƒ½ (`get_current_active_user`) ã¯ `auth.py` ã‹ã‚‰ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦åˆ©ç”¨ã—ã¾ã™ã€‚\n-   **`config.py`**: `.env` ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ç’°å¢ƒå¤‰æ•°ã‚’èª­ã¿è¾¼ã¿ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å…¨ä½“ã§åˆ©ç”¨å¯èƒ½ãªè¨­å®šã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æä¾›ã—ã¾ã™ã€‚\n-   **`db.py`**: Supabaseã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’åˆæœŸåŒ–ã—ã€APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã§ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã‚’åˆ©ç”¨ã™ã‚‹ãŸã‚ã®FastAPIä¾å­˜æ€§æ³¨å…¥é–¢æ•° (`get_supabase_client`) ã‚’æä¾›ã—ã¾ã™ã€‚\n-   **`auth.py`**: JWTãƒ™ãƒ¼ã‚¹ã®èªè¨¼ãƒ»èªå¯å‡¦ç†ã‚’å®Ÿè£…ã—ã¾ã™ã€‚Supabaseã‹ã‚‰ç™ºè¡Œã•ã‚ŒãŸJWTã®æ¤œè¨¼ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã®å–å¾—ï¼ˆ`public.users` ãƒ†ãƒ¼ãƒ–ãƒ«çµŒç”±ï¼‰ã€ãƒ­ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡ï¼ˆRBACï¼‰ã®ãŸã‚ã®ä¾å­˜æ€§æ³¨å…¥é–¢æ•° (`get_current_active_user`, `require_superuser_role` ãªã©) ã‚’æä¾›ã—ã¾ã™ã€‚\n-   **`ai_agent.py`**: Google ADKã‚’åˆ©ç”¨ã—ãŸAIãƒãƒ£ãƒƒãƒˆãƒœãƒƒãƒˆã®å¿œç­”ç”Ÿæˆãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚\n-   **`models/`**: APIã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒœãƒ‡ã‚£ã‚„ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒœãƒ‡ã‚£ã®æ§‹é€ ã‚’å®šç¾©ã™ã‚‹Pydanticãƒ¢ãƒ‡ãƒ«ã‚’æ ¼ç´ã—ã¾ã™ã€‚`tenant_models.py` ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚\n-   **`routers/`**: å„æ©Ÿèƒ½ã‚°ãƒ«ãƒ¼ãƒ—ã«å¯¾å¿œã™ã‚‹APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆï¼ˆãƒ‘ã‚¹ã‚ªãƒšãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰ã‚’å®šç¾©ã—ãŸ `APIRouter` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æ ¼ç´ã—ã¾ã™ã€‚`tenant_router.py` ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚\n-   **`services/`**: APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‹ã‚‰å‘¼ã³å‡ºã•ã‚Œã‚‹ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã‚„ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ“ä½œã‚’ã‚«ãƒ—ã‚»ãƒ«åŒ–ã—ãŸé–¢æ•°/ã‚¯ãƒ©ã‚¹ã‚’æ ¼ç´ã—ã¾ã™ã€‚`tenant_service.py` ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚\n-   **`tests/`**: `pytest` ã‚’åˆ©ç”¨ã—ãŸè‡ªå‹•ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã‚’æ ¼ç´ã—ã¾ã™ã€‚å„APIãƒ«ãƒ¼ã‚¿ãƒ¼ã‚„ä¸»è¦ãªã‚µãƒ¼ãƒ“ã‚¹ã«å¯¾å¿œã™ã‚‹ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ãŒå«ã¾ã‚Œã¾ã™ã€‚`test_tenant_api.py` ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚\n\n## 4. ãƒ­ãƒ¼ã‚«ãƒ«é–‹ç™ºç’°å¢ƒã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— (Local Development Setup)\n\nãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒ­ãƒ¼ã‚«ãƒ«ç’°å¢ƒã§ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã—ã€å®Ÿè¡Œã™ã‚‹ãŸã‚ã®æ‰‹é †ã§ã™ã€‚\n\n### å‰ææ¡ä»¶\n-   Python 3.11 ä»¥é™\n-   `pip` (Python ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ©)\n-   Supabaseãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆï¼ˆè©³ç´°ã¯ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆã®README.mdã‚’å‚ç…§ã—ã€ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—æ¸ˆã¿ã§ã‚ã‚‹ã“ã¨ï¼‰\n-   (æ¨å¥¨) Pythonä»®æƒ³ç’°å¢ƒ (`venv`, `conda` ãªã©)\n\n### ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—æ‰‹é †\n1.  **ãƒªãƒã‚¸ãƒˆãƒªã®ã‚¯ãƒ­ãƒ¼ãƒ³** (ã¾ã ã®å ´åˆ):\n    ```bash\n    # git clone <repository_url>\n    # cd <repository_name>/backend\n    # (ãƒªãƒã‚¸ãƒˆãƒªã‚’ã‚¯ãƒ­ãƒ¼ãƒ³å¾Œã€backendãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ç§»å‹•ã—ã¦ã„ã‚‹æƒ³å®šã§ä»¥é™ã‚’è¨˜è¿°)\n    ```\n\n2.  **(æ¨å¥¨) Pythonä»®æƒ³ç’°å¢ƒã®ä½œæˆã¨æœ‰åŠ¹åŒ–** (ä¾‹: `backend` ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå†…ã§):\n    ```bash\n    python -m venv venv\n    source venv/bin/activate  # Linux/macOS\n    # venv\\Scripts\\activate    # Windows (ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚’ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—)\n    ```\n\n3.  **ä¾å­˜é–¢ä¿‚ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«**:\n    `backend` ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªç›´ä¸‹ã§ä»¥ä¸‹ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚\n    ```bash\n    pip install -r requirements.txt\n    ```\n\n4.  **`.env` ãƒ•ã‚¡ã‚¤ãƒ«ã®ä½œæˆã¨è¨­å®š**:\n    *   ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ«ãƒ¼ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ã‚ã‚‹ `.env.example` ã‚’ã‚³ãƒ”ãƒ¼ã—ã€åŒã˜ããƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆã« `.env` ãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ä½œæˆã—ã¾ã™ã€‚\n    *   `.env` ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç·¨é›†ã—ã€ä»¥ä¸‹ã®å¿…é ˆç’°å¢ƒå¤‰æ•°ã‚’è¨­å®šã—ã¦ãã ã•ã„ã€‚\n        ```dotenv\n        SUPABASE_URL=\"YOUR_SUPABASE_PROJECT_URL\"\n        SUPABASE_SERVICE_ROLE_KEY=\"YOUR_SUPABASE_SERVICE_ROLE_KEY\"\n\n        # AI Agentç”¨ (ã‚ªãƒ—ã‚·ãƒ§ãƒ³)\n        # GEMINI_MODEL_NAME=\"gemini-1.5-flash-latest\" # config.pyã«ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚ã‚Š\n        # GOOGLE_API_KEY=\"YOUR_GOOGLE_API_KEY_IF_ADC_IS_NOT_SETUP\"\n\n        # --- Supabase Auth Settings (JWTæ¤œè¨¼ã«å¿…é ˆ) ---\n        # Supabaseãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®JWKS URI (ä¾‹: https://<project-ref>.supabase.co/auth/v1/.well-known/jwks.json)\n        SUPABASE_JWKS_URI=\"YOUR_SUPABASE_JWKS_URI\"\n        # Supabase JWTã®æœŸå¾…ã•ã‚Œã‚‹Audience (é€šå¸¸ 'authenticated')\n        SUPABASE_JWT_AUDIENCE=\"authenticated\"\n        # ã‚ªãƒ—ã‚·ãƒ§ãƒ³: JWTã®Issuerã‚’æ˜ç¤ºçš„ã«è¨­å®šã™ã‚‹å ´åˆ (é€šå¸¸ SUPABASE_URL + \"/auth/v1\" ã‹ã‚‰å°å‡ºå¯èƒ½)\n        # SUPABASE_JWT_ISSUER=\"YOUR_SUPABASE_ISSUER_URL\"\n\n        # --- AI Agent Retry Settings (ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã€config.pyã«ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚ã‚Š) ---\n        # AI Agentã®APIå‘¼ã³å‡ºã—ãƒªãƒˆãƒ©ã‚¤å›æ•°ã®æœ€å¤§å€¤\n        # AI_AGENT_RETRY_ATTEMPTS=3\n        # ãƒªãƒˆãƒ©ã‚¤æ™‚ã®åˆå›å¾…æ©Ÿç§’æ•°\n        # AI_AGENT_RETRY_WAIT_INITIAL_SECONDS=1\n        # ãƒªãƒˆãƒ©ã‚¤æ™‚ã®æœ€å¤§å¾…æ©Ÿç§’æ•°ï¼ˆæŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•åˆ©ç”¨æ™‚ï¼‰\n        # AI_AGENT_RETRY_WAIT_MAX_SECONDS=10\n        # æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•ã®ä¹—æ•° (ä¾‹: 1ç§’å¾Œ, 2ç§’å¾Œ, 4ç§’å¾Œ...)\n        # AI_AGENT_RETRY_WAIT_MULTIPLIER=2\n        ```\n        `GEMINI_MODEL_NAME` ãŠã‚ˆã³AI Agentãƒªãƒˆãƒ©ã‚¤é–¢é€£ã®è¨­å®šã¯ `config.py` ã§ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã™ã€‚ç’°å¢ƒå¤‰æ•°ã§ä¸Šæ›¸ãå¯èƒ½ã§ã™ã€‚`GOOGLE_API_KEY` ã¯Application Default Credentials (ADC) ãŒè¨­å®šã•ã‚Œã¦ã„ã‚Œã°ä¸è¦ãªå ´åˆãŒã‚ã‚Šã¾ã™ã€‚GA4é–¢é€£ã®APIã‚­ãƒ¼ã¨æ¸¬å®šIDã¯ã€APIçµŒç”±ã§ãƒ•ã‚©ãƒ¼ãƒ ã”ã¨ã«ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«è¨­å®šã—ã¾ã™ã€‚\n\n5.  **ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¹ã‚­ãƒ¼ãƒã®é©ç”¨**:\n    Supabaseãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®SQL Editorã‚’ä½¿ç”¨ã—ã¦ã€ä»¥ä¸‹ã®ã‚¹ã‚­ãƒ¼ãƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’é †ç•ªã«å®Ÿè¡Œã—ã€å¿…è¦ãªãƒ†ãƒ¼ãƒ–ãƒ«ã¨ã‚«ãƒ©ãƒ ã‚’ä½œæˆã—ã¾ã™ã€‚\n    (æ³¨æ„: å®Ÿéš›ã®ãƒ•ã‚¡ã‚¤ãƒ«åã¯ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«åˆã‚ã›ã¦ç¢ºèªã—ã¦ãã ã•ã„ã€‚ãƒ•ã‚¡ã‚¤ãƒ«åã«å«ã¾ã‚Œã‚‹ç•ªå·ã¯ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®æ¨å¥¨é©ç”¨é †åºã‚’ç¤ºã—ã¾ã™ã€‚)\n    1.  `database/0001_tenants_schema.sql` (ãƒ†ãƒŠãƒ³ãƒˆç®¡ç†ç”¨ãƒ†ãƒ¼ãƒ–ãƒ« `tenants` ä½œæˆ)\n    2.  `database/0002_user_profiles_schema.sql` (`public.users` ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆã€`auth.users` ã¨é€£æºã€`tenants` ã¨ã®FKè¨­å®š)\n    3.  `database/0003_contact_form_submissions_schema.sql` (æ—§ `contact_form_schema.sql` - å•ã„åˆã‚ã›ä¿å­˜ç”¨ãƒ†ãƒ¼ãƒ–ãƒ« `contact_submissions` ä½œæˆã€`tenant_id` ã‚«ãƒ©ãƒ è¿½åŠ ã¨FKè¨­å®šå«ã‚€)\n    4.  `database/0004_form_ga_configurations_schema.sql` (æ—§ `form_ga_configurations_schema.sql` - ãƒ•ã‚©ãƒ¼ãƒ ã”ã¨ã®GA4è¨­å®šç”¨ãƒ†ãƒ¼ãƒ–ãƒ« `form_ga_configurations` ä½œæˆã€`tenant_id` ã‚«ãƒ©ãƒ è¿½åŠ ã¨FKè¨­å®šå«ã‚€)\n    5.  ä»¥ä¸‹ã®SQL (ã¾ãŸã¯å„ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆã‚¹ã‚­ãƒ¼ãƒã«çµ±åˆã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª) ã‚’å®Ÿè¡Œã—ã¦ `contact_submissions` ãŠã‚ˆã³ãã®ä»–ã®é–¢é€£ãƒ†ãƒ¼ãƒ–ãƒ«ã« `updated_at` ã‚«ãƒ©ãƒ ã¨è‡ªå‹•æ›´æ–°ãƒˆãƒªã‚¬ãƒ¼ã‚’è¿½åŠ :\n        ```sql\n        -- Add updated_at column and auto-update trigger to contact_submissions table (example)\n        ALTER TABLE contact_submissions\n        ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW();\n\n        COMMENT ON COLUMN contact_submissions.updated_at IS 'Timestamp of when this submission record was last updated.';\n\n        CREATE OR REPLACE FUNCTION update_contact_submissions_updated_at_column()\n        RETURNS TRIGGER AS $$\n        BEGIN\n            NEW.updated_at = NOW();\n            RETURN NEW;\n        END;\n        $$ language 'plpgsql';\n\n        CREATE TRIGGER trigger_update_contact_submissions_updated_at\n        BEFORE UPDATE ON contact_submissions\n        FOR EACH ROW\n        EXECUTE FUNCTION update_contact_submissions_updated_at_column();\n        ```\n        (åŒæ§˜ã®ãƒˆãƒªã‚¬ãƒ¼ã‚’ `tenants`, `users`, `form_ga_configurations` ã«ã‚‚è¨­å®šã™ã‚‹ã“ã¨ã‚’æ¨å¥¨ã—ã¾ã™ã€‚)\n\n6.  **é–‹ç™ºã‚µãƒ¼ãƒãƒ¼ã®èµ·å‹•**:\n    ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ«ãƒ¼ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‹ã‚‰ï¼ˆã¾ãŸã¯ `PYTHONPATH` ãŒé©åˆ‡ã«è¨­å®šã•ã‚Œã¦ã„ã‚Œã° `backend` ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‹ã‚‰ï¼‰ä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚\n    ```bash\n    uvicorn backend.contact_api:app --reload --port 8000\n    ```\n    `--reload` ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã«ã‚ˆã‚Šã€ã‚³ãƒ¼ãƒ‰å¤‰æ›´æ™‚ã«ã‚µãƒ¼ãƒãƒ¼ãŒè‡ªå‹•çš„ã«å†èµ·å‹•ã—ã¾ã™ã€‚\n\n7.  **APIãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¸ã®ã‚¢ã‚¯ã‚»ã‚¹**:\n    ã‚µãƒ¼ãƒãƒ¼èµ·å‹•å¾Œã€ãƒ–ãƒ©ã‚¦ã‚¶ã§ http://localhost:8000/docs ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã¨ã€Swagger UIã«ã‚ˆã‚‹APIãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãŒè¡¨ç¤ºã•ã‚Œã€å„ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’è©¦ã™ã“ã¨ãŒã§ãã¾ã™ã€‚ http://localhost:8000/redoc ã§ã‚‚Redocå½¢å¼ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãŒç¢ºèªã§ãã¾ã™ã€‚\n\n## 5. èªè¨¼ãƒ»èªå¯ (Authentication & Authorization)\n\nãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰APIã®ä¿è­·ã•ã‚ŒãŸã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã«ã¯ã€JWT (JSON Web Token) ã‚’ä½¿ç”¨ã—ãŸèªè¨¼ãŒå¿…è¦ã§ã™ã€‚\n\n### èªè¨¼ãƒ•ãƒ­ãƒ¼\n1.  **ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼**: ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¾ãŸã¯ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯ã€Supabase Auth (ä¾‹: `supabase-js`ãƒ©ã‚¤ãƒ–ãƒ©ãƒª) ã‚’ä½¿ç”¨ã—ã¦ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ­ã‚°ã‚¤ãƒ³å‡¦ç†ã‚’è¡Œã„ã¾ã™ã€‚\n2.  **JWTå–å¾—**: èªè¨¼æˆåŠŸå¾Œã€Supabase Authã‹ã‚‰JWTï¼ˆã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ï¼‰ãŒç™ºè¡Œã•ã‚Œã¾ã™ã€‚\n3.  **APIãƒªã‚¯ã‚¨ã‚¹ãƒˆ**: ä¿è­·ã•ã‚ŒãŸAPIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¸ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆæ™‚ã€ã“ã®JWTã‚’ `Authorization` HTTPãƒ˜ãƒƒãƒ€ãƒ¼ã« `Bearer <token>` ã®å½¢å¼ã§å«ã‚ã¦é€ä¿¡ã—ã¾ã™ã€‚\n\n### JWTæ¤œè¨¼ (ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰)\n-   ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ (`auth.py` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã® `get_current_active_user` ä¾å­˜æ€§æ³¨å…¥é–¢æ•°å†…) ã¯ã€å—ã‘å–ã£ãŸJWTã‚’æ¤œè¨¼ã—ã¾ã™ã€‚\n-   æ¤œè¨¼ã«ã¯ã€Supabaseãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®JWKS (JSON Web Key Set) URI (`SUPABASE_JWKS_URI` ç’°å¢ƒå¤‰æ•°ã§è¨­å®š) ã‹ã‚‰å–å¾—ã—ãŸå…¬é–‹éµã‚»ãƒƒãƒˆã‚’ä½¿ç”¨ã—ã¾ã™ã€‚\n-   JWTã®ç½²åã€æœ‰åŠ¹æœŸé™ã€ç™ºè¡Œè€… (issuer - `SUPABASE_URL` ã‹ã‚‰æ´¾ç”Ÿ)ã€å¯¾è±¡è€… (audience - `SUPABASE_JWT_AUDIENCE` ç’°å¢ƒå¤‰æ•°ã§è¨­å®š) ãŒæ¤œè¨¼ã•ã‚Œã¾ã™ã€‚\n-   æ¤œè¨¼æˆåŠŸå¾Œã€ãƒˆãƒ¼ã‚¯ãƒ³å†…ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ID (`sub` ã‚¯ãƒ¬ãƒ¼ãƒ ) ã‚’ä½¿ç”¨ã—ã¦ã€`public.users` ãƒ†ãƒ¼ãƒ–ãƒ«ã‹ã‚‰ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±ï¼ˆ`app_role`, `tenant_id` ãªã©ï¼‰ã‚’å–å¾—ã—ã¾ã™ã€‚\n-   ã“ã‚Œã‚‰ã®æƒ…å ±ã‚’å«ã‚€ `AuthenticatedUser` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã€ä¿è­·ã•ã‚ŒãŸã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆé–¢æ•°ã«æ³¨å…¥ã•ã‚Œã¾ã™ã€‚\n\n### ãƒ­ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡ (RBAC)\n-   **`app_role`**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã«æ ¼ç´ã•ã‚Œã‚‹ãƒ­ãƒ¼ãƒ«ï¼ˆä¾‹: `user`, `admin`, `superuser`ï¼‰ã€‚\n-   **`user` ãƒ­ãƒ¼ãƒ«**: é€šå¸¸ã®ãƒ†ãƒŠãƒ³ãƒˆãƒ¦ãƒ¼ã‚¶ãƒ¼ã€‚è‡ªèº«ã®ãƒ†ãƒŠãƒ³ãƒˆã«é–¢é€£ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ï¼ˆãƒ•ã‚©ãƒ¼ãƒ è¨­å®šã€å•ã„åˆã‚ã›ãƒ‡ãƒ¼ã‚¿ãªã©ï¼‰ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒè¨±å¯ã•ã‚Œã¾ã™ã€‚\n-   **`superuser` ãƒ­ãƒ¼ãƒ«**: ã‚·ã‚¹ãƒ†ãƒ ç®¡ç†è€…ã€‚ãƒ†ãƒŠãƒ³ãƒˆä½œæˆãƒ»ç®¡ç†ãªã©ã€ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã«é–¢ã‚ã‚‹æ“ä½œãŒè¨±å¯ã•ã‚Œã¾ã™ã€‚\n-   å„APIãƒ«ãƒ¼ã‚¿ãƒ¼ã¾ãŸã¯å€‹åˆ¥ã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã§ã€å¿…è¦ãªãƒ­ãƒ¼ãƒ«ã‚’æŒã¤ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã¿ãŒã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‚ˆã†ã«åˆ¶å¾¡ã•ã‚Œã¾ã™ï¼ˆä¾‹: `tenant_router.py` ã® `require_superuser_role` ä¾å­˜æ€§ï¼‰ã€‚\n\n## 6. APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆè©³ç´° (API Endpoints)\n\nãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯ä»¥ä¸‹ã®ä¸»è¦ãªAPIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’æä¾›ã—ã¾ã™ã€‚\nè©³ç´°ãªãƒªã‚¯ã‚¨ã‚¹ãƒˆ/ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®ã‚¹ã‚­ãƒ¼ãƒã‚„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«ã¤ã„ã¦ã¯ã€ã‚µãƒ¼ãƒãƒ¼èµ·å‹•å¾Œã« `/docs` (Swagger UI) ã¾ãŸã¯ `/redoc` (Redoc) ã§ã”ç¢ºèªãã ã•ã„ã€‚\n\n### 6.1. ãƒ•ã‚©ãƒ¼ãƒ é€ä¿¡ (Form Submission)\n\n-   **`POST /submit`**\n    -   **èª¬æ˜**: ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆã‹ã‚‰ã®ãŠå•ã„åˆã‚ã›ãƒ‡ãƒ¼ã‚¿ã‚’å—ã‘ä»˜ã‘ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ä¿å­˜ã—ã¾ã™ã€‚ä¿å­˜æˆåŠŸå¾Œã€GA4ãŒè¨­å®šã•ã‚Œã¦ã„ã‚Œã° `generate_lead` ã‚¤ãƒ™ãƒ³ãƒˆã‚’é€ä¿¡ã—ã¾ã™ã€‚\n    -   **èªè¨¼**: ä¸è¦ (é€šå¸¸ã€å…¬é–‹ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ)\n    -   **ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒœãƒ‡ã‚£ä¾‹**:\n        ```json\n        {\n          \"name\": \"å±±ç”° å¤ªéƒ\",\n          \"email\": \"yamada.taro@example.com\",\n          \"message\": \"è£½å“Aã«ã¤ã„ã¦è©³ã—ãçŸ¥ã‚ŠãŸã„ã§ã™ã€‚\",\n          \"tenant_id\": \"your-tenant-uuid-here\",\n          \"ga_client_id\": \"GA1.2.123456789.1678901234\",\n          \"ga_session_id\": \"1678901234\",\n          \"form_id\": \"product_inquiry_form\"\n        }\n        ```\n    -   **æˆåŠŸãƒ¬ã‚¹ãƒãƒ³ã‚¹ä¾‹ (200 OK)**:\n        ```json\n        {\n          \"id\": 123,\n          \"created_at\": \"2024-03-15T10:30:00Z\",\n          \"name\": \"å±±ç”° å¤ªéƒ\",\n          \"email\": \"yamada.taro@example.com\",\n          \"message\": \"è£½å“Aã«ã¤ã„ã¦è©³ã—ãçŸ¥ã‚ŠãŸã„ã§ã™ã€‚\",\n          \"tenant_id\": \"your-tenant-uuid-here\",\n          \"ga_client_id\": \"GA1.2.123456789.1678901234\",\n          \"ga_session_id\": \"1678901234\",\n          \"form_id\": \"product_inquiry_form\",\n          \"submission_status\": \"new\",\n          \"status_change_reason\": null,\n          \"updated_at\": \"2024-03-15T10:30:00Z\"\n        }\n        ```\n    -   **ä¸»ãªã‚¨ãƒ©ãƒ¼ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹**:\n        -   `422 Unprocessable Entity`: ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒœãƒ‡ã‚£ã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼ã€‚\n        -   `503 Service Unavailable`: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆæœªåˆæœŸåŒ–ãªã©ã€‚\n        -   `500 Internal Server Error`: ãã®ä»–ã®ã‚µãƒ¼ãƒãƒ¼å†…éƒ¨ã‚¨ãƒ©ãƒ¼ã€‚\n\n### 6.2. AIãƒãƒ£ãƒƒãƒˆ (AI Chat)\n\n-   **`POST /chat`**\n    -   **èª¬æ˜**: AIãƒãƒ£ãƒƒãƒˆãƒœãƒƒãƒˆï¼ˆGeminiãƒ¢ãƒ‡ãƒ«ï¼‰ã¨ã®å¯¾è©±ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‡¦ç†ã—ã€AIã‹ã‚‰ã®å¿œç­”ã‚’è¿”ã—ã¾ã™ã€‚\n    -   **èªè¨¼**: ä¸è¦ (é€šå¸¸ã€å…¬é–‹ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ)\n    -   **ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒœãƒ‡ã‚£ä¾‹**:\n        ```json\n        {\n          \"message\": \"ã“ã®ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆã®ä¾¡æ ¼ã¯ï¼Ÿ\",\n          \"session_id\": \"chat-session-789\"\n        }\n        ```\n    -   **æˆåŠŸãƒ¬ã‚¹ãƒãƒ³ã‚¹ä¾‹ (200 OK)**:\n        ```json\n        {\n          \"reply\": \"ä¾¡æ ¼ã«ã¤ã„ã¦ã¯ã€æ–™é‡‘ãƒšãƒ¼ã‚¸ã‚’ã”è¦§ãã ã•ã„...\",\n          \"session_id\": \"chat-session-789\",\n          \"require_form_after_message\": false\n        }\n        ```\n    -   **ä¸»ãªã‚¨ãƒ©ãƒ¼ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹**:\n        -   `422 Unprocessable Entity`: ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒœãƒ‡ã‚£ã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼ã€‚\n        -   `500 Internal Server Error`: AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå‡¦ç†ä¸­ã®ã‚¨ãƒ©ãƒ¼ãªã©ã€‚\n\n### 6.3. å•ã„åˆã‚ã›ãƒ‡ãƒ¼ã‚¿ä¸€è¦§å–å¾— (List Submissions)\n\n-   **`GET /api/v1/submissions`**\n    -   **èª¬æ˜**: å•ã„åˆã‚ã›ãƒ‡ãƒ¼ã‚¿ã®ä¸€è¦§ã‚’ã€æŒ‡å®šã•ã‚ŒãŸãƒ•ã‚£ãƒ«ã‚¿ãƒ¼æ¡ä»¶ã€ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ã€ã‚½ãƒ¼ãƒˆé †ã«åŸºã¥ã„ã¦å–å¾—ã—ã¾ã™ã€‚\n    -   **èªè¨¼**: å¿…è¦ (ãƒ†ãƒŠãƒ³ãƒˆãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯è‡ªèº«ã®ãƒ†ãƒŠãƒ³ãƒˆã®ãƒ‡ãƒ¼ã‚¿ã®ã¿ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½)ã€‚\n    -   **ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿**:\n        -   `form_id: Optional[str]` (ãƒ•ã‚©ãƒ¼ãƒ ID)\n        -   `submission_status: Optional[str]` (ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹)\n        -   `email: Optional[str]` (ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã€éƒ¨åˆ†ä¸€è‡´)\n        -   `name: Optional[str]` (åå‰ã€éƒ¨åˆ†ä¸€è‡´)\n        -   `start_date: Optional[date]` (ä½œæˆæ—¥ç¯„å›²å§‹ç‚¹ YYYY-MM-DD)\n        -   `end_date: Optional[date]` (ä½œæˆæ—¥ç¯„å›²çµ‚ç‚¹ YYYY-MM-DD)\n        -   `skip: int` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ `0`, 0ä»¥ä¸Š)\n        -   `limit: int` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ `20`, 1ä»¥ä¸Š100ä»¥ä¸‹)\n        -   `sort_by: Optional[str]` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ `created_at`, Enum: `created_at`, `updated_at`, `name`, `submission_status`, `id`, `email`, `form_id`)\n        -   `sort_order: Optional[str]` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ `desc`, Enum: `asc`, `desc`)\n    -   **æˆåŠŸãƒ¬ã‚¹ãƒãƒ³ã‚¹ä¾‹ (200 OK)**:\n        ```json\n        {\n          \"submissions\": [\n            {\n              \"id\": 123,\n              \"created_at\": \"2024-03-15T10:30:00Z\",\n              \"name\": \"å±±ç”° å¤ªéƒ\",\n              \"email\": \"yamada.taro@example.com\",\n              \"message\": \"è£½å“Aã«ã¤ã„ã¦è©³ã—ãçŸ¥ã‚ŠãŸã„ã§ã™ã€‚\",\n              \"tenant_id\": \"your-tenant-uuid-here\",\n              \"ga_client_id\": \"GA1.2.123456789.1678901234\",\n              \"ga_session_id\": \"1678901234\",\n              \"form_id\": \"product_inquiry_form\",\n              \"submission_status\": \"new\",\n              \"status_change_reason\": null,\n              \"updated_at\": \"2024-03-15T10:30:00Z\"\n            }\n          ],\n          \"total_count\": 1,\n          \"skip\": 0,\n          \"limit\": 20\n        }\n        ```\n    -   **ä¸»ãªã‚¨ãƒ©ãƒ¼ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹**:\n        -   `403 Forbidden`: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãƒ†ãƒŠãƒ³ãƒˆã«ç´ä»˜ã„ã¦ã„ãªã„å ´åˆã€‚\n        -   `422 Unprocessable Entity`: ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼ã€‚\n        -   `503 Service Unavailable`: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆæœªåˆæœŸåŒ–ãªã©ã€‚\n        -   `500 Internal Server Error`: ãã®ä»–ã®ã‚µãƒ¼ãƒãƒ¼å†…éƒ¨ã‚¨ãƒ©ãƒ¼ã€‚\n\n### 6.4. GA4è¨­å®šç®¡ç† (GA4 Form Configurations)\n\nã“ã‚Œã‚‰ã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¯ã€ãƒ†ãƒŠãƒ³ãƒˆå†…ã®ãƒ•ã‚©ãƒ¼ãƒ ã”ã¨ã®GA4æ¸¬å®šIDã¨APIã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã‚’ç®¡ç†ã—ã¾ã™ã€‚\n**èªè¨¼**: å¿…è¦ (ãƒ†ãƒŠãƒ³ãƒˆãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯è‡ªèº«ã®ãƒ†ãƒŠãƒ³ãƒˆã®è¨­å®šã®ã¿ç®¡ç†å¯èƒ½)ã€‚\n\n-   **`POST /api/v1/ga_configurations/{form_id}`**:\n    -   **èª¬æ˜**: æŒ‡å®šã•ã‚ŒãŸ `form_id` ã«å¯¾ã—ã¦æ–°ã—ã„GA4è¨­å®šã‚’ç™»éŒ²ã—ã¾ã™ã€‚\n    -   **æˆåŠŸãƒ¬ã‚¹ãƒãƒ³ã‚¹ (201 Created)**: ä½œæˆã•ã‚ŒãŸGA4è¨­å®šæƒ…å ±ã€‚\n    -   **ä¸»ãªã‚¨ãƒ©ãƒ¼ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹**: `409 Conflict` (æŒ‡å®š`form_id`ãŒæ—¢ã«å­˜åœ¨ã™ã‚‹å ´åˆ), `403`, `422`, `500`, `503`ã€‚\n\n-   **`GET /api/v1/ga_configurations`**:\n    -   **èª¬æ˜**: èªè¨¼ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ†ãƒŠãƒ³ãƒˆã«ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹å…¨ã¦ã®ãƒ•ã‚©ãƒ¼ãƒ GA4è¨­å®šã‚’ãƒªã‚¹ãƒˆã—ã¾ã™ï¼ˆãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³å¯¾å¿œ: `skip`, `limit` ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼‰ã€‚\n    -   **æˆåŠŸãƒ¬ã‚¹ãƒãƒ³ã‚¹ (200 OK)**: GA4è¨­å®šã®ãƒªã‚¹ãƒˆã€‚\n\n-   **`GET /api/v1/ga_configurations/{form_id}`**:\n    -   **èª¬æ˜**: æŒ‡å®šã•ã‚ŒãŸ `form_id` ã®GA4è¨­å®šã‚’å–å¾—ã—ã¾ã™ã€‚\n    -   **æˆåŠŸãƒ¬ã‚¹ãƒãƒ³ã‚¹ (200 OK)**:è©²å½“ã™ã‚‹GA4è¨­å®šæƒ…å ±ã€‚\n    -   **ä¸»ãªã‚¨ãƒ©ãƒ¼ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹**: `404 Not Found`ã€‚\n\n-   **`PUT /api/v1/ga_configurations/{form_id}`**:\n    -   **èª¬æ˜**: æŒ‡å®šã•ã‚ŒãŸ `form_id` ã®GA4è¨­å®šã‚’æ›´æ–°ã—ã¾ã™ã€‚\n    -   **æˆåŠŸãƒ¬ã‚¹ãƒãƒ³ã‚¹ (200 OK)**: æ›´æ–°ã•ã‚ŒãŸGA4è¨­å®šæƒ…å ±ã€‚\n    -   **ä¸»ãªã‚¨ãƒ©ãƒ¼ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹**: `404 Not Found`, `422`, `500`, `503`ã€‚\n\n-   **`DELETE /api/v1/ga_configurations/{form_id}`**:\n    -   **èª¬æ˜**: æŒ‡å®šã•ã‚ŒãŸ `form_id` ã®GA4è¨­å®šã‚’å‰Šé™¤ã—ã¾ã™ã€‚\n    -   **æˆåŠŸãƒ¬ã‚¹ãƒãƒ³ã‚¹ (204 No Content)**ã€‚\n    -   **ä¸»ãªã‚¨ãƒ©ãƒ¼ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹**: `404 Not Found`ã€‚\n\n### 6.5. å•ã„åˆã‚ã›ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–° (Submission Status Update)\n\n-   **`PATCH /api/v1/submissions/{submission_id}/status`**\n    -   **èª¬æ˜**: æŒ‡å®šã•ã‚ŒãŸå•ã„åˆã‚ã› (`submission_id`) ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ (`submission_status`ã¨ä»»æ„ã§`status_change_reason`) ã‚’æ›´æ–°ã—ã¾ã™ã€‚ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å¤‰æ›´ã«å¿œã˜ã¦ã€GA4ã‚¤ãƒ™ãƒ³ãƒˆãŒé€ä¿¡ã•ã‚Œã¾ã™ã€‚\n    -   **èªè¨¼**: å¿…è¦ (ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯è‡ªèº«ã®ãƒ†ãƒŠãƒ³ãƒˆå†…ã®å•ã„åˆã‚ã›ã®ã¿æ›´æ–°å¯èƒ½)ã€‚\n    -   **ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒœãƒ‡ã‚£ä¾‹**:\n        ```json\n        {\n          \"new_status\": \"converted\",\n          \"reason\": \"Lead successfully closed.\"\n        }\n        ```\n    -   **æˆåŠŸãƒ¬ã‚¹ãƒãƒ³ã‚¹ä¾‹ (200 OK)**: æ›´æ–°ã•ã‚ŒãŸå•ã„åˆã‚ã›ãƒ¬ã‚³ãƒ¼ãƒ‰å…¨ä½“ã€‚\n    -   **ä¸»ãªã‚¨ãƒ©ãƒ¼ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹**: `404 Not Found` (submission_idãŒè¦‹ã¤ã‹ã‚‰ãªã„ã€ã¾ãŸã¯ä»–ãƒ†ãƒŠãƒ³ãƒˆã®ãƒ‡ãƒ¼ã‚¿), `403`, `422`, `500`, `503`ã€‚\n\n### 6.6. ãƒ†ãƒŠãƒ³ãƒˆç®¡ç† (Tenant Management - Superuser Only)\n-   **`POST /api/v1/tenants`**: æ–°è¦ãƒ†ãƒŠãƒ³ãƒˆä½œæˆã€‚\n-   **`GET /api/v1/tenants`**: ãƒ†ãƒŠãƒ³ãƒˆä¸€è¦§å–å¾—ã€‚\n-   **`GET /api/v1/tenants/{tenant_id}`**: ç‰¹å®šãƒ†ãƒŠãƒ³ãƒˆæƒ…å ±å–å¾—ã€‚\n-   **`PUT /api/v1/tenants/{tenant_id}`**: ãƒ†ãƒŠãƒ³ãƒˆæƒ…å ±æ›´æ–°ã€‚\n-   **`DELETE /api/v1/tenants/{tenant_id}`**: ãƒ†ãƒŠãƒ³ãƒˆå‰Šé™¤ï¼ˆè«–ç†/ç‰©ç†ï¼‰ã€‚\n    -   **èªè¨¼**: ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã¿ï¼ˆ`require_superuser_role` ä¾å­˜æ€§ã«ã‚ˆã‚Šå®Ÿæ–½ï¼‰ã€‚\n\n## 7. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¹ã‚­ãƒ¼ãƒæ¦‚è¦ (Database Schema Overview)\n\nãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã¯Supabase (PostgreSQL) ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ä¸»è¦ãªãƒ†ãƒ¼ãƒ–ãƒ«ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚\nè©³ç´°ãªã‚¹ã‚­ãƒ¼ãƒå®šç¾©ã¯ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆã® `database/` ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå†…ã®å„SQLãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‚ç…§ã—ã¦ãã ã•ã„ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«åã«æ³¨æ„ã—ã€ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³é †åºã«å¾“ã£ã¦ãã ã•ã„ï¼‰ã€‚\n\n-   **`tenants`**:\n    -   **èª¬æ˜**: å„ãƒ†ãƒŠãƒ³ãƒˆï¼ˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆä¼æ¥­ï¼‰ã®æƒ…å ±ã‚’æ ¼ç´ã—ã¾ã™ã€‚`tenant_id` (UUID) ãŒä¸»ã‚­ãƒ¼ã§ã™ã€‚\n    -   **ã‚¹ã‚­ãƒ¼ãƒãƒ•ã‚¡ã‚¤ãƒ«**: `database/0001_tenants_schema.sql` (ã¾ãŸã¯åŒç­‰ã®å†…å®¹ã‚’å«ã‚€ãƒ•ã‚¡ã‚¤ãƒ«)\n    -   **ä¸»è¦ã‚«ãƒ©ãƒ **: `tenant_id`, `company_name`, `domain`, `is_deleted`, `created_at`, `updated_at`ã€‚\n\n-   **`users` (in `public` schema, linked to `auth.users`)**:\n    -   **èª¬æ˜**: ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±ã€‚Supabaseã® `auth.users` ãƒ†ãƒ¼ãƒ–ãƒ«ã®ãƒ¬ã‚³ãƒ¼ãƒ‰ã¨ `id` (UUID) ã§1å¯¾1ã«å¯¾å¿œã—ã¾ã™ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ç‰¹å®šã®ãƒ†ãƒŠãƒ³ãƒˆã«æ‰€å±ã—ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å›ºæœ‰ã®ãƒ­ãƒ¼ãƒ«ï¼ˆ`app_role`ï¼‰ã‚’æŒã¡ã¾ã™ã€‚\n    -   **ã‚¹ã‚­ãƒ¼ãƒãƒ•ã‚¡ã‚¤ãƒ«**: `database/0002_user_profiles_schema.sql` (ã¾ãŸã¯åŒç­‰ã®å†…å®¹ã‚’å«ã‚€ãƒ•ã‚¡ã‚¤ãƒ«)\n    -   **ä¸»è¦ã‚«ãƒ©ãƒ **: `id` (FK to `auth.users.id`), `app_role` (`user`, `superuser`ãªã©), `tenant_id` (FK to `public.tenants.tenant_id`), `full_name`, `created_at`, `updated_at`ã€‚\n\n-   **`contact_submissions`**:\n    -   **èª¬æ˜**: ãŠå•ã„åˆã‚ã›ãƒ•ã‚©ãƒ¼ãƒ ã‹ã‚‰é€ä¿¡ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚’ãƒ†ãƒŠãƒ³ãƒˆã”ã¨ã«ä¿å­˜ã—ã¾ã™ã€‚`tenant_id` ã‚«ãƒ©ãƒ ã§ãƒ†ãƒŠãƒ³ãƒˆã«ç´ä»˜ã‘ã‚‰ã‚Œã¾ã™ã€‚\n    -   **ã‚¹ã‚­ãƒ¼ãƒãƒ•ã‚¡ã‚¤ãƒ«**: `database/0003_contact_form_submissions_schema.sql` (ã¾ãŸã¯åŒç­‰ã®å†…å®¹ã‚’å«ã‚€ãƒ•ã‚¡ã‚¤ãƒ«ã€`tenant_id` è¿½åŠ æ¸ˆã¿ã§ã‚ã‚‹ã“ã¨)\n    -   **ä¸»è¦ã‚«ãƒ©ãƒ **: `id`, `created_at`, `updated_at`, `name`, `email`, `message`, `ga_client_id`, `ga_session_id`, `form_id`, `submission_status`, `status_change_reason`, `tenant_id`ã€‚\n\n-   **`form_ga_configurations`**:\n    -   **èª¬æ˜**: ãƒ†ãƒŠãƒ³ãƒˆå†…ã®ãƒ•ã‚©ãƒ¼ãƒ ã”ã¨ã®Google Analytics 4 Measurement Protocolè¨­å®šã‚’ä¿å­˜ã—ã¾ã™ã€‚`tenant_id` ã¨ `form_id` ã®è¤‡åˆä¸»ã‚­ãƒ¼ã§ç®¡ç†ã•ã‚Œã¾ã™ã€‚\n    -   **ã‚¹ã‚­ãƒ¼ãƒãƒ•ã‚¡ã‚¤ãƒ«**: `database/0004_form_ga_configurations_schema.sql` (ã¾ãŸã¯åŒç­‰ã®å†…å®¹ã‚’å«ã‚€ãƒ•ã‚¡ã‚¤ãƒ«ã€`tenant_id` è¿½åŠ æ¸ˆã¿ã§ã‚ã‚‹ã“ã¨)\n    -   **ä¸»è¦ã‚«ãƒ©ãƒ **: `tenant_id`, `form_id`, `ga4_measurement_id`, `ga4_api_secret`, `description`, `created_at`, `updated_at`ã€‚\n\n## 8. Google Analytics 4 (GA4) é€£æº (GA4 Integration)\n\nã“ã®ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã¯ã€GA4ã®Measurement Protocol (v2) ã‚’ä½¿ç”¨ã—ã¦ã€ãƒªãƒ¼ãƒ‰ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã«é–¢é€£ã™ã‚‹ã‚¤ãƒ™ãƒ³ãƒˆã‚’Google Analyticsã«é€ä¿¡ã—ã¾ã™ã€‚å„ãƒ†ãƒŠãƒ³ãƒˆã¯è‡ªèº«ã®GA4ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¨é€£æºã§ãã¾ã™ã€‚\n\n### è¨­å®šæ–¹æ³•\n1.  **GA4ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã§ã®æº–å‚™**: GA4ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã§ã€Œæ¸¬å®šIDã€ã¨ã€ŒAPIã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã€ã‚’å–å¾—ã—ã¾ã™ã€‚\n2.  **ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã¸ã®è¨­å®šç™»éŒ²**: `/api/v1/ga_configurations` ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆï¼ˆã€Œ6.4. GA4è¨­å®šç®¡ç†ã€å‚ç…§ï¼‰ã‚’ä½¿ç”¨ã—ã¦ã€ãƒ†ãƒŠãƒ³ãƒˆå†…ã®ãƒ•ã‚©ãƒ¼ãƒ ã”ã¨ (`form_id` å˜ä½) ã«å–å¾—ã—ãŸæ¸¬å®šIDã¨APIã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã‚’ç™»éŒ²ã—ã¾ã™ã€‚\n\n### é€ä¿¡ã•ã‚Œã‚‹ä¸»è¦ã‚¤ãƒ™ãƒ³ãƒˆ\n-   **`generate_lead`**:\n    -   **ãƒˆãƒªã‚¬ãƒ¼**: `/submit` ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã§ãƒ•ã‚©ãƒ¼ãƒ é€ä¿¡ãŒæ­£å¸¸ã«å‡¦ç†ã•ã‚ŒãŸéš›ã€‚\n    -   **ä¸»ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿**: `client_id`, `session_id` (ãƒ•ã‚©ãƒ¼ãƒ ã‹ã‚‰æä¾›ã•ã‚ŒãŸå ´åˆ), `form_id` (ã‚«ã‚¹ã‚¿ãƒ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ `event_label` ã¨ã—ã¦), `event_category: "contact_form"`ã€‚\n-   **ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å¤‰æ›´é€£å‹•ã‚¤ãƒ™ãƒ³ãƒˆ**: `/api/v1/submissions/{submission_id}/status` ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã§å•ã„åˆã‚ã›ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒå¤‰æ›´ã•ã‚ŒãŸéš›ã€‚\n    -   `contacted` æ™‚: `working_lead` (ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ `lead_status: "contacted"`)
    -   `qualified` æ™‚: `qualify_lead`
    -   `converted` æ™‚: `close_convert_lead` (ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ `transaction_id` ã« `submission_id` ã‚’ä½¿ç”¨)
    -   `unconverted` æ™‚: `lead_unconverted` (ã‚«ã‚¹ã‚¿ãƒ ã‚¤ãƒ™ãƒ³ãƒˆ)
    -   `disqualified` æ™‚: `lead_disqualified` (ã‚«ã‚¹ã‚¿ãƒ ã‚¤ãƒ™ãƒ³ãƒˆ)
    -   ã“ã‚Œã‚‰ã®ã‚¤ãƒ™ãƒ³ãƒˆã«ã‚‚ `client_id`, `session_id`, `form_id` ãªã©ã®é–¢é€£æƒ…å ±ãŒä»˜ä¸ã•ã‚Œã¾ã™ã€‚

å…¨ã¦ã®ã‚¤ãƒ™ãƒ³ãƒˆã«ã¯ã€å›ºå®šå€¤ã¨ã—ã¦ `value: 0`, `currency: "JPY"` ãŒè¨­å®šã•ã‚Œã¾ã™ã€‚
ã‚¤ãƒ™ãƒ³ãƒˆé€ä¿¡å‡¦ç†ã¯ `backend/services/ga4_mp_service.py` ã® `send_ga4_event` é–¢æ•°ãŒæ‹…å½“ã—ã¾ã™ã€‚

## 9. ãƒ†ã‚¹ãƒˆ (Testing)

ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆãŠã‚ˆã³çµåˆãƒ†ã‚¹ãƒˆã¯ `pytest` ã‚’ä½¿ç”¨ã—ã¦å®Ÿè¡Œã—ã¾ã™ã€‚

### ãƒ†ã‚¹ãƒˆã®å®Ÿè¡Œ
1.  ä¸Šè¨˜ã€Œãƒ­ãƒ¼ã‚«ãƒ«é–‹ç™ºç’°å¢ƒã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã€ãŒå®Œäº†ã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚
2.  `pytest` ãŒ `requirements.txt` ã«å«ã¾ã‚Œã¦ãŠã‚Šã€ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚
3.  ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ«ãƒ¼ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§ä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚
    ```bash
    pytest backend/tests/
    ```
    ã¾ãŸã¯ã€ç‰¹å®šã®ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿ã‚’å®Ÿè¡Œã™ã‚‹å ´åˆ:
    ```bash
    pytest backend/tests/test_contact_api.py
    pytest backend/tests/test_form_ga_config_api.py
    pytest backend/tests/test_submission_api.py
    pytest backend/tests/test_ai_agent.py
    pytest backend/tests/test_tenant_api.py
    ```

### ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®å ´æ‰€
ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã¯ `backend/tests/` ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«é…ç½®ã•ã‚Œã¦ã„ã¾ã™ã€‚

-   `test_contact_api.py`: `/submit`, `/chat` ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆãŠã‚ˆã³é–¢é€£æ©Ÿèƒ½ã®ãƒ†ã‚¹ãƒˆã€‚
-   `test_form_ga_config_api.py`: GA4è¨­å®šç®¡ç†API (`/api/v1/ga_configurations/...`) ã®ãƒ†ã‚¹ãƒˆã€‚
-   `test_submission_api.py`: å•ã„åˆã‚ã›ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°API (`/api/v1/submissions/.../status`) ãŠã‚ˆã³ä¸€è¦§å–å¾—APIã®ãƒ†ã‚¹ãƒˆã€‚
-   `test_ai_agent.py`: AI Agentã®å¿œç­”ç”Ÿæˆãƒ­ã‚¸ãƒƒã‚¯ï¼ˆãƒªãƒˆãƒ©ã‚¤å‡¦ç†å«ã‚€ï¼‰ã®ãƒ†ã‚¹ãƒˆã€‚
-   `test_tenant_api.py`: ãƒ†ãƒŠãƒ³ãƒˆç®¡ç†API (`/api/v1/tenants/...`) ã®ãƒ†ã‚¹ãƒˆã€‚

ãƒ†ã‚¹ãƒˆã¯ã€ã‚µãƒ¼ãƒ“ã‚¹å±¤ã®ãƒ­ã‚¸ãƒƒã‚¯ã‚„å¤–éƒ¨ä¾å­˜ï¼ˆSupabaseã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãªã©ï¼‰ã‚’ãƒ¢ãƒƒã‚¯ã—ã¦ã€å„ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®å‹•ä½œã‚’ç‹¬ç«‹ã—ã¦æ¤œè¨¼ã™ã‚‹ã“ã¨ã«ä¸»çœ¼ã‚’ç½®ã„ã¦ã„ã¾ã™ã€‚

## 10. ãã®ä»– (Miscellaneous)

-   (ç¾æ™‚ç‚¹ã§ã¯ç‰¹è¨˜äº‹é …ãªã—)

```

[end of backend/README.md]

[start of backend/ai_agent.py]
from typing import Optional, Tuple
import json # Added json import
import logging # Added logging
from pydantic import BaseModel, Field
from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type, before_sleep_log # Added tenacity
from .config import settings # Added

logger = logging.getLogger(__name__) # Initialized logger

ADK_IMPORTED_SUCCESSFULLY = False
AGENT_INITIALIZED_SUCCESSFULLY = False # New flag

# Attempt to import ADK components. Handle gracefully if not available.
try:
    from google.adk.agents import LlmAgent
    from google.adk.runners import InMemoryRunner
    from google.adk.events import Event
    ADK_IMPORTED_SUCCESSFULLY = True
    logger.debug("ADK components imported successfully.")
except ImportError as e:
    logger.error("Failed to import ADK components: %s. AI Agent will not be available.", e, exc_info=True)
    # Dummy ADK class definitions are below and will be used.
    pass

# --- Pydantic Model for Structured Agent Response ---
class AgentStructuredResponse(BaseModel):
    message: str = Field(description="The chat message response from the AI agent.")
    require_form_after_message: bool = Field(
        description="Indicates if the frontend should suggest or display a contact form after this message."
    )

class LlmAgent:
        def __init__(self, *args, **kwargs):
            # This print is in a dummy class, potentially keep as is or change to logger.warning
            # For now, let's assume these dummy classes' prints are for very specific non-ADK scenarios
            print("WARNING: google-adk-python not installed. AI Agent will not function.")
            pass
    class InMemoryRunner:
        def __init__(self, *args, **kwargs):
            pass
        def run(self, *args, **kwargs) -> 'Event': # type: ignore
            return Event(error_message="ADK components not available. Please install google-adk-python.") # type: ignore
    class Event: # type: ignore
        def __init__(self, error_message: Optional[str] = None):
            self.actions = []
            self.error_message = error_message
            self.session_id = None


# Configure your Google Cloud project and credentials if necessary.
# For Gemini, ensure API keys or ADC (Application Default Credentials) are set up.
# You might need to set GOOGLE_API_KEY environment variable if not using ADC.
# The ADK library should pick up Application Default Credentials automatically if set up.

GEMINI_MODEL_NAME = settings.gemini_model_name
# The GOOGLE_API_KEY is expected to be sourced by the ADK from the environment variables
# (which pydantic-settings helps load from .env) or via ADC.
# We log if it's explicitly set via our application settings, for awareness.
if settings.google_api_key:
    logger.info("Application settings include a GOOGLE_API_KEY.")
else:
    logger.info("GOOGLE_API_KEY is not set in application settings. ADK will rely on ADC or an externally set GOOGLE_API_KEY environment variable.")

# Generate JSON schema string for the agent's structured response
AGENT_RESPONSE_JSON_SCHEMA = json.dumps(AgentStructuredResponse.model_json_schema(), indent=2)

chat_agent = None
agent_runner = None

if ADK_IMPORTED_SUCCESSFULLY:
    try:
        chat_agent = LlmAgent(
            name="structured_chat_agent", # Renamed for clarity
            model=GEMINI_MODEL_NAME,
            instruction=f"""You are a highly intelligent and helpful AI assistant for 'Contact Form Widget Corp'.
Your primary role is to answer user questions about our company, our innovative contact form widgets, related whitepapers, and product information.
You MUST always respond with a JSON object that strictly adheres to the following JSON schema:
```json
{AGENT_RESPONSE_JSON_SCHEMA}
```

Here's how to determine the values for the JSON fields:
- `message`: This field should contain your textual response to the user. Be helpful, concise, and informative.
- `require_form_after_message`: This boolean field determines if the user should be prompted with a contact form or a specific call to action after your message.
    - Set this to `true` if the conversation indicates a strong user interest in our products or services, if they are asking for quotes, detailed product comparisons, or if they seem like a qualified lead ready for the next step. For example, if they ask 'How can I get this widget for my site?' or 'Can you tell me the pricing for enterprise users?'.
    - When setting to `true`, the `message` field should naturally lead to this suggestion. For example: 'That's a great question! For detailed pricing and to discuss your specific needs, I recommend reaching out to our sales team. Would you like me to show you a form to contact them?' or 'Our 'Pro Widget X' seems like a perfect fit for your requirements. You can find more details and a purchase link here: [link]. I can also help you get in touch with our team if you'd like.'
    - In all other cases, or if you are unsure, set `require_form_after_message` to `false`. This includes general inquiries, requests for information you can provide directly, or if the user is not yet showing strong buying signals.
You are an expert in our products and aim to guide users effectively.
""",
        output_schema=AgentStructuredResponse, # Pass the Pydantic model here
        # tools=[] # Explicitly no tools, as output_schema disables them
        )
        agent_runner = InMemoryRunner(agent=chat_agent)
        AGENT_INITIALIZED_SUCCESSFULLY = True
        logger.info("AI Agent initialized successfully.")
    except Exception as e:
        logger.error("Failed to initialize LlmAgent or InMemoryRunner: %s. AI Agent will not be functional.", e, exc_info=True)
        chat_agent = None # Ensure they are None if init fails
        agent_runner = None
        # AGENT_INITIALIZED_SUCCESSFULLY remains False
else:
    logger.warning("ADK components not imported. AI Agent initialization will be skipped.")
    chat_agent = None
    agent_runner = None

@retry(
    stop=stop_after_attempt(settings.ai_agent_retry_attempts),
    wait=wait_exponential(
        multiplier=settings.ai_agent_retry_wait_multiplier,
        min=settings.ai_agent_retry_wait_initial_seconds,
        max=settings.ai_agent_retry_wait_max_seconds
    ),
    retry=retry_if_exception_type(Exception), # Consider refining this later
    before_sleep=before_sleep_log(logger, logging.WARNING) # Log before retrying
)
async def get_chat_response(message: str, session_id: Optional[str] = None) -> Tuple[str, Optional[str], bool]:
    """
    Gets a chat response from the AI agent, with retry logic.
    Returns:
        Tuple[str, Optional[str], bool]: (reply_message, session_id, require_form_flag)
    """
    # Changed level to debug and improved message snippet handling
    logger.debug(
        "get_chat_response called with session_id: %s, message_snippet: %s",
        session_id,
        message[:80] + "..." if message and len(message) > 80 else message
    )

    # Input Validation for 'message'
    if not message or not message.strip():
        logger.warning(
            "Input validation failed for get_chat_response: message is empty or consists only of whitespace. Session_id: %s",
            session_id
        )
        return "Message cannot be empty. Please provide a valid message.", session_id, False

    if not AGENT_INITIALIZED_SUCCESSFULLY:
        fallback_message = ""
        if not ADK_IMPORTED_SUCCESSFULLY:
            fallback_message = "AI Agent is unavailable due to missing dependencies. Please check server logs."
            logger.debug("Serving fallback because ADK components not imported.")
        else:
            # This means ADK was imported, but LlmAgent/InMemoryRunner initialization failed
            fallback_message = "AI Agent is currently experiencing setup issues. Please try again later or contact support."
            logger.debug("Serving fallback because AI Agent failed to initialize.")
        return fallback_message, session_id, False

    if agent_runner is None:
        logger.error("agent_runner is None despite AGENT_INITIALIZED_SUCCESSFULLY being true. This indicates a logic flaw.", exc_info=True)
        return "AI Agent is unexpectedly unavailable. Please contact support.", session_id, False

    reply = "[No response from agent or empty response]" # Default reply
    require_form = False # Default value
    response_session_id = session_id # Default to passed-in session_id

    try:
        # Assuming agent_runner.run() is synchronous.
        # If it were async, it would be `await agent_runner.run_async(...)`.
        # For a sync call in an async def, to avoid blocking, it should ideally be:
        # from fastapi.concurrency import run_in_threadpool
        # event: Event = await run_in_threadpool(agent_runner.run, request=message, session_id=session_id)
        # However, for this subtask, we apply tenacity as requested, assuming direct call first.
        logger.debug(f"Calling agent_runner.run for session_id: {session_id}")
        event: Event = agent_runner.run(request=message, session_id=session_id) # Synchronous call
        logger.debug(f"agent_runner.run completed for session_id: {session_id}")

        # Process the event
        require_form = False # Default value
        response_session_id = session_id # Default to passed-in session_id

        if event.error_message:
            logger.error("Agent event returned error_message: %s", event.error_message)
            reply = f"[Agent Error: {event.error_message}]"
        elif event.actions and event.actions[0].parts:
            action_part = event.actions[0].parts[0]
            if hasattr(action_part, 'text') and action_part.text:
                raw_agent_text = action_part.text
                try:
                    structured_response_data = json.loads(raw_agent_text)
                    parsed_response = AgentStructuredResponse(**structured_response_data)
                    reply = parsed_response.message
                    require_form = parsed_response.require_form_after_message
                except json.JSONDecodeError as jde:
                    logger.error("Failed to decode JSON response from agent. Text was: %s", raw_agent_text, exc_info=True)
                    reply = "[Agent Error: Failed to decode JSON response]"
                except Exception as pydantic_error: # Catch Pydantic validation errors
                    logger.error("Invalid JSON structure from agent. Text was: %s Error: %s", raw_agent_text, pydantic_error, exc_info=True)
                    reply = f"[Agent Error: Invalid JSON structure]"
            else:
                logger.warning("Agent produced no actionable text output. Event details: %s", event)
                reply = "[Agent produced no actionable text output]"
        else:
            logger.warning("Agent event had no error_message and no actionable parts. Event details: %s", event)
            # reply remains "[No response from agent or empty response]"

        if hasattr(event, 'session_id') and event.session_id:
            response_session_id = event.session_id

        logger.debug(
            "Successfully processed AI event. Returning chat response. Session_id: %s, require_form: %s, reply snippet: %.80s",
            response_session_id, require_form, reply
        )
        return reply, response_session_id, require_form

    except Exception as e: # This will catch exceptions if all retries by tenacity fail OR from event processing logic
        logger.error(
            "AI Agent call failed after %s attempts (or error in response processing) for session_id %s: %s",
            settings.ai_agent_retry_attempts,
            session_id,
            e,
            exc_info=True
        )
        # Return a generic error message, specific details are in logs
        return f"[AI Agent Error after retries or processing error: consult logs for details]", session_id, False

# Example of how you might test this function directly (requires ADK and auth)
if __name__ == '__main__':
    if AGENT_INITIALIZED_SUCCESSFULLY: # Check if agent is ready for testing
        print("Testing AI Agent locally (ensure GOOGLE_API_KEY or ADC is set up)...")
        # Test 1: Simple message
        test_message = "Hello, how are you?"
        test_session_id = "local_test_session_123"

        print(f"\nSending message: '{test_message}' with session_id: '{test_session_id}'")
        reply_text, returned_session_id, require_form = get_chat_response(test_message, test_session_id)
        print(f"  Agent Reply: {reply_text}")
        print(f"  Returned Session ID: {returned_session_id}")
        print(f"  Require Form: {require_form}")

        # Test 2: Message without session_id
        test_message_2 = "What's the weather like?"
        print(f"\nSending message: '{test_message_2}' with no session_id")
        reply_text_2, returned_session_id_2, require_form_2 = get_chat_response(test_message_2)
        print(f"  Agent Reply: {reply_text_2}")
        print(f"  Returned Session ID: {returned_session_id_2}")
        print(f"  Require Form: {require_form_2}")

        # Test 3: Potentially problematic (empty message, though ADK might handle it)
        # test_message_3 = ""
        # print(f"\nSending message: '{test_message_3}'")
        # reply_text_3, returned_session_id_3, require_form_3 = get_chat_response(test_message_3)
        # print(f"  Agent Reply: {reply_text_3}")
        # print(f"  Returned Session ID: {returned_session_id_3}")
        # print(f"  Require Form: {require_form_3}")
    elif not ADK_IMPORTED_SUCCESSFULLY:
        print("ADK components not imported. Cannot run local test.")
        reply, sid, req_form = get_chat_response("test message if ADK components not imported")
        print(f"Reply: '{reply}', Session ID: {sid}, Require Form: {req_form}")
    else: # ADK imported but agent not initialized
        print("AI Agent failed to initialize. Cannot run local test.")
        reply, sid, req_form = get_chat_response("test message if AI agent failed to initialize")
        print(f"Reply: '{reply}', Session ID: {sid}, Require Form: {req_form}")

[end of backend/ai_agent.py]

[start of backend/auth.py]
# backend/auth.py
import httpx
import logging
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from jose import JWTError, jwt
from pydantic import BaseModel, ConfigDict, Field
from typing import Optional, Dict, Any, List
from datetime import datetime, timedelta # Added timedelta

from backend.config import settings
from backend.db import get_supabase_client # Supabase client for DB access
from supabase import Client # Type hint for Supabase client

logger = logging.getLogger(__name__)

# --- Pydantic Model for Authenticated User ---
class AuthenticatedUser(BaseModel):
    id: str # UUID from Supabase auth.users.id
    app_role: str
    tenant_id: Optional[str] = None # UUID, as string
    email: Optional[str] = None
    full_name: Optional[str] = None

    # Pydantic V2 config
    model_config = ConfigDict(from_attributes=True)

http_bearer_scheme = HTTPBearer(
    description="Supabase JWT token. Obtain it from Supabase Auth client (e.g., supabase-js after login).",
    bearerFormat="JWT" # OpenAPI: format of the bearer token
)

# --- JWKS (JSON Web Key Set) Caching ---
_jwks_cache: Optional[Dict[str, Any]] = None
_jwks_cache_expiry: Optional[datetime] = None
JWKS_CACHE_TTL_SECONDS = 3600 # Cache JWKS for 1 hour

async def get_jwks() -> Dict[str, Any]:
    global _jwks_cache, _jwks_cache_expiry
    now = datetime.utcnow()

    if _jwks_cache and _jwks_cache_expiry and now < _jwks_cache_expiry:
        logger.debug("Using cached JWKS.")
        return _jwks_cache

    if not settings.supabase_jwks_uri:
        logger.error("Supabase JWKS URI is not configured in settings.")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Authentication system not configured (JWKS URI missing)."
        )

    logger.info(f"Fetching JWKS from: {settings.supabase_jwks_uri}")
    async with httpx.AsyncClient(timeout=10.0) as client:
        try:
            response = await client.get(settings.supabase_jwks_uri)
            response.raise_for_status() # Raises HTTPStatusError for 4xx/5xx responses
            _jwks_cache = response.json()
            _jwks_cache_expiry = now + timedelta(seconds=JWKS_CACHE_TTL_SECONDS)
            logger.info("Successfully fetched and cached JWKS.")
            return _jwks_cache
        except httpx.HTTPStatusError as e:
            logger.error(f"HTTP error fetching JWKS: {e.response.status_code} - {e.response.text}", exc_info=True)
            raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail=f"Failed to fetch JWKS: HTTP {e.response.status_code}")
        except Exception as e: # Includes JSONDecodeError, httpx.RequestError, etc.
            logger.error(f"Failed to fetch or parse JWKS: {e}", exc_info=True)
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Failed to process JWKS: {str(e)}")

async def get_current_active_user(
    auth_creds: HTTPAuthorizationCredentials = Depends(http_bearer_scheme), # Gets Bearer token
    supabase_db: Client = Depends(get_supabase_client) # Renamed to avoid clash with 'supabase' var name
) -> AuthenticatedUser:

    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials or token is invalid/expired.",
        headers={"WWW-Authenticate": "Bearer"},
    )

    token = auth_creds.credentials # The actual token string

    try:
        jwks = await get_jwks()
        unverified_header = jwt.get_unverified_header(token)
        rsa_key = {}
        for key_dict in jwks.get("keys", []): # Added .get with default
            if key_dict.get("kid") == unverified_header.get("kid"): # Added .get
                rsa_key = {
                    "kty": key_dict["kty"], "kid": key_dict["kid"],
                    "use": key_dict["use"], "n": key_dict["n"], "e": key_dict["e"]
                }
                break
        if not rsa_key:
            logger.warning("JWT KID in token header does not match any key in JWKS.")
            raise credentials_exception

        if not settings.supabase_url:
            logger.error("Supabase URL for JWT issuer validation is not configured.")
            raise HTTPException(status_code=500, detail="Auth system config error (issuer URL).")

        expected_issuer = settings.supabase_url + "/auth/v1"

        payload = jwt.decode(
            token,
            rsa_key,
            algorithms=["RS256"],
            audience=settings.supabase_jwt_audience,
            issuer=expected_issuer
        )

        user_id: Optional[str] = payload.get("sub")
        email_from_jwt: Optional[str] = payload.get("email")
        # Supabase default role for authenticated users
        # auth_role_from_jwt: Optional[str] = payload.get("role")

        if user_id is None:
            logger.warning("User ID (sub) not found in JWT payload.")
            raise credentials_exception

    except JWTError as e:
        logger.warning(f"JWT validation/decoding error: {e}", exc_info=True)
        raise credentials_exception
    except HTTPException: # Re-raise HTTPExceptions from get_jwks or config checks
        raise
    except Exception as e: # Catch any other unexpected error during JWT processing
        logger.error(f"Unexpected error during JWT processing: {e}", exc_info=True)
        raise credentials_exception # Treat as validation failure

    # Fetch app-specific user profile from public.users
    if supabase_db is None:
        logger.error("Supabase client (supabase_db) unavailable for fetching user profile.")
        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail="Database client unavailable for user profile.")

    try:
        profile_response = supabase_db.table("users").select("app_role, tenant_id, full_name").eq("id", user_id).maybe_single().execute()

        user_profile = profile_response.data
        if not user_profile:
            logger.warning(f"User profile not found in public.users for user_id: {user_id}. A profile should be created automatically on new user signup.")
            # Depending on policy, could create a default user object here or deny access.
            # For now, deny access if no profile, as tenant_id and app_role are crucial.
            raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="User profile incomplete or not found.")

    except Exception as e:
        logger.error(f"Database error fetching user profile for user_id {user_id}: {e}", exc_info=True)
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Could not fetch user profile details.")

    return AuthenticatedUser(
        id=user_id,
        app_role=user_profile.get("app_role", "user"), # Default to 'user' if somehow missing
        tenant_id=str(user_profile.get("tenant_id")) if user_profile.get("tenant_id") else None,
        email=email_from_jwt, # Email from JWT is generally more reliable/verified
        full_name=user_profile.get("full_name")
    )

[end of backend/auth.py]

[start of backend/config.py]
from pydantic_settings import BaseSettings, SettingsConfigDict
from typing import Optional

class Settings(BaseSettings):
    # AI Agent Settings
    # The default value will be used if the environment variable is not set.
    gemini_model_name: str = "gemini-1.5-flash-latest"

    # API key is optional at this level.
    # Code using this setting should handle the case where it might be None.
    google_api_key: Optional[str] = None

    # Supabase Connection Settings
    supabase_url: Optional[str] = None
    supabase_service_role_key: Optional[str] = None

    # Supabase Auth Settings
    supabase_jwks_uri: Optional[str] = None
    supabase_jwt_audience: str = "authenticated" # Default value
    # supabase_jwt_issuer: Optional[str] = None # Optional: if not set, can be derived from supabase_url

    # AI Agent Retry Settings
    ai_agent_retry_attempts: int = 3
    ai_agent_retry_wait_initial_seconds: int = 1
    ai_agent_retry_wait_max_seconds: int = 10
    ai_agent_retry_wait_multiplier: int = 2

    # Configuration for loading from .env file
    # This uses Pydantic V2 (pydantic-settings) style.
    # For Pydantic V1, you would use:
    # class Config:
    #     env_file = ".env"
    #     env_file_encoding = 'utf-8'
    #     extra = 'ignore' # Allow extra fields in the .env file
    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding='utf-8',
        extra='ignore' # 'extra' allows other environment variables to exist without causing validation errors
    )

# Create a single, importable instance of the settings.
# Other parts of the application will import this instance.
settings = Settings()

# Example of how to use this in other modules:
#
# from backend.config import settings
#
# def some_function():
#     model = settings.gemini_model_name
#     api_key = settings.google_api_key
#     if api_key:
#         print(f"Using API Key: {api_key[:5]}...") # Be careful with logging API keys
#     else:
#         print("Google API Key is not set.")
#     print(f"Using Gemini Model: {model}")

[end of backend/config.py]

[start of backend/contact_api.py]
from fastapi import FastAPI, Depends, HTTPException, status # Added Depends, HTTPException, status
from pydantic import BaseModel, ConfigDict # Added ConfigDict
from fastapi.middleware.cors import CORSMiddleware
import logging
from typing import List, Optional, Any # Ensure List, Optional, Any are imported
from datetime import date, datetime # Ensure date and datetime are imported
# Removed: from sqlalchemy.orm import Session
from supabase import Client # Add this import

# Import the AI agent module
from . import ai_agent
from .config import settings # Ensure settings is imported if used directly
from .db import get_supabase_client # Add this import for the new dependency
from .routers import form_ga_config_router, submission_router, tenant_router # Added tenant_router import
from .services import form_ga_config_service # Added import
from .services import ga4_mp_service # Added import
from .auth import get_current_active_user # Added import for new auth

# Configure basic logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(title="Contact Form API with Chat", version="0.2.0")

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["POST", "GET", "OPTIONS"],
    allow_headers=["*"],
)

# --- Models for /submit endpoint ---
class ContactFormPayload(BaseModel):
    name: str
    email: str
    message: str
    tenant_id: str # Added
    ga_client_id: Optional[str] = None
    ga_session_id: Optional[str] = None
    form_id: Optional[str] = None # Added

class SubmissionResponse(BaseModel): # Newly added
    id: int
    created_at: datetime
    name: str
    email: str
    message: str
    tenant_id: str # Added
    ga_client_id: Optional[str] = None
    ga_session_id: Optional[str] = None
    form_id: Optional[str] = None
    submission_status: Optional[str] = None # Assuming this comes from DB
    status_change_reason: Optional[str] = None # Assuming this comes from DB
    updated_at: Optional[datetime] = None # Assuming this comes from DB

    model_config = ConfigDict(from_attributes=True) # Added for consistency/ORM mode

# --- Models for /chat endpoint ---
class ChatMessage(BaseModel):
    message: str
    session_id: Optional[str] = None

class ChatResponse(BaseModel):
    reply: str
    session_id: Optional[str] = None
    require_form_after_message: bool = False # New field

# --- API Endpoints ---

@app.post("/submit", response_model=SubmissionResponse) # Ensure SubmissionResponse is imported
async def handle_form_submission(
    payload: ContactFormPayload,
    supabase: Optional[Client] = Depends(get_supabase_client)
):
    logger.info(f"Received form submission: {payload.model_dump_json()}") # Use model_dump_json for logging Pydantic V2

    if supabase is None:
        logger.error("Supabase client not available for /submit endpoint.")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Database service is currently unavailable. Please try again later."
        )

    try:
        # For Pydantic V2, use model_dump. For V1, use dict.
        # Assuming Pydantic V2 based on pydantic-settings usage earlier.
        data_to_insert = payload.model_dump(exclude_unset=False)

        # Supabase insert expects a list of dicts, even for a single record
        response = supabase.table("contact_submissions").insert([data_to_insert]).execute()

        if response.data and len(response.data) > 0:
            inserted_record = response.data[0]
            logger.info(f"Successfully inserted submission. ID: {inserted_record.get('id')}")

            # --- GA4 generate_lead ã‚¤ãƒ™ãƒ³ãƒˆé€ä¿¡ ---
            if payload.tenant_id and payload.form_id and payload.ga_client_id: # Added tenant_id check
                try:
                    ga_config_dict = form_ga_config_service.get_ga_configuration(
                        supabase,
                        tenant_id=payload.tenant_id, # Pass tenant_id
                        form_id=payload.form_id
                    )
                    if ga_config_dict:
                        api_secret = ga_config_dict.get("ga4_api_secret")
                        measurement_id = ga_config_dict.get("ga4_measurement_id")

                        if api_secret and measurement_id:
                            event_params = {
                                "event_category": "contact_form",
                                "event_label": payload.form_id,
                            }
                            if payload.ga_session_id:
                                event_params["session_id"] = payload.ga_session_id

                            event_params["value"] = 0  # Added
                            event_params["currency"] = "JPY" # Added

                            ga4_event = {"name": "generate_lead", "params": event_params}

                            logger.info(f"Attempting to send generate_lead event to GA4 for form_id: {payload.form_id}, client_id: {payload.ga_client_id}")
                            ga_sent_successfully = await ga4_mp_service.send_ga4_event(
                                api_secret=api_secret,
                                measurement_id=measurement_id,
                                client_id=payload.ga_client_id,
                                events=[ga4_event]
                            )
                            if not ga_sent_successfully:
                                logger.warning(f"generate_lead event sending to GA4 may have failed for form_id: {payload.form_id} (see previous logs from ga4_mp_service).")
                        else:
                            logger.warning(f"GA4 API secret or Measurement ID missing in config for form_id '{payload.form_id}'. Cannot send generate_lead event.")
                    else:
                        logger.warning(f"GA4 configuration not found for tenant_id '{payload.tenant_id}', form_id '{payload.form_id}'. Cannot send generate_lead event.")
                except Exception as e_ga_setup: # Catch errors during GA config fetch or event construction
                    logger.error(f"Error during GA4 event preparation for generate_lead (tenant_id: {payload.tenant_id}, form_id: {payload.form_id}): {e_ga_setup}", exc_info=True)
            else:
                logger.info("Skipping GA4 generate_lead event: tenant_id, form_id or ga_client_id missing from payload for submission ID: %s.", inserted_record.get('id'))
            # --- GA4 ã‚¤ãƒ™ãƒ³ãƒˆé€ä¿¡ã“ã“ã¾ã§ ---

            return SubmissionResponse(**inserted_record)
        else:
            # Log the actual response from Supabase for debugging
            logger.error(
                "Supabase insert operation did not return data as expected. Full response: %s",
                response.model_dump_json() if hasattr(response, 'model_dump_json') else str(response)
            )
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to save submission: No data returned from database operation."
            )

    except HTTPException: # Re-raise HTTPExceptions directly
        raise
    except Exception as e:
        logger.error(f"Error saving submission to Supabase: {e}", exc_info=True)
        # Avoid leaking detailed error messages to the client in production if not desired.
        # For now, including str(e) for easier debugging during development.
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"An error occurred while processing your request." # str(e) removed for security
        )

@app.post("/chat", response_model=ChatResponse)
async def handle_chat(payload: ChatMessage):
    logger.info(f"Received chat message: '{payload.message}', session_id: {payload.session_id}")

    # Call the ai_agent.py function which now returns three values
    agent_reply, response_session_id, require_form = ai_agent.get_chat_response(
        message=payload.message,
        session_id=payload.session_id
    )

    return ChatResponse(
        reply=agent_reply,
        session_id=response_session_id,
        require_form_after_message=require_form # Pass the value from the agent
    )

@app.get("/")
async def read_root():
    return {"message": "Contact Form API with Chat is running. Submit contact data to /submit or chat messages to /chat"}

# To run this app (for development, from the project root directory):
# uvicorn backend.contact_api:app --reload --port 8000
#
# Example of how to test the /chat endpoint with curl:
# curl -X POST "http://localhost:8000/chat" \
# -H "Content-Type: application/json" \
# -d '{
#   "message": "Hello Agent!",
#   "session_id": "user123_chat789"
# }'

# Placeholder for database session dependency
# In a real application, this would be configured with your database connection
# def get_db(): # This function was already removed in a previous step, ensuring it's gone
    # Mock implementation. Replace with your actual database session provider.
    # For example:
    # from .database import SessionLocal # Assuming you have a database.py
    # db = SessionLocal()
    # try:
    #     yield db
    # finally:
    #     db.close()
    # For now, yielding None and endpoints will check for this.
    # A real implementation would yield a SQLAlchemy Session.
    # yield None # Removed stub get_db function

# The get_current_active_user is now imported from backend.auth
# The old placeholder function below is removed.
# async def get_current_active_user() -> Any: # Added return type hint
#     # Mock implementation.
#     # To simulate a protected endpoint that currently doesn't authenticate properly:
#     # raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Not authenticated")
#     # For development, returning a dummy user or None to bypass actual auth.
#     # return {"username": "devuser", "permissions": ["view_analytics"]} # Keeping this for now, might be used by other parts or future tests
#     return {"username": "devuser", "permissions": ["view_analytics"]}

app.include_router(form_ga_config_router.router)
app.include_router(submission_router.router)
app.include_router(tenant_router.router) # Added line to include the new tenant router

[end of backend/contact_api.py]

[start of backend/db.py]
# backend/db.py
import logging
from typing import Optional
from supabase import create_client, Client
from backend.config import settings # Assuming .config is correct relative path

logger = logging.getLogger(__name__)

supabase_url: Optional[str] = settings.supabase_url
supabase_key: Optional[str] = settings.supabase_service_role_key

supabase_client: Optional[Client] = None

if supabase_url and supabase_key:
    try:
        supabase_client = create_client(supabase_url, supabase_key)
        logger.info("Supabase client initialized successfully.")
    except Exception as e:
        logger.error("Failed to initialize Supabase client: %s", e, exc_info=True)
        supabase_client = None
else:
    logger.warning("Supabase URL or Service Role Key is not set in .env. Supabase client cannot be initialized.")

def get_supabase_client() -> Optional[Client]:
    return supabase_client

[end of backend/db.py]

[start of backend/rag_integration.py]

[end of backend/rag_integration.py]

[start of backend/requirements.txt]
fastapi
uvicorn[standard]
google-adk
python-dotenv
supabase-py>=1.0,<2.0
httpx>=0.20.0,<1.0.0
tenacity>=8.2.0,<9.0.0
python-jose[cryptography]>=3.3.0,<4.0.0

[end of backend/requirements.txt]

[start of backend/models/ga4_config_models.py]
# backend/models/ga4_config_models.py
from pydantic import BaseModel, Field, ConfigDict # ConfigDict for Pydantic V2
from typing import Optional, List
from datetime import datetime

class GA4ConfigurationBase(BaseModel):
    ga4_measurement_id: str = Field(
        ...,
        min_length=1,
        description=\"GA4 Measurement ID (e.g., G-XXXXXXXXXX).\",
        examples=[\"G-1234567890\"]
    )
    ga4_api_secret: str = Field(
        ...,
        min_length=1,
        description=\"GA4 API Secret for Measurement Protocol. This is sensitive data.\"
    )
    description: Optional[str] = Field(
        None,
        description=\"Optional human-readable description for this GA4 configuration set.\",
        examples=[\"Main contact form GA4 settings\"]
    )

class GA4ConfigurationCreatePayload(GA4ConfigurationBase):
    \"\"\"
    Payload for creating a new GA4 configuration.
    form_id will be a path parameter, tenant_id from authenticated user.
    \"\"\"
    pass # Inherits all fields from GA4ConfigurationBase, form_id removed

class GA4ConfigurationUpdatePayload(BaseModel):
    \"\"\"
    Payload for updating an existing GA4 configuration.
    All fields are optional; only provided fields will be updated.
    \"\"\"
    ga4_measurement_id: Optional[str] = Field(
        None,
        min_length=1,
        description=\"New GA4 Measurement ID, if changing.\"
    )
    ga4_api_secret: Optional[str] = Field(
        None,
        min_length=1,
        description=\"New GA4 API Secret, if changing. This is sensitive data.\"
    )
    description: Optional[str] = Field(
        None,
        description=\"New or updated description for this GA4 configuration set.\"
    )

class GA4ConfigurationResponse(GA4ConfigurationBase):
    \"\"\"
    Represents a GA4 configuration record as returned by the API.
    Includes database-generated fields like tenant_id, form_id, created_at, and updated_at.
    \"\"\"
    tenant_id: str # Added
    form_id: str
    created_at: datetime
    updated_at: datetime

    model_config = ConfigDict(from_attributes=True)


class GA4ConfigurationListResponse(BaseModel):
    \"\"\"
    Response model for listing multiple GA4 configurations.
    \"\"\"
    configurations: List[GA4ConfigurationResponse]

[end of backend/models/ga4_config_models.py]

[start of backend/models/submission_models.py]
# backend/models/submission_models.py
from pydantic import BaseModel, Field
from typing import Optional, List # Added List
from backend.contact_api import SubmissionResponse # Added import

class SubmissionStatusUpdatePayload(BaseModel):
    \"\"\"
    Payload for updating the status of a submission.
    \"\"\"
    new_status: str = Field(
        ...,
        min_length=1,
        description=\"The new status to set for the submission (e.g., 'contacted', 'converted', 'spam'). This should match one of the predefined status values.\"\n    )
    reason: Optional[str] = Field(
        None,
        description=\"An optional reason for this status change, especially for statuses like 'unconverted' or 'disqualified'.\"\n    )

# Note: The response for a status update will likely be the full updated submission,
# which can reuse the existing `SubmissionResponse` model defined in `backend.contact_api`.
# Therefore, a specific response model for status updates might not be needed here.


class SubmissionListResponse(BaseModel):
    \"\"\"
    Response model for listing contact submissions.
    Contains a list of submission records and pagination details.
    \"\"\"
    submissions: List[SubmissionResponse]
    total_count: int = Field(..., description=\"Total number of submissions matching the filter criteria.\")
    skip: int = Field(..., ge=0, description=\"Number of records skipped (offset).\")
    limit: int = Field(..., ge=1, description=\"Maximum number of records returned in this response.\")

[end of backend/models/submission_models.py]

[start of backend/models/tenant_models.py]
# backend/models/tenant_models.py
from pydantic import BaseModel, Field, UUID4, ConfigDict
from typing import Optional, List
from datetime import datetime

class TenantBase(BaseModel):
    company_name: str = Field(..., min_length=1, description=\"Name of the tenant company.\")
    domain: Optional[str] = Field(
        None,
        description=\"Domain associated with the tenant (e.g., company website). Can be null.\",
        examples=[\"example.com\"]\n    )

class TenantCreatePayload(TenantBase):
    \"\"\"Payload for creating a new tenant.\"\"\"
    pass

class TenantUpdatePayload(BaseModel):
    \"\"\"Payload for updating an existing tenant. All fields are optional.\"\"\"
    company_name: Optional[str] = Field(None, min_length=1, description=\"New company name, if changing.\")
    domain: Optional[str] = Field(None, description=\"New domain, if changing. Set to null to clear.\")
    is_deleted: Optional[bool] = Field(None, description=\"Set to true to logically delete, false to restore.\")

class TenantResponse(TenantBase):
    \"\"\"Response model for a tenant, including database-generated fields.\"\"\"
    tenant_id: UUID4 # UUID type from Pydantic
    is_deleted: bool
    created_at: datetime
    updated_at: datetime

    model_config = ConfigDict(from_attributes=True) # For Pydantic V2 ORM mode

class TenantListResponse(BaseModel):
    \"\"\"Response model for listing tenants with pagination info.\"\"\"
    tenants: List[TenantResponse]
    total_count: int = Field(..., description=\"Total number of tenants matching filter criteria.\")
    skip: int = Field(..., ge=0, description=\"Number of records skipped (offset).\")
    limit: int = Field(..., ge=1, description=\"Maximum number of records returned.\")

[end of backend/models/tenant_models.py]

[start of backend/routers/form_ga_config_router.py]
# backend/routers/form_ga_config_router.py
from fastapi import APIRouter, Depends, HTTPException, status, Body
from typing import List, Optional, Any # Added Any for current_user
from supabase import Client

from backend.db import get_supabase_client
from backend.models.ga4_config_models import (\n    GA4ConfigurationBase, # Changed from GA4ConfigurationCreatePayload\n    GA4ConfigurationUpdatePayload,\n    GA4ConfigurationResponse,\n    GA4ConfigurationListResponse\n)
from backend.services import form_ga_config_service
from backend.auth import AuthenticatedUser, get_current_active_user # Ensure AuthenticatedUser is imported

router = APIRouter(\n    prefix=\"/api/v1/ga_configurations\",\n    tags=[\"GA4 Form Configurations\"],\n    dependencies=[Depends(get_current_active_user)]\n)

@router.post(\"/{form_id}\", response_model=GA4ConfigurationResponse, status_code=status.HTTP_201_CREATED)
async def create_ga_configuration_endpoint(\n    form_id: str, # form_id from path\n    payload: GA4ConfigurationBase, # Use base model for payload\n    supabase: Client = Depends(get_supabase_client),\n    user: AuthenticatedUser = Depends(get_current_active_user)\n):\n    if supabase is None:\n        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail=\"Supabase client unavailable\")\n    if not user.tenant_id:\n        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=\"User does not have a tenant ID.\")\n\n    existing_config = form_ga_config_service.get_ga_configuration(supabase, tenant_id=user.tenant_id, form_id=form_id)\n    if existing_config:\n        raise HTTPException(\n            status_code=status.HTTP_409_CONFLICT,\n            detail=f\"GA4 configuration for tenant '{user.tenant_id}', form_id '{form_id}' already exists.\"\n        )\n\n    created_config_dict = form_ga_config_service.create_ga_configuration(\n        db=supabase,\n        tenant_id=user.tenant_id,\n        form_id=form_id,\n        payload_base=payload\n    )\n    if not created_config_dict:\n        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=\"Failed to create GA4 configuration.\")\n    return GA4ConfigurationResponse(**created_config_dict)


@router.get(\"\", response_model=GA4ConfigurationListResponse)
async def list_ga_configurations_endpoint(\n    skip: int = 0,\n    limit: int = 20,\n    supabase: Client = Depends(get_supabase_client),\n    user: AuthenticatedUser = Depends(get_current_active_user)\n):\n    if supabase is None:\n        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail=\"Supabase client unavailable\")\n    if not user.tenant_id:\n        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=\"User does not have a tenant ID.\")\n\n    configs_list_dict = form_ga_config_service.list_ga_configurations(\n        db=supabase, tenant_id=user.tenant_id, skip=skip, limit=limit\n    )\n    # Ensure GA4ConfigurationResponse model can handle dicts from service (it should with from_attributes=True)\n    response_items = [GA4ConfigurationResponse(**item) for item in configs_list_dict]\n    return GA4ConfigurationListResponse(configurations=response_items)


@router.get(\"/{form_id}\", response_model=GA4ConfigurationResponse)
async def get_ga_configuration_endpoint(\n    form_id: str,\n    supabase: Client = Depends(get_supabase_client),\n    user: AuthenticatedUser = Depends(get_current_active_user)\n):\n    if supabase is None:\n        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail=\"Supabase client unavailable\")\n    if not user.tenant_id:\n        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=\"User does not have a tenant ID.\")\n\n    config_dict = form_ga_config_service.get_ga_configuration(supabase, tenant_id=user.tenant_id, form_id=form_id)\n    if not config_dict:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f\"GA4 configuration for tenant '{user.tenant_id}', form_id '{form_id}' not found.\")\n    return GA4ConfigurationResponse(**config_dict)


@router.put(\"/{form_id}\", response_model=GA4ConfigurationResponse)
async def update_ga_configuration_endpoint(\n    form_id: str,\n    payload: GA4ConfigurationUpdatePayload,\n    supabase: Client = Depends(get_supabase_client),\n    user: AuthenticatedUser = Depends(get_current_active_user)\n):\n    if supabase is None:\n        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail=\"Supabase client unavailable\")\n    if not user.tenant_id:\n        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=\"User does not have a tenant ID.\")\n\n    updated_config_dict = form_ga_config_service.update_ga_configuration(\n        db=supabase, tenant_id=user.tenant_id, form_id=form_id, config_payload=payload\n    )\n    if not updated_config_dict:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f\"GA4 configuration for tenant '{user.tenant_id}', form_id '{form_id}' not found or no update performed.\")\n    return GA4ConfigurationResponse(**updated_config_dict)


@router.delete(\"/{form_id}\", status_code=status.HTTP_204_NO_CONTENT)
async def delete_ga_configuration_endpoint(\n    form_id: str,\n    supabase: Client = Depends(get_supabase_client),\n    user: AuthenticatedUser = Depends(get_current_active_user)\n):\n    if supabase is None:\n        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail=\"Supabase client unavailable\")\n    if not user.tenant_id:\n        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=\"User does not have a tenant ID.\")\n\n    success = form_ga_config_service.delete_ga_configuration(supabase, tenant_id=user.tenant_id, form_id=form_id)\n    if not success:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f\"GA4 configuration for tenant '{user.tenant_id}', form_id '{form_id}' not found or delete failed.\")\n    # No body for 204 response\n"
    },
    {
      "path": "backend/routers/submission_router.py",
      "content": "# backend/routers/submission_router.py\nimport logging\nfrom fastapi import APIRouter, Depends, HTTPException, status, Path, Query # Added Query\nfrom typing import Optional, Any, Dict, List # Added List\nfrom datetime import date # Added date\nfrom supabase import Client\n\nfrom backend.db import get_supabase_client\nfrom backend.models.submission_models import SubmissionStatusUpdatePayload, SubmissionListResponse # Added SubmissionListResponse\nfrom backend.contact_api import SubmissionResponse as SubmissionItemResponse # Reusing existing model from contact_api and aliasing\n\n# Import services\nfrom backend.services import submission_service\nfrom backend.services import form_ga_config_service\nfrom backend.services import ga4_mp_service\nfrom backend.auth import AuthenticatedUser, get_current_active_user # Ensured AuthenticatedUser is imported\n\nlogger = logging.getLogger(__name__)\n\nrouter = APIRouter(\n    prefix=\"/api/v1/submissions\",\n    tags=[\"Submission Status Management\"],\n    dependencies=[Depends(get_current_active_user)]\n)\n\n# Mapping of submission statuses to GA4 event details\n# This could also live in a config file or a dedicated module if it grows.\nSTATUS_TO_GA4_EVENT_MAP: Dict[str, Dict[str, Any]] = {\n    \"contacted\": {\"name\": \"working_lead\", \"params_template\": {\"lead_status\": \"contacted\"}},\n    \"qualified\": {\"name\": \"qualify_lead\", \"params_template\": {}},\n    \"converted\": {\"name\": \"close_convert_lead\", \"params_template\": {}}, # transaction_id to be added dynamically\n    \"unconverted\": {\"name\": \"lead_unconverted\", \"params_template\": {}}, # Custom event\n    \"disqualified\": {\"name\": \"lead_disqualified\", \"params_template\": {}}, # Custom event\n}\n\nCONTACT_SUBMISSIONS_TABLE = \"contact_submissions\" # Define table name constant\n\n@router.patch(\"/{submission_id}/status\", response_model=SubmissionItemResponse)\nasync def update_submission_status_endpoint(\n    submission_id: int = Path(..., title=\"The ID of the submission to update\", ge=1),\n    payload: SubmissionStatusUpdatePayload,\n    supabase: Client = Depends(get_supabase_client),\n    user: AuthenticatedUser = Depends(get_current_active_user) # Inject user\n):\n    if supabase is None:\n        logger.error(\"Supabase client unavailable for PATCH /submissions/%s/status\", submission_id)\n        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail=\"Supabase client unavailable\")\n\n    if not user.tenant_id:\n        logger.error(\"User tenant_id missing for PATCH /submissions/%s/status\", submission_id)\n        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=\"User not associated with a tenant.\")\n\n    # 1. Fetch current submission, scoped by tenant_id\n    try:\n        query = (\n            supabase.table(CONTACT_SUBMISSIONS_TABLE)\n            .select(\"id, form_id, ga_client_id, ga_session_id, submission_status, tenant_id\") # Ensure tenant_id is selected\n            .eq(\"id\", submission_id)\n            .eq(\"tenant_id\", user.tenant_id) # Scope to tenant\n            .single()\n        )\n        current_submission_response = query.execute()\n\n        if not current_submission_response.data:\n            logger.warning(f\"Submission with id {submission_id} not found for tenant {user.tenant_id}.\")\n            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f\"Submission with id {submission_id} not found.\")\n        current_submission = current_submission_response.data\n        original_status = current_submission.get(\"submission_status\")\n\n    except Exception as e_fetch:\n        logger.error(f\"Failed to fetch submission {submission_id} for tenant {user.tenant_id}: {e_fetch}\", exc_info=True)\n        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f\"Failed to retrieve submission details for id {submission_id}.\")\n\n    # 2. Update the submission status, scoped by tenant_id\n    updated_submission_dict = await submission_service.update_submission_status(\n        db=supabase,\n        tenant_id=user.tenant_id, # Pass tenant_id\n        submission_id=submission_id,\n        new_status=payload.new_status,\n        reason=payload.reason\n    )\n\n    if not updated_submission_dict:\n        logger.error(f\"Update_submission_status service failed for submission_id: {submission_id}, tenant_id: {user.tenant_id}\")\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f\"Failed to update submission status for id {submission_id}, record may not exist or update failed.\")\n\n    # 3. Send GA4 event if status actually changed and is mapped\n    if original_status != payload.new_status and payload.new_status in STATUS_TO_GA4_EVENT_MAP:\n        form_id = current_submission.get(\"form_id\")\n        ga_client_id = current_submission.get(\"ga_client_id\")\n\n        if form_id and ga_client_id: # tenant_id is confirmed from user object\n            ga_config_dict = form_ga_config_service.get_ga_configuration(\n                db=supabase, tenant_id=user.tenant_id, form_id=form_id # Pass tenant_id\n            )\n\n            if ga_config_dict:\n                api_secret = ga_config_dict.get(\"ga4_api_secret\")\n                measurement_id = ga_config_dict.get(\"ga4_measurement_id\")\n\n                if api_secret and measurement_id:\n                    event_config = STATUS_TO_GA4_EVENT_MAP[payload.new_status]\n                    event_params = {**event_config[\"params_template\"]}\n\n                    event_params[\"value\"] = 0\n                    event_params[\"currency\"] = \"JPY\"\n\n                    event_params[\"form_id\"] = form_id\n                    if current_submission.get(\"ga_session_id\"):\n                        event_params[\"session_id\"] = current_submission.get(\"ga_session_id\")\n                    if payload.new_status == \"converted\":\n                        event_params[\"transaction_id\"] = str(submission_id)\n\n                    ga4_event_payload = {\"name\": event_config[\"name\"], \"params\": event_params}\n\n                    logger.info(\n                        f\"Attempting to send GA4 event '{ga4_event_payload['name']}' for tenant_id: {user.tenant_id}, submission_id: {submission_id}, new_status: {payload.new_status}\"\n                    )\n                    try:\n                        await ga4_mp_service.send_ga4_event(\n                            api_secret=api_secret,\n                            measurement_id=measurement_id,\n                            client_id=ga_client_id,\n                            events=[ga4_event_payload]\n                        )\n                    except Exception as e_ga:\n                        logger.error(\n                            f\"Unhandled error when trying to send GA4 event for tenant_id: {user.tenant_id}, submission_id {submission_id} (status {payload.new_status}): {e_ga}\",\n                            exc_info=True\n                        )\n                else:\n                    logger.warning(f\"GA4 API secret or Measurement ID missing in config for tenant_id '{user.tenant_id}', form_id '{form_id}'. Cannot send '{payload.new_status}' event for submission {submission_id}.\")\n            else:\n                logger.warning(f\"GA4 configuration not found for tenant_id '{user.tenant_id}', form_id '{form_id}'. Cannot send '{payload.new_status}' event for submission {submission_id}.\")\n        else:\n            logger.info(f\"Skipping GA4 '{payload.new_status}' event for tenant_id: {user.tenant_id}, submission {submission_id}: form_id or ga_client_id missing.\")\n\n    return SubmissionItemResponse(**updated_submission_dict)\n\n\n@router.get(\"\", response_model=SubmissionListResponse, tags=[\"Submissions Data\"])\nasync def list_submissions_endpoint(\n    form_id: Optional[str] = Query(None, description=\"Filter by form_id.\"),\n    submission_status: Optional[str] = Query(None, description=\"Filter by submission status.\"),\n    email: Optional[str] = Query(None, description=\"Filter by email (case-insensitive, partial match).\"),\n    name: Optional[str] = Query(None, description=\"Filter by name (case-insensitive, partial match).\"),\n    start_date: Optional[date] = Query(None, description=\"Filter by creation date (start of range, YYYY-MM-DD).\"),\n    end_date: Optional[date] = Query(None, description=\"Filter by creation date (end of range, YYYY-MM-DD).\"),\n    skip: int = Query(0, ge=0, description=\"Number of records to skip.\"),\n    limit: int = Query(20, ge=1, le=100, description=\"Maximum number of records to return.\"),\n    sort_by: Optional[str] = Query(\"created_at\", enum=[\"created_at\", \"updated_at\", \"name\", \"submission_status\", \"id\", \"email\", \"form_id\"], description=\"Column to sort by.\"),\n    sort_order: Optional[str] = Query(\"desc\", enum=[\"asc\", \"desc\"], description=\"Sort order (asc or desc).\"),\n    supabase: Client = Depends(get_supabase_client),\n    user: AuthenticatedUser = Depends(get_current_active_user) # Inject user\n):\n    if supabase is None:\n        logger.error(\"Supabase client unavailable for GET /api/v1/submissions\")\n        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail=\"Supabase client unavailable\")\n\n    if not user.tenant_id:\n        logger.error(\"User tenant_id missing for GET /api/v1/submissions\")\n        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=\"User not associated with a tenant.\")\n\n    try:\n        submissions_list_dicts, total_count = await submission_service.list_submissions(\n            db=supabase,\n            tenant_id=user.tenant_id, # Pass tenant_id\n            skip=skip,\n            limit=limit,\n            form_id=form_id,\n            submission_status=submission_status,\n            email=email,\n            name=name,\n            start_date=start_date,\n            end_date=end_date,\n            sort_by=sort_by,\n            sort_order=sort_order\n        )\n\n        parsed_submissions = [SubmissionItemResponse(**item) for item in submissions_list_dicts]\n\n        return SubmissionListResponse(\n            submissions=parsed_submissions,\n            total_count=total_count,\n            skip=skip,\n            limit=limit\n        )\n    except Exception as e:\n        logger.error(f\"Error listing submissions: {e}\", exc_info=True)\n        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=\"Failed to list submissions.\")\n"
    },
    {
      "path": "backend/routers/tenant_router.py",
      "content": "# backend/routers/tenant_router.py\nimport logging\nfrom uuid import UUID\nfrom fastapi import APIRouter, Depends, HTTPException, status, Query, Path # Added Path\nfrom typing import List, Optional, Any\nfrom supabase import Client\n\nfrom backend.db import get_supabase_client\nfrom backend.models.tenant_models import (\n    TenantCreatePayload,\n    TenantUpdatePayload,\n    TenantResponse,\n    TenantListResponse\n)\nfrom backend.services import tenant_service\nfrom backend.auth import AuthenticatedUser, get_current_active_user # Import from auth.py\n\nlogger = logging.getLogger(__name__)\n\nrouter = APIRouter(\n    prefix=\"/api/v1/tenants\",\n    tags=[\"Tenant Management (Superuser Only)\"] # Tag updated for clarity\n)\n\n# Dependency for superuser check\nasync def require_superuser_role(user: AuthenticatedUser = Depends(get_current_active_user)):\n    # This assumes 'superuser' is a defined app_role for superusers.\n    # And that user.tenant_id might be None for a superuser not tied to a specific tenant context by default.\n    if user.app_role != \"superuser\":\n        logger.warning(f\"User {user.id} (role: {user.app_role}) attempted to access superuser-only tenant API at {router.prefix}.\")\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"You do not have permission to manage tenants.\"\n        )\n    return user\n\n# Apply superuser check to all routes in this router\nrouter.dependencies.append(Depends(require_superuser_role))\n\n\n@router.post(\"\", response_model=TenantResponse, status_code=status.HTTP_201_CREATED)\nasync def create_tenant_endpoint(\n    payload: TenantCreatePayload,\n    supabase: Client = Depends(get_supabase_client)\n    # superuser: AuthenticatedUser = Depends(require_superuser_role) # Covered by router dependency\n):\n    if supabase is None:\n        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail=\"Supabase client unavailable\")\n\n    # Optional: Check if tenant with same company_name or domain already exists if they should be unique\n    # This would require additional service methods like get_tenant_by_name/domain.\n    # For now, relying on DB constraints if any (e.g. unique domain if schema had it).\n\n    created_tenant_dict = await tenant_service.create_tenant(supabase, payload)\n    if not created_tenant_dict:\n        # Consider more specific error if service layer can provide it (e.g. duplicate)\n        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=\"Failed to create tenant. Check server logs for details.\")\n    return TenantResponse(**created_tenant_dict)\n\n\n@router.get(\"\", response_model=TenantListResponse)\nasync def list_tenants_endpoint(\n    skip: int = Query(0, ge=0, description=\"Number of records to skip for pagination.\"),\n    limit: int = Query(20, ge=1, le=100, description=\"Maximum number of records to return.\"),\n    show_deleted: bool = Query(False, description=\"Set to true to include logically deleted tenants.\"),\n    supabase: Client = Depends(get_supabase_client)\n):\n    if supabase is None:\n        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail=\"Supabase client unavailable\")\n\n    tenants_list_dict, total_count = await tenant_service.list_tenants(supabase, skip, limit, show_deleted)\n    return TenantListResponse(\n        tenants=[TenantResponse(**t) for t in tenants_list_dict],\n        total_count=total_count,\n        skip=skip,\n        limit=limit\n    )\n\n@router.get(\"/{tenant_id}\", response_model=TenantResponse)\nasync def get_tenant_endpoint(\n    tenant_id: UUID = Path(..., description=\"The UUID of the tenant to retrieve.\"), # Use Path for path params\n    supabase: Client = Depends(get_supabase_client)\n):\n    if supabase is None:\n        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail=\"Supabase client unavailable\")\n\n    tenant_dict = await tenant_service.get_tenant(supabase, tenant_id)\n    if not tenant_dict:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f\"Tenant with id '{tenant_id}' not found.\")\n    return TenantResponse(**tenant_dict)\n\n@router.put(\"/{tenant_id}\", response_model=TenantResponse)\nasync def update_tenant_endpoint(\n    tenant_id: UUID = Path(..., description=\"The UUID of the tenant to update.\"),\n    payload: TenantUpdatePayload,\n    supabase: Client = Depends(get_supabase_client)\n):\n    if supabase is None:\n        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail=\"Supabase client unavailable\")\n\n    updated_tenant_dict = await tenant_service.update_tenant(supabase, tenant_id, payload)\n    if not updated_tenant_dict:\n        # This could be not found, or an empty update payload that resulted in no change (service returns current)\n        # If service returns None specifically for \"not found\", then 404 is appropriate.\n        # Assuming service returns None if tenant_id not found by update call.\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f\"Tenant with id '{tenant_id}' not found or update resulted in no change/failed.\")\n    return TenantResponse(**updated_tenant_dict)\n\n@router.delete(\"/{tenant_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_tenant_endpoint(\n    tenant_id: UUID = Path(..., description=\"The UUID of the tenant to delete.\"),\n    hard_delete: bool = Query(False, description=\"Set to true to permanently (hard) delete the tenant. Default is logical delete.\"),\n    supabase: Client = Depends(get_supabase_client)\n):\n    if supabase is None:\n        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail=\"Supabase client unavailable\")\n\n    success = await tenant_service.delete_tenant(supabase, tenant_id, hard_delete)\n    if not success:\n        # Service's delete_tenant returns False if record not found (for hard delete)\n        # or if already in the desired state (for logical delete, though service was updated to return True here).\n        # Or if DB error occurs. For simplicity, map to 404 if not successful.\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f\"Tenant with id '{tenant_id}' not found or delete operation failed.\")\n    # For 204, FastAPI expects no return value (or None).\n"
    },
    {
      "path": "backend/services/form_ga_config_service.py",
      "content": "# backend/services/form_ga_config_service.py\nimport logging\nfrom typing import List, Optional, Dict, Any\nfrom supabase import Client\n# GA4ConfigurationCreatePayload is now GA4ConfigurationBase for the service create function\nfrom backend.models.ga4_config_models import GA4ConfigurationBase, GA4ConfigurationUpdatePayload\n\nlogger = logging.getLogger(__name__)\nTABLE_NAME = \"form_ga_configurations\"\n\ndef create_ga_configuration(\n    db: Client,\n    tenant_id: str,\n    form_id: str,\n    payload_base: GA4ConfigurationBase\n) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    Creates a new GA4 configuration for a specific tenant and form_id.\n    Returns the created record as a dictionary, or None if creation failed.\n    \"\"\"\n    try:\n        data_to_insert = payload_base.model_dump()\n        data_to_insert[\"tenant_id\"] = tenant_id\n        data_to_insert[\"form_id\"] = form_id\n\n        response = db.table(TABLE_NAME).insert(data_to_insert).execute()\n        if response.data and len(response.data) > 0:\n            logger.info(f\"GA4 configuration created for tenant_id: {tenant_id}, form_id: {form_id}\")\n            return response.data[0]\n        else:\n            logger.warning(\n                f\"Failed to create GA4 configuration for tenant_id: {tenant_id}, form_id: {form_id}. \"\n                f\"Supabase response: {response.model_dump_json() if hasattr(response, 'model_dump_json') else str(response)}\"\n            )\n            return None\n    except Exception as e: # More specific exceptions could be caught from supabase.exceptions\n        logger.error(\n            f\"Exception creating GA4 configuration for tenant_id: {tenant_id}, form_id {form_id}: {e}\",\n            exc_info=True\n        )\n        return None\n\ndef get_ga_configuration(db: Client, tenant_id: str, form_id: str) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    Retrieves a GA4 configuration by tenant_id and form_id.\n    Returns the record as a dictionary, or None if not found.\n    \"\"\"\n    try:\n        response = (\n            db.table(TABLE_NAME)\n            .select(\"*\")\n            .eq(\"tenant_id\", tenant_id) # Added tenant_id filter\n            .eq(\"form_id\", form_id)\n            .single()\n            .execute()\n        )\n        # single() returns the object directly in .data if found, or raises an error if >1, or data is None if 0\n        if response.data:\n            return response.data\n        else: # Should be caught by PostgrestAPIError if not found with single(), but defensive check\n            logger.info(f\"No GA4 configuration found for tenant_id '{tenant_id}' and form_id '{form_id}'.\")\n            return None\n    except Exception as e: # Catch supabase.exceptions.PostgrestAPIError for \"No rows found\" specifically if desired\n        logger.error(f\"Exception retrieving GA4 configuration for tenant_id '{tenant_id}', form_id '{form_id}': {e}\", exc_info=True)\n        return None\n\ndef list_ga_configurations(db: Client, tenant_id: str, skip: int = 0, limit: int = 100) -> List[Dict[str, Any]]:\n    \"\"\"\n    Lists GA4 configurations for a specific tenant with pagination.\n    Returns a list of records (dictionaries).\n    \"\"\"\n    try:\n        response = (\n            db.table(TABLE_NAME)\n            .select(\"*\")\n            .eq(\"tenant_id\", tenant_id)\n            .range(skip, skip + limit - 1)\n            .execute()\n        )\n        return response.data if response.data else []\n    except Exception as e:\n        logger.error(f\"Exception listing GA4 configurations for tenant_id {tenant_id}: {e}\", exc_info=True)\n        return []\n\ndef update_ga_configuration(\n    db: Client,\n    tenant_id: str,\n    form_id: str,\n    config_payload: GA4ConfigurationUpdatePayload\n) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    Updates an existing GA4 configuration for a given tenant_id and form_id.\n    Only updates fields present in the payload (non-None).\n    Returns the updated record as a dictionary, or None if not found or update failed.\n    \"\"\"\n    try:\n        data_to_update = config_payload.model_dump(exclude_unset=True)\n\n        if not data_to_update:\n            logger.info(f\"No fields to update for GA4 configuration for tenant_id: {tenant_id}, form_id: {form_id}. Returning current record.\")\n            return get_ga_configuration(db, tenant_id, form_id)\n\n        response = (\n            db.table(TABLE_NAME)\n            .update(data_to_update)\n            .eq(\"tenant_id\", tenant_id)\n            .eq(\"form_id\", form_id)\n            .execute()\n        )\n        if response.data and len(response.data) > 0:\n            logger.info(f\"GA4 configuration updated for tenant_id: {tenant_id}, form_id: {form_id}\")\n            return response.data[0]\n        else:\n            logger.warning(\n                f\"Failed to update GA4 configuration for tenant_id: {tenant_id}, form_id: {form_id} (it may not exist or no data returned). \"\n                f\"Supabase response: {response.model_dump_json() if hasattr(response, 'model_dump_json') else str(response)}\"\n            )\n            return None\n    except Exception as e:\n        logger.error(f\"Exception updating GA4 configuration for tenant_id: {tenant_id}, form_id {form_id}: {e}\", exc_info=True)\n        return None\n\ndef delete_ga_configuration(db: Client, tenant_id: str, form_id: str) -> bool:\n    \"\"\"\n    Deletes a GA4 configuration by tenant_id and form_id.\n    Returns True if deletion was successful, False otherwise.\n    \"\"\"\n    try:\n        response = (\n            db.table(TABLE_NAME)\n            .delete()\n            .eq(\"tenant_id\", tenant_id)\n            .eq(\"form_id\", form_id)\n            .execute()\n        )\n        if response.data and len(response.data) > 0:\n            logger.info(f\"GA4 configuration deleted for tenant_id: {tenant_id}, form_id: {form_id}\")\n            return True\n        else:\n            logger.warning(f\"GA4 configuration for tenant_id: {tenant_id}, form_id: {form_id} not found or delete returned no data. Response: {response.model_dump_json() if hasattr(response, 'model_dump_json') else str(response)}\")\n            return False\n    except Exception as e:\n        logger.error(f\"Exception deleting GA4 configuration for tenant_id: {tenant_id}, form_id {form_id}: {e}\", exc_info=True)\n        return False\n"
    },
    {
      "path": "backend/services/ga4_mp_service.py",
      "content": "# backend/services/ga4_mp_service.py\nimport httpx\nimport logging\nfrom typing import List, Dict, Any, Optional\nimport time # For timestamp_micros default\n\nlogger = logging.getLogger(__name__)\n\nGA4_MP_URL = \"https://www.google-analytics.com/mp/collect\"\n# Measurement Protocolãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆç§’ï¼‰\nDEFAULT_MP_TIMEOUT = 10.0\n\nasync def send_ga4_event(\n    api_secret: str,\n    measurement_id: str,\n    client_id: str,\n    events: List[Dict[str, Any]],\n    # session_id is typically part of event params, but can be passed for inclusion\n    # timestamp_micros defaults to current time if not provided\n    timestamp_micros: Optional[int] = None,\n    user_properties: Optional[Dict[str, Any]] = None,\n    non_personalized_ads: bool = False\n) -> bool:\n    \"\"\"\n    Sends one or more events to Google Analytics 4 Measurement Protocol.\n\n    Args:\n        api_secret: The API secret for the GA4 property.\n        measurement_id: The Measurement ID for the GA4 property.\n        client_id: The client ID for the user.\n        events: A list of event objects. Each event object should be a dictionary\n                with 'name' (string) and 'params' (dict) keys.\n        timestamp_micros: Event timestamp in microseconds (UTC).\n                          If None, current time will be used.\n        user_properties: Optional user properties to send.\n        non_personalized_ads: Whether these events are for non-personalized ads.\n\n    Returns:\n        True if the request was successful (2xx status code), False otherwise.\n    \"\"\"\n    if not api_secret or not measurement_id:\n        logger.error(\"GA4 API Secret or Measurement ID is missing. Cannot send event(s) for client_id: %s\", client_id)\n        return False\n    if not client_id:\n        logger.error(\"GA4 Client ID is missing. Cannot send event(s) for measurement_id: %s\", measurement_id)\n        return False\n    if not events:\n        logger.warning(\"No events provided to send to GA4 for client_id: %s, measurement_id: %s.\", client_id, measurement_id)\n        return True # No events to send is not an error of this function.\n\n    # Prepare the main payload\n    payload: Dict[str, Any] = {\n        \"client_id\": client_id,\n        \"non_personalized_ads\": non_personalized_ads,\n        \"events\": events, # Events should already have session_id in their params if needed\n    }\n\n    if timestamp_micros is None:\n        # Default to current time in microseconds if not provided\n        payload[\"timestamp_micros\"] = int(time.time() * 1_000_000)\n    else:\n        payload[\"timestamp_micros\"] = timestamp_micros\n\n    if user_properties:\n        payload[\"user_properties\"] = user_properties\n\n    # Query parameters for the POST request\n    query_params = {\n        \"api_secret\": api_secret,\n        \"measurement_id\": measurement_id,\n    }\n\n    event_names = [event.get(\"name\", \"unknown_event\") for event in events]\n    logger.debug(\n        \"Attempting to send GA4 events. Measurement ID: %s, Client ID: %s, Events: %s, Payload: %s\",\n        measurement_id, client_id, event_names, payload\n    )\n\n    try:\n        async with httpx.AsyncClient(timeout=DEFAULT_MP_TIMEOUT) as http_client: # Renamed client to http_client\n            response = await http_client.post(GA4_MP_URL, params=query_params, json=payload)\n\n        if 200 <= response.status_code < 300:\n            logger.info(\n                \"Successfully sent %d event(s) to GA4: %s (Measurement ID: %s, Client ID: %s)\",\n                len(events), event_names, measurement_id, client_id\n            )\n            # Check for validation messages if the validation server was hit (usually by not using \"www.\")\n            # or if GA4 MP returns them in a successful response.\n            if response.content:\n                try:\n                    validation_data = response.json()\n                    if validation_data and validation_data.get(\"validationMessages\"):\n                        logger.warning(\n                            \"GA4 Measurement Protocol validation messages for Measurement ID %s, Client ID %s: %s\",\n                            measurement_id, client_id, validation_data.get(\"validationMessages\")\n                        )\n                except Exception: # Not a JSON response\n                    logger.debug(\n                        \"GA4 Measurement Protocol response content (non-JSON) for Measurement ID %s, Client ID %s: %s\",\n                        measurement_id, client_id, response.text[:500]\n                    )\n            return True\n        else:\n            logger.error(\n                \"Failed to send event(s) to GA4: %s (Measurement ID: %s, Client ID: %s). Status: %d, Response: %s\",\n                event_names, measurement_id, client_id, response.status_code, response.text[:500]\n            )\n            return False\n    except httpx.TimeoutException:\n        logger.error(\n            \"Timeout sending event(s) to GA4: %s (Measurement ID: %s, Client ID: %s).\",\n            event_names, measurement_id, client_id\n        )\n        return False\n    except httpx.RequestError as e:\n        logger.error(\n            \"RequestError sending event(s) to GA4: %s (Measurement ID: %s, Client ID: %s): %s\",\n            event_names, measurement_id, client_id, e, exc_info=True\n        )\n        return False\n    except Exception as e:\n        logger.error(\n            \"Unexpected error sending event(s) to GA4: %s (Measurement ID: %s, Client ID: %s): %s\",\n            event_names, measurement_id, client_id, e, exc_info=True\n        )\n        return False\n"
    },
    {
      "path": "backend/services/submission_service.py",
      "content": "# backend/services/submission_service.py\nimport logging\nfrom typing import Optional, Dict, Any, Tuple, List # Added Tuple, List\nfrom supabase import Client\nfrom datetime import date, time, datetime # Added date, time, datetime\n\nlogger = logging.getLogger(__name__)\nCONTACT_SUBMISSIONS_TABLE = \"contact_submissions\"\n\nasync def update_submission_status(\n    db: Client,\n    tenant_id: str,\n    submission_id: int,\n    new_status: str,\n    reason: Optional[str] = None\n) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    Updates the 'submission_status' and 'status_change_reason' for a contact submission.\n\n    It's assumed that an 'updated_at' field in the 'contact_submissions' table\n    is handled by a database trigger or will be addressed in a separate schema update.\n    This function does not explicitly set 'updated_at'.\n\n    Args:\n        db: Supabase client instance.\n        submission_id: The ID of the submission to update.\n        new_status: The new status string.\n        reason: Optional reason for the status change. If None, the reason field\n                in the database will be set to NULL (or cleared).\n\n    Returns:\n        A dictionary representing the updated submission record if successful,\n        otherwise None.\n    \"\"\"\n    try:\n        update_data: Dict[str, Any] = {\"submission_status\": new_status}\n\n        # Set status_change_reason, explicitly setting to None if reason is not provided\n        # to ensure it clears any existing reason in the DB.\n        update_data[\"status_change_reason\"] = reason\n\n        response = (\n            db.table(CONTACT_SUBMISSIONS_TABLE)\n            .update(update_data)\n            .eq(\"id\", submission_id)\n            .eq(\"tenant_id\", tenant_id) # Add tenant_id filter\n            .execute()\n        )\n\n        if response.data and len(response.data) > 0:\n            logger.info(f\"Submission status updated for tenant_id: {tenant_id}, id: {submission_id} to '{new_status}'. Reason: '{reason if reason else 'N/A'}'\")\n            return response.data[0]\n        else:\n            logger.warning(\n                f\"Failed to update submission status for tenant_id: {tenant_id}, id: {submission_id}. Record not found or no data returned. \"\n                f\"Supabase response: {response.model_dump_json() if hasattr(response, 'model_dump_json') else str(response)}\"\n            )\n            return None\n    except Exception as e:\n        logger.error(f\"Exception updating submission status for tenant_id: {tenant_id}, id: {submission_id}: {e}\", exc_info=True)\n        return None\n\nasync def list_submissions(\n    db: Client,\n    tenant_id: str, # Added tenant_id\n    skip: int = 0,\n    limit: int = 20,\n    form_id: Optional[str] = None,\n    submission_status: Optional[str] = None,\n    email: Optional[str] = None,\n    name: Optional[str] = None,\n    start_date: Optional[date] = None,\n    end_date: Optional[date] = None,\n    sort_by: Optional[str] = \"created_at\", # Default sort\n    sort_order: Optional[str] = \"desc\",   # Default order\n) -> Tuple[List[Dict[str, Any]], int]:\n    \"\"\"\n    Lists contact submissions for a specific tenant with filtering, pagination, and sorting.\n    Returns a tuple of (list of submission records as dictionaries, total_count).\n    Note: The Supabase client's execute() method is synchronous. For true async\n    behavior in a FastAPI async endpoint, this should be run in a thread pool\n    (e.g., using fastapi.concurrency.run_in_threadpool).\n    \"\"\"\n    try:\n        query = db.table(CONTACT_SUBMISSIONS_TABLE).select(\"*\", count=\"exact\").eq(\"tenant_id\", tenant_id)\n\n        # Apply other filters\n        if form_id:\n            query = query.eq(\"form_id\", form_id)\n        if submission_status:\n            query = query.eq(\"submission_status\", submission_status)\n        if email:\n            query = query.ilike(\"email\", f\"%{email}%\")\n        if name:\n            query = query.ilike(\"name\", f\"%{name}%\")\n\n        if start_date:\n            # Combine with min time and convert to ISO format string for Supabase\n            start_datetime_iso = datetime.combine(start_date, time.min).isoformat()\n            query = query.gte(\"created_at\", start_datetime_iso)\n        if end_date:\n            # Combine with max time and convert to ISO format string\n            end_datetime_iso = datetime.combine(end_date, time.max).isoformat()\n            query = query.lte(\"created_at\", end_datetime_iso)\n\n        # Apply sorting\n        # Ensure sort_by is a valid column name to prevent injection-like issues if it were user-supplied without validation.\n        # Here, it's from a Query(enum=[...]) in the router, so it's relatively safe.\n        if sort_by and sort_order:\n            is_ascending = sort_order.lower() == \"asc\"\n            query = query.order(sort_by, desc=not is_ascending)\n\n        # Apply pagination\n        # Supabase range is inclusive for 'to', so skip + limit - 1\n        query = query.range(skip, skip + limit - 1)\n\n        # Execute the query (synchronous call)\n        response = query.execute()\n\n        submissions = response.data if response.data else []\n        total_count = response.count if response.count is not None else 0 # Get total count from 'exact'\n\n        logger.debug(f\"Listed {len(submissions)} submissions for tenant_id {tenant_id} (skip={skip}, limit={limit}) with total_count {total_count} matching criteria.\")\n        return submissions, total_count\n\n    except Exception as e:\n        logger.error(f\"Exception listing submissions for tenant_id {tenant_id} with criteria (form_id={form_id}, status={submission_status}, etc.): {e}\", exc_info=True)\n        return [], 0\n"
    },
    {
      "path": "backend/services/tenant_service.py",
      "content": "# backend/services/tenant_service.py\nimport logging\nfrom typing import List, Optional, Dict, Any, Tuple\nfrom uuid import UUID # For type hinting UUID\nfrom supabase import Client\nfrom backend.models.tenant_models import TenantCreatePayload, TenantUpdatePayload\n# from datetime import datetime, timezone # Not explicitly setting updated_at here, relying on DB trigger\n\nlogger = logging.getLogger(__name__)\nTENANTS_TABLE = \"tenants\" # Table name constant\n\nasync def create_tenant(db: Client, payload: TenantCreatePayload) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    Creates a new tenant. tenant_id is auto-generated by the database.\n    Returns the created tenant record as a dictionary, or None on failure.\n    \"\"\"\n    try:\n        data_to_insert = payload.model_dump()\n        # tenant_id is expected to be defaulted by gen_random_uuid() in the DB schema\n        response = db.table(TENANTS_TABLE).insert(data_to_insert).execute()\n\n        if response.data and len(response.data) > 0:\n            created_tenant = response.data[0]\n            logger.info(f\"Tenant created: {created_tenant.get('company_name')} (ID: {created_tenant.get('tenant_id')})\")\n            return created_tenant\n        else:\n            logger.error(\n                f\"Failed to create tenant, Supabase response did not contain data. Payload: {payload.model_dump_json()}. \"\n                f\"Response: {response.model_dump_json() if hasattr(response, 'model_dump_json') else str(response)}\"\n            )\n            return None\n    except Exception as e: # Consider catching specific Supabase/PostgREST exceptions if available\n        logger.error(f\"Exception creating tenant ({payload.company_name}): {e}\", exc_info=True)\n        return None\n\nasync def get_tenant(db: Client, tenant_id: UUID) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    Retrieves a specific tenant by its UUID.\n    Returns the tenant record as a dictionary, or None if not found.\n    \"\"\"\n    try:\n        response = db.table(TENANTS_TABLE).select(\"*\").eq(\"tenant_id\", str(tenant_id)).maybe_single().execute()\n        # maybe_single() returns data as dict if found, None if no rows (and no error raised for 0 rows)\n        if response.data:\n            logger.debug(f\"Tenant found: {tenant_id}\")\n            return response.data\n        else:\n            logger.debug(f\"Tenant not found: {tenant_id}\")\n            return None\n    except Exception as e:\n        logger.error(f\"Exception retrieving tenant {tenant_id}: {e}\", exc_info=True)\n        return None\n\nasync def list_tenants(\n    db: Client, skip: int = 0, limit: int = 20, show_deleted: bool = False\n) -> Tuple[List[Dict[str, Any]], int]:\n    \"\"\"\n    Lists tenants with pagination and an option to include logically deleted ones.\n    Returns a tuple: (list of tenant records, total_count).\n    \"\"\"\n    try:\n        query = db.table(TENANTS_TABLE).select(\"*\", count=\"exact\")\n        if not show_deleted:\n            query = query.eq(\"is_deleted\", False)\n\n        query = query.order(\"company_name\", desc=False).range(skip, skip + limit - 1) # Default sort by company_name asc\n        response = query.execute()\n\n        tenants = response.data if response.data else []\n        total_count = response.count if response.count is not None else 0\n        logger.debug(f\"Listed {len(tenants)} tenants (total: {total_count}, skip: {skip}, limit: {limit}, show_deleted: {show_deleted})\")\n        return tenants, total_count\n    except Exception as e:\n        logger.error(f\"Exception listing tenants: {e}\", exc_info=True)\n        return [], 0\n\nasync def update_tenant(\n    db: Client, tenant_id: UUID, payload: TenantUpdatePayload\n) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    Updates an existing tenant. Only fields present in the payload are updated.\n    Returns the updated tenant record as a dictionary, or None if not found or update failed.\n    Assumes updated_at is handled by a DB trigger.\n    \"\"\"\n    try:\n        data_to_update = payload.model_dump(exclude_unset=True)\n        if not data_to_update:\n            logger.info(f\"No fields to update for tenant_id: {tenant_id}. Returning current record.\")\n            return await get_tenant(db, tenant_id)\n\n        response = db.table(TENANTS_TABLE).update(data_to_update).eq(\"tenant_id\", str(tenant_id)).execute()\n\n        if response.data and len(response.data) > 0:\n            updated_tenant = response.data[0]\n            logger.info(f\"Tenant updated: {tenant_id}. New company name: {updated_tenant.get('company_name')}\")\n            return updated_tenant\n        else:\n            logger.warning(\n                f\"Failed to update tenant {tenant_id} (it may not exist or no data returned). \"\n                f\"Update payload: {data_to_update}. Supabase response: {response.model_dump_json() if hasattr(response, 'model_dump_json') else str(response)}\"\n            )\n            return None\n    except Exception as e:\n        logger.error(f\"Exception updating tenant {tenant_id}: {e}\", exc_info=True)\n        return None\n\nasync def delete_tenant(db: Client, tenant_id: UUID, hard_delete: bool = False) -> bool:\n    \"\"\"\n    Logically or physically deletes a tenant.\n    For logical delete, sets is_deleted = True.\n    Returns True if operation was successful (or record already in desired state for logical delete),\n    False on error or if record not found for hard delete.\n    \"\"\"\n    try:\n        if hard_delete:\n            logger.warning(f\"Performing HARD delete for tenant_id: {tenant_id}\")\n            response = db.table(TENANTS_TABLE).delete().eq(\"tenant_id\", str(tenant_id)).execute()\n            # For hard delete, success means data was returned (i.e., something was deleted)\n            if response.data and len(response.data) > 0:\n                 logger.info(f\"Tenant hard deleted: {tenant_id}\")\n                 return True\n            logger.warning(f\"Tenant {tenant_id} not found for hard delete, or no data returned from operation.\")\n            return False # Nothing was deleted\n        else: # Logical delete\n            # Check if already deleted to avoid unnecessary update and log spam\n            current_tenant = await get_tenant(db, tenant_id)\n            if current_tenant is None:\n                logger.warning(f\"Tenant {tenant_id} not found for logical delete.\")\n                return False # Not found\n            if current_tenant.get(\"is_deleted\") is True:\n                logger.info(f\"Tenant {tenant_id} is already logically deleted.\")\n                return True # Already in desired state\n\n            response = db.table(TENANTS_TABLE).update({\"is_deleted\": True}).eq(\"tenant_id\", str(tenant_id)).execute()\n            if response.data and len(response.data) > 0:\n                logger.info(f\"Tenant logically deleted: {tenant_id}\")\n                return True\n            logger.warning(f\"Failed to logically delete tenant {tenant_id} (no data returned from update).\")\n            return False # Update didn't affect any rows as expected\n\n    except Exception as e:\n        logger.error(f\"Exception during delete operation for tenant {tenant_id} (hard_delete={hard_delete}): {e}\", exc_info=True)\n        return False\n"
    },
    {
      "path": "backend/tests/test_ai_agent.py",
      "content": "# backend/tests/test_ai_agent.py\nimport pytest\nfrom unittest.mock import MagicMock, patch, ANY as AnyMockValue, call\nimport logging # For logger type hints and levels if needed by before_sleep_log\n\n# It's assumed that the following can be imported from the SUT (System Under Test)\n# This might require specific PYTHONPATH setup for the test runner.\n# For subtask execution, if these cannot be resolved, the test might rely on patching\n# at a higher level or the subtask might need to adjust paths/mocking.\ntry:\n    from backend.ai_agent import get_chat_response # The SUT\n    from backend.config import Settings # For type hinting mock_settings if needed\n    from google.adk.events import Event # Type used in ai_agent.py\nexcept ImportError as e:\n    # Fallback for subtask environment if imports fail\n    # This indicates a potential issue with how tests would run in the actual project\n    # and should ideally be resolved by proper test environment setup.\n    logging.getLogger(__name__).warning(f\"Import error in test_ai_agent.py: {e}. Using placeholders.\")\n    # Define dummy/placeholder for Event if needed for mock spec, or rely on MagicMock's flexibility\n    class Event: pass\n    # get_chat_response will be patched or tested via API if direct import fails robustly\n\n\n# Fixture to mock ai_agent.settings for controlling retry parameters in tests\n@pytest.fixture\ndef mock_ai_agent_settings(mocker):\n    # Patch the settings instance within the ai_agent module\n    mock_settings_instance = mocker.patch(\"backend.ai_agent.settings\")\n\n    mock_settings_instance.ai_agent_retry_attempts = 3\n    mock_settings_instance.ai_agent_retry_wait_initial_seconds = 0.01 # Very short for testing\n    mock_settings_instance.ai_agent_retry_wait_multiplier = 1 # No exponential backoff for faster tests\n    mock_settings_instance.ai_agent_retry_wait_max_seconds = 0.05 # Short max wait\n    return mock_settings_instance\n\n# Test cases\n@patch(\"backend.ai_agent.agent_runner\") # Mock the global agent_runner in ai_agent.py\n@patch(\"backend.ai_agent.logger\")      # Mock the logger in ai_agent.py\nasync def test_get_chat_response_success_first_try(\n    mock_logger, mock_runner, mock_ai_agent_settings # Fixture is injected\n):\n    # Ensure AGENT_INITIALIZED_SUCCESSFULLY is True for these tests\n    # This is a module-level variable in ai_agent.py\n    with patch(\"backend.ai_agent.AGENT_INITIALIZED_SUCCESSFULLY\", True):\n        mock_event = MagicMock(spec=Event)\n        mock_event.error_message = None\n        # Simulate a valid JSON response structure\n        mock_event.actions = [MagicMock(parts=[MagicMock(text='{\"message\": \"AI Success\", \"require_form_after_message\": false}')])]\n        mock_event.session_id = \"session_success_1st\" # Ensure runner's event can set this\n\n        mock_runner.run.return_value = mock_event\n\n        # Directly import and call the decorated function\n        from backend.ai_agent import get_chat_response\n        reply, session_id, require_form = await get_chat_response(\"hello\", \"session_success_1st_input\")\n\n    assert reply == \"AI Success\"\n    assert session_id == \"session_success_1st\" # Check if session_id from event is used\n    assert require_form is False\n    mock_runner.run.assert_called_once_with(request=\"hello\", session_id=\"session_success_1st_input\")\n    # Check that no retry warning logs were made\n    assert not any(\"Retrying AI Agent call\" in c[0][0] for c in mock_logger.warning.call_args_list if isinstance(c[0][0], str))\n\n\n@patch(\"backend.ai_agent.agent_runner\")\n@patch(\"backend.ai_agent.logger\")\nasync def test_get_chat_response_retry_then_success(\n    mock_logger, mock_runner, mock_ai_agent_settings\n):\n    with patch(\"backend.ai_agent.AGENT_INITIALIZED_SUCCESSFULLY\", True):\n        mock_event_success = MagicMock(spec=Event)\n        mock_event_success.error_message = None\n        mock_event_success.actions = [MagicMock(parts=[MagicMock(text='{\"message\": \"AI Retry Success\", \"require_form_after_message\": true}')])]\n        mock_event_success.session_id = \"session_retry_success\"\n\n        mock_runner.run.side_effect = [\n            RuntimeError(\"Simulated network error\"), # First call fails\n            mock_event_success                     # Second call succeeds\n        ]\n        from backend.ai_agent import get_chat_response\n        reply, session_id, require_form = await get_chat_response(\"retry please\", \"session_retry_input\")\n\n    assert reply == \"AI Retry Success\"\n    assert require_form is True\n    assert session_id == \"session_retry_success\"\n    assert mock_runner.run.call_count == 2 # Initial call + 1 retry\n    # Check if tenacity's before_sleep_log (which logs at WARNING) was called once\n    assert mock_logger.warning.call_count == 1\n    # Example check for log content if needed:\n    # mock_logger.warning.assert_any_call(AnyMockValue(containing=\"Retrying AI Agent call\"))\n\n\n@patch(\"backend.ai_agent.agent_runner\")\n@patch(\"backend.ai_agent.logger\")\nasync def test_get_chat_response_retry_all_attempts_fail(\n    mock_logger, mock_runner, mock_ai_agent_settings\n):\n    with patch(\"backend.ai_agent.AGENT_INITIALIZED_SUCCESSFULLY\", True):\n        # Make all attempts fail\n        mock_runner.run.side_effect = RuntimeError(\"Persistent failure\")\n\n        from backend.ai_agent import get_chat_response\n        reply, session_id, require_form = await get_chat_response(\"this will fail\", \"session_fail_all\")\n\n    assert \"AI Agent Error after retries\" in reply\n    assert require_form is False\n    assert session_id == \"session_fail_all\" # Original session_id should be returned on full failure\n    assert mock_runner.run.call_count == mock_ai_agent_settings.ai_agent_retry_attempts\n    # Number of sleeps (and thus before_sleep_log calls) is attempts - 1\n    assert mock_logger.warning.call_count == mock_ai_agent_settings.ai_agent_retry_attempts - 1\n    # Check for the final error log after all retries are exhausted\n    mock_logger.error.assert_called_once()\n    # More specific check for the error log content\n    args, kwargs = mock_logger.error.call_args\n    assert \"AI Agent call failed after %s attempts\" in args[0]\n    assert args[1] == mock_ai_agent_settings.ai_agent_retry_attempts\n    assert args[2] == \"session_fail_all\"\n\n\n@patch(\"backend.ai_agent.logger\") # Only logger needed for this, agent_runner not called\nasync def test_get_chat_response_agent_not_initialized_import_failed(mock_logger):\n    # Simulate ADK_IMPORTED_SUCCESSFULLY = False, AGENT_INITIALIZED_SUCCESSFULLY = False\n    with patch(\"backend.ai_agent.AGENT_INITIALIZED_SUCCESSFULLY\", False), \\\n         patch(\"backend.ai_agent.ADK_IMPORTED_SUCCESSFULLY\", False):\n        from backend.ai_agent import get_chat_response\n        reply, session_id, require_form = await get_chat_response(\"query to broken agent\", \"session_broken_1\")\n\n    assert \"AI Agent is unavailable due to missing dependencies\" in reply\n    assert require_form is False\n    # Check the debug log for fallback reason\n    # The actual log message in get_chat_response is \"Serving fallback because ADK components not imported.\"\n    # and it's logged via logger.debug, not logger.warning for this specific case.\n    # The prompt has logger.warning.assert_any_call for these, let's adjust if the code uses debug.\n    # Based on ai_agent.py: logger.debug(\"Serving fallback because ADK components not imported.\")\n    # So, this test case should check logger.debug.\n    # However, the prompt's test code uses mock_logger.warning.assert_any_call.\n    # For consistency with the prompt, I'll assume the test logic is what's desired.\n    # If the actual log level is different, this assertion would need to change.\n    # The current ai_agent.py logs these fallback reasons at DEBUG level.\n    # The test prompt specified: mock_logger.warning.assert_any_call\n    # Let's assume for the test that the logger in get_chat_response for this was changed to warning,\n    # or the test intent is to ensure *some* log indicates the fallback.\n    # For now, I will keep the test as per prompt, but this might be a discrepancy.\n    # Looking at the actual code:\n    # logger.debug(\"Serving fallback because ADK components not imported.\")\n    # logger.debug(\"Serving fallback because AI Agent failed to initialize.\")\n    # The tests should check logger.debug for these specific messages.\n    # I will adjust the test to check logger.debug as per the actual implementation.\n\n    # Corrected assertion based on actual implementation logging level\n    found_log = False\n    for call_args in mock_logger.debug.call_args_list:\n        if \"Serving fallback because ADK components not imported.\" in call_args[0][0]:\n            found_log = True\n            break\n    assert found_log, \"Expected debug log for ADK import failure not found.\"\n\n\n@patch(\"backend.ai_agent.logger\") # Only logger needed\nasync def test_get_chat_response_agent_not_initialized_init_failed(mock_logger):\n    # Simulate ADK_IMPORTED_SUCCESSFULLY = True, AGENT_INITIALIZED_SUCCESSFULLY = False\n    with patch(\"backend.ai_agent.AGENT_INITIALIZED_SUCCESSFULLY\", False), \\\n         patch(\"backend.ai_agent.ADK_IMPORTED_SUCCESSFULLY\", True):\n        from backend.ai_agent import get_chat_response\n        reply, session_id, require_form = await get_chat_response(\"query to broken agent\", \"session_broken_2\")\n\n    assert \"AI Agent is currently experiencing setup issues\" in reply\n    assert require_form is False\n    # Corrected assertion based on actual implementation logging level\n    found_log = False\n    for call_args in mock_logger.debug.call_args_list:\n        if \"Serving fallback because AI Agent failed to initialize.\" in call_args[0][0]:\n            found_log = True\n            break\n    assert found_log, \"Expected debug log for AI agent initialization failure not found.\"\n"
    },
    {
      "path": "backend/tests/test_contact_api.py",
      "content": "import pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import MagicMock, patch\nfrom datetime import datetime, timezone # Added timezone for created_at comparison\nfrom typing import Optional, Dict, Any, List\n\n# Attempt to import app and models from the correct location\n# This assumes tests are run from a context where 'backend' is a discoverable module\ntry:\n    from backend.contact_api import app\n    from backend.db import get_supabase_client # For patching\n    from backend.contact_api import ContactFormPayload # For type hints if needed, though not strictly for dicts\nexcept ImportError:\n    # Fallback for subtask execution if direct import fails\n    from contact_api import app # type: ignore\n    from db import get_supabase_client # type: ignore\n    from contact_api import ContactFormPayload # type: ignore\n\nclient = TestClient(app)\n\n# --- Helper Function for Payload ---\ndef get_valid_payload_dict(form_id: Optional[str] = \"test-form-123\") -> Dict[str, Any]:\n    return {\n        \"name\": \"Test User\",\n        \"email\": \"test@example.com\",\n        \"message\": \"This is a test message.\",\n        \"ga_client_id\": \"ga-client-id-example\",\n        \"ga_session_id\": \"ga-session-id-example\",\n        \"form_id\": form_id,\n    }\n\n# --- Test Cases ---\n\ndef test_submit_form_success_sends_ga4_event_when_configured(mocker): # Renamed\n    payload = get_valid_payload_dict() # This includes form_id and ga_client_id\n\n    mock_supabase_client = MagicMock()\n    mock_insert_response = MagicMock()\n    mock_created_at_iso = datetime.now(timezone.utc).isoformat()\n    inserted_record_data = {**payload, \"id\": 1, \"created_at\": mock_created_at_iso}\n    mock_insert_response.data = [inserted_record_data]\n    mock_supabase_client.table.return_value.insert.return_value.execute.return_value = mock_insert_response\n\n    # Mock GA4 services\n    mock_get_ga_config = mocker.patch(\"backend.contact_api.form_ga_config_service.get_ga_configuration\")\n    mock_send_ga4_event = mocker.patch(\"backend.contact_api.ga4_mp_service.send_ga4_event\")\n\n    mock_ga_config_data = {\n        \"form_id\": payload[\"form_id\"],\n        \"ga4_measurement_id\": \"G-VALIDMEASUREMENTID\",\n        \"ga4_api_secret\": \"validapisecret\"\n    }\n    mock_get_ga_config.return_value = mock_ga_config_data\n    mock_send_ga4_event.return_value = True # Simulate successful send\n\n    with patch(\"backend.contact_api.get_supabase_client\", return_value=mock_supabase_client):\n        response = client.post(\"/submit\", json=payload)\n\n    assert response.status_code == 200\n    response_data = response.json()\n    assert response_data[\"id\"] == 1\n\n    mock_supabase_client.table.return_value.insert.assert_called_once_with([payload])\n\n    # Assert GA4 mocks\n    mock_get_ga_config.assert_called_once_with(mock_supabase_client, payload[\"form_id\"])\n\n    expected_event_params = {\n        \"event_category\": \"contact_form\",\n        \"event_label\": payload[\"form_id\"],\n        \"session_id\": payload[\"ga_session_id\"]\n    }\n    mock_send_ga4_event.assert_called_once_with(\n        api_secret=mock_ga_config_data[\"ga4_api_secret\"],\n        measurement_id=mock_ga_config_data[\"ga4_measurement_id\"],\n        client_id=payload[\"ga_client_id\"],\n        events=[{\"name\": \"generate_lead\", \"params\": expected_event_params}]\n    )\n\ndef test_submit_form_success_minimal_fields_skips_ga4_event(mocker): # Updated name and assertions\n    minimal_payload = {\n        \"name\": \"Minimal User\",\n        \"email\": \"minimal@example.com\",\n        \"message\": \"Minimal message.\",\n    }\n    # form_id, ga_client_id, ga_session_id are omitted, will default to None\n\n    mock_supabase_client = MagicMock()\n    mock_insert_response = MagicMock()\n    mock_created_at_iso = datetime.now(timezone.utc).isoformat()\n    data_as_inserted = {\n        \"name\": \"Minimal User\", \"email\": \"minimal@example.com\", \"message\": \"Minimal message.\",\n        \"ga_client_id\": None, \"ga_session_id\": None, \"form_id\": None\n    }\n    inserted_record_data = {**data_as_inserted, \"id\": 2, \"created_at\": mock_created_at_iso}\n    mock_insert_response.data = [inserted_record_data]\n    mock_supabase_client.table.return_value.insert.return_value.execute.return_value = mock_insert_response\n\n    # Mock GA4 services to ensure they are NOT called\n    mock_get_ga_config = mocker.patch(\"backend.contact_api.form_ga_config_service.get_ga_configuration\")\n    mock_send_ga4_event = mocker.patch(\"backend.contact_api.ga4_mp_service.send_ga4_event\")\n\n    with patch(\"backend.contact_api.get_supabase_client\", return_value=mock_supabase_client):\n        response = client.post(\"/submit\", json=minimal_payload)\n\n    assert response.status_code == 200\n    response_data = response.json()\n    assert response_data[\"name\"] == \"Minimal User\"\n    assert response_data[\"id\"] == 2\n    assert response_data[\"form_id\"] is None\n    assert response_data[\"ga_client_id\"] is None\n\n    mock_supabase_client.table.return_value.insert.assert_called_once_with([data_as_inserted])\n\n    # Assert GA4 mocks were NOT called\n    mock_get_ga_config.assert_not_called()\n    mock_send_ga4_event.assert_not_called()\n\n\ndef test_submit_form_success_ga4_config_not_found_skips_event(mocker):\n    payload = get_valid_payload_dict() # This includes form_id and ga_client_id\n\n    mock_supabase_client = MagicMock()\n    mock_insert_response = MagicMock()\n    mock_created_at_iso = datetime.now(timezone.utc).isoformat()\n    inserted_record_data = {**payload, \"id\": 3, \"created_at\": mock_created_at_iso}\n    mock_insert_response.data = [inserted_record_data]\n    mock_supabase_client.table.return_value.insert.return_value.execute.return_value = mock_insert_response\n\n    # Mock GA4 services\n    mock_get_ga_config = mocker.patch(\"backend.contact_api.form_ga_config_service.get_ga_configuration\")\n    mock_send_ga4_event = mocker.patch(\"backend.contact_api.ga4_mp_service.send_ga4_event\")\n\n    mock_get_ga_config.return_value = None # Simulate GA4 config not found\n\n    with patch(\"backend.contact_api.get_supabase_client\", return_value=mock_supabase_client):\n        response = client.post(\"/submit\", json=payload)\n\n    assert response.status_code == 200\n    assert response.json()[\"id\"] == 3\n\n    mock_get_ga_config.assert_called_once_with(mock_supabase_client, payload[\"form_id\"])\n    mock_send_ga4_event.assert_not_called()\n\n\ndef test_submit_form_supabase_client_unavailable(mocker):\n    with patch(\"backend.contact_api.get_supabase_client\", return_value=None):\n        response = client.post(\"/submit\", json=get_valid_payload_dict())\n\n    assert response.status_code == 503\n    assert response.json() == {\"detail\": \"Database service is currently unavailable. Please try again later.\"}\n\ndef test_submit_form_supabase_insert_api_error(mocker): # Renamed for clarity (APIError from Supabase)\n    mock_supabase_client = MagicMock()\n    # Simulate an error from Supabase client, e.g., PostgrestAPIError\n    # For simplicity, just making execute raise a generic Exception here.\n    # A more specific Supabase exception could be mocked if needed.\n    mock_supabase_client.table.return_value.insert.return_value.execute.side_effect = Exception(\"Supabase DB error\")\n\n    with patch(\"backend.contact_api.get_supabase_client\", return_value=mock_supabase_client):\n        response = client.post(\"/submit\", json=get_valid_payload_dict())\n\n    assert response.status_code == 500\n    # The detail message in endpoint is generic for non-HTTPExceptions\n    assert response.json() == {\"detail\": \"An error occurred while processing your request.\"}\n\n\ndef test_submit_form_supabase_insert_returns_no_data(mocker):\n    mock_supabase_client = MagicMock()\n    mock_empty_response = MagicMock()\n    mock_empty_response.data = [] # Supabase returns empty data list\n    mock_supabase_client.table.return_value.insert.return_value.execute.return_value = mock_empty_response\n\n    with patch(\"backend.contact_api.get_supabase_client\", return_value=mock_supabase_client):\n        response = client.post(\"/submit\", json=get_valid_payload_dict())\n\n    assert response.status_code == 500\n    assert response.json() == {\"detail\": \"Failed to save submission: No data returned from database operation.\"}\n\ndef test_submit_form_missing_required_field_name(client): # More specific test name\n    # 'name' is a required field in ContactFormPayload\n    invalid_payload_missing_name = {\n        \"email\": \"invalid@example.com\",\n        \"message\": \"Message for submission missing name.\",\n        \"form_id\": \"form-no-name\"\n    }\n    response = client.post(\"/submit\", json=invalid_payload_missing_name)\n    assert response.status_code == 422 # FastAPI validation error\n    response_data = response.json()\n    assert \"detail\" in response_data\n    # Check if 'name' field is reported as missing\n    field_error_found = False\n    for error in response_data[\"detail\"]:\n        if error.get(\"type\") == \"missing\" and \"name\" in error.get(\"loc\", []):\n            field_error_found = True\n            break\n    assert field_error_found, \"Error detail for missing 'name' field not found.\"\n"
    },
    {
      "path": "backend/tests/test_form_ga_config_api.py",
      "content": "import pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import MagicMock, patch\nfrom datetime import datetime, timezone\nfrom typing import List, Dict, Any, Optional\n\n# Attempt to import app and other necessary components\ntry:\n    from backend.contact_api import app\n    # For patching, we need the actual path to the dependency used in the router\n    # from backend.db import get_supabase_client # Not directly used if router import is patched\n    # from backend.contact_api import get_current_active_user # Same as above\nexcept ImportError:\n    from contact_api import app # type: ignore\n\n\nclient = TestClient(app)\n\n# --- Mock Data & Helpers ---\nBASE_PATH = \"/api/v1/ga_configurations\"\nTEST_FORM_ID = \"test-form-for-ga\"\nMOCK_USER = {\"username\": \"testuser\"}\n\ndef mock_ga_config_payload_dict(form_id_override: Optional[str] = None) -> Dict[str, Any]:\n    return {\n        \"form_id\": form_id_override or TEST_FORM_ID,\n        \"ga4_measurement_id\": \"G-TEST12345\",\n        \"ga4_api_secret\": \"test_api_secret_value\",\n        \"description\": \"Test GA4 Configuration\"\n    }\n\ndef mock_db_record_dict(payload: Dict[str, Any]) -> Dict[str, Any]:\n    now_iso = datetime.now(timezone.utc).isoformat()\n    return {\n        **payload,\n        \"created_at\": now_iso,\n        \"updated_at\": now_iso\n    }\n\n# --- Test Cases ---\n\n@patch(\"backend.routers.form_ga_config_router.get_current_active_user\", return_value=MOCK_USER)\n@patch(\"backend.routers.form_ga_config_router.get_supabase_client\")\n@patch(\"backend.services.form_ga_config_service.create_ga_configuration\")\n@patch(\"backend.services.form_ga_config_service.get_ga_configuration\") # For pre-check\ndef test_create_ga_configuration_success(mock_get_config, mock_create_config, mock_get_supabase, mock_auth, client):\n    payload = mock_ga_config_payload_dict()\n\n    mock_get_supabase.return_value = MagicMock() # Simulate available Supabase client\n    mock_get_config.return_value = None # Simulate no existing config\n    mock_create_config.return_value = mock_db_record_dict(payload)\n\n    response = client.post(BASE_PATH, json=payload)\n\n    assert response.status_code == 201\n    response_data = response.json()\n    assert response_data[\"form_id\"] == TEST_FORM_ID\n    assert response_data[\"ga4_measurement_id\"] == \"G-TEST12345\"\n    mock_create_config.assert_called_once()\n\n@patch(\"backend.routers.form_ga_config_router.get_current_active_user\", return_value=MOCK_USER)\n@patch(\"backend.routers.form_ga_config_router.get_supabase_client\")\n@patch(\"backend.services.form_ga_config_service.get_ga_configuration\")\ndef test_create_ga_configuration_already_exists(mock_get_config, mock_get_supabase, mock_auth, client):\n    payload = mock_ga_config_payload_dict()\n    mock_get_supabase.return_value = MagicMock()\n    mock_get_config.return_value = mock_db_record_dict(payload) # Simulate existing config\n\n    response = client.post(BASE_PATH, json=payload)\n\n    assert response.status_code == 409\n\n@patch(\"backend.routers.form_ga_config_router.get_current_active_user\", return_value=MOCK_USER)\n@patch(\"backend.routers.form_ga_config_router.get_supabase_client\")\n@patch(\"backend.services.form_ga_config_service.get_ga_configuration\")\ndef test_get_ga_configuration_success(mock_get_config, mock_get_supabase, mock_auth, client):\n    db_record = mock_db_record_dict(mock_ga_config_payload_dict())\n    mock_get_supabase.return_value = MagicMock()\n    mock_get_config.return_value = db_record\n\n    response = client.get(f\"{BASE_PATH}/{TEST_FORM_ID}\")\n\n    assert response.status_code == 200\n    response_data = response.json()\n    assert response_data[\"form_id\"] == TEST_FORM_ID\n    assert response_data[\"ga4_measurement_id\"] == db_record[\"ga4_measurement_id\"]\n\n@patch(\"backend.routers.form_ga_config_router.get_current_active_user\", return_value=MOCK_USER)\n@patch(\"backend.routers.form_ga_config_router.get_supabase_client\")\n@patch(\"backend.services.form_ga_config_service.get_ga_configuration\")\ndef test_get_ga_configuration_not_found(mock_get_config, mock_get_supabase, mock_auth, client):\n    mock_get_supabase.return_value = MagicMock()\n    mock_get_config.return_value = None # Simulate not found\n\n    response = client.get(f\"{BASE_PATH}/{TEST_FORM_ID}\")\n\n    assert response.status_code == 404\n\n@patch(\"backend.routers.form_ga_config_router.get_current_active_user\", return_value=MOCK_USER)\n@patch(\"backend.routers.form_ga_config_router.get_supabase_client\")\n@patch(\"backend.services.form_ga_config_service.list_ga_configurations\")\ndef test_list_ga_configurations_success(mock_list_configs, mock_get_supabase, mock_auth, client):\n    mock_get_supabase.return_value = MagicMock()\n    payload1 = mock_ga_config_payload_dict(form_id_override=\"form1\")\n    payload2 = mock_ga_config_payload_dict(form_id_override=\"form2\")\n    db_records = [mock_db_record_dict(payload1), mock_db_record_dict(payload2)]\n    mock_list_configs.return_value = db_records\n\n    response = client.get(BASE_PATH)\n\n    assert response.status_code == 200\n    response_data = response.json()\n    assert len(response_data[\"configurations\"]) == 2\n    assert response_data[\"configurations\"][0][\"form_id\"] == \"form1\"\n\n@patch(\"backend.routers.form_ga_config_router.get_current_active_user\", return_value=MOCK_USER)\n@patch(\"backend.routers.form_ga_config_router.get_supabase_client\")\n@patch(\"backend.services.form_ga_config_service.update_ga_configuration\")\ndef test_update_ga_configuration_success(mock_update_config, mock_get_supabase, mock_auth, client):\n    update_payload = {\"description\": \"Updated Test Description\"}\n    # Original payload for context, though service mock determines outcome\n    original_payload = mock_ga_config_payload_dict()\n    updated_db_record = mock_db_record_dict({**original_payload, **update_payload})\n\n    mock_get_supabase.return_value = MagicMock()\n    mock_update_config.return_value = updated_db_record\n\n    response = client.put(f\"{BASE_PATH}/{TEST_FORM_ID}\", json=update_payload)\n\n    assert response.status_code == 200\n    response_data = response.json()\n    assert response_data[\"description\"] == \"Updated Test Description\"\n    assert response_data[\"form_id\"] == TEST_FORM_ID\n    mock_update_config.assert_called_once()\n\n@patch(\"backend.routers.form_ga_config_router.get_current_active_user\", return_value=MOCK_USER)\n@patch(\"backend.routers.form_ga_config_router.get_supabase_client\")\n@patch(\"backend.services.form_ga_config_service.update_ga_configuration\")\ndef test_update_ga_configuration_not_found(mock_update_config, mock_get_supabase, mock_auth, client):\n    update_payload = {\"description\": \"NonExistent Update\"}\n    mock_get_supabase.return_value = MagicMock()\n    mock_update_config.return_value = None # Simulate not found by service\n\n    response = client.put(f\"{BASE_PATH}/{TEST_FORM_ID}\", json=update_payload)\n\n    assert response.status_code == 404\n\n@patch(\"backend.routers.form_ga_config_router.get_current_active_user\", return_value=MOCK_USER)\n@patch(\"backend.routers.form_ga_config_router.get_supabase_client\")\n@patch(\"backend.services.form_ga_config_service.delete_ga_configuration\")\ndef test_delete_ga_configuration_success(mock_delete_config, mock_get_supabase, mock_auth, client):\n    mock_get_supabase.return_value = MagicMock()\n    mock_delete_config.return_value = True # Simulate successful deletion\n\n    response = client.delete(f\"{BASE_PATH}/{TEST_FORM_ID}\")\n\n    assert response.status_code == 204\n\n@patch(\"backend.routers.form_ga_config_router.get_current_active_user\", return_value=MOCK_USER)\n@patch(\"backend.routers.form_ga_config_router.get_supabase_client\")\n@patch(\"backend.services.form_ga_config_service.delete_ga_configuration\")\ndef test_delete_ga_configuration_not_found(mock_delete_config, mock_get_supabase, mock_auth, client):\n    mock_get_supabase.return_value = MagicMock()\n    mock_delete_config.return_value = False # Simulate record not found or delete failed\n\n    response = client.delete(f\"{BASE_PATH}/{TEST_FORM_ID}\")\n\n    assert response.status_code == 404\n\n# It's important that the patch paths like \"backend.routers.form_ga_config_router.get_supabase_client\"\n# correctly point to where these names are looked up *within the context of the router file*.\n# If get_supabase_client is imported as `from backend.db import get_supabase_client` in the router,\n# then the patch path should be \"backend.routers.form_ga_config_router.get_supabase_client\" if that's how it's referenced,\n# or \"backend.db.get_supabase_client\" if you want to patch it at its source (which affects all uses).\n# Patching where it's *used* (in the router) is often more targeted for testing the router's logic.\n# The current patching style uses decorators, which apply to the whole function.\n# `client` is assumed to be a TestClient instance provided by pytest (e.g. via fixture or global).\n"
    },
    {
      "path": "backend/tests/test_submission_api.py",
      "content": "# backend/tests/test_submission_api.py\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import MagicMock, patch, ANY as AnyMockValue\nfrom datetime import datetime, timezone, date # Ensure date is imported\nfrom typing import Optional, Dict, Any, List\n\n# Attempt to import app and other necessary components\ntry:\n    from backend.contact_api import app\n    # For patching, paths are relative to where they are called in the router/service\nexcept ImportError:\n    from contact_api import app # type: ignore\n\nclient = TestClient(app)\n\n# --- Mock Data & Helpers ---\nSUBMISSIONS_API_BASE_PATH = \"/api/v1/submissions\" # Renamed for clarity\nTEST_SUBMISSION_ID = 123\nMOCK_AUTH_USER = {\"username\": \"test_submission_user\"}\n\ndef helper_mock_submission_dict(\n    submission_id: int = TEST_SUBMISSION_ID,\n    form_id: str = \"form-xyz\",\n    ga_client_id: Optional[str] = \"client-id-123\",\n    ga_session_id: Optional[str] = \"session-id-456\",\n    current_status: str = \"new\",\n    reason: Optional[str] = None\n) -> Dict[str, Any]:\n    return {\n        \"id\": submission_id,\n        \"name\": \"Original Test Name\",\n        \"email\": \"test.user@example.com\",\n        \"message\": \"This is an original test message.\",\n        \"ga_client_id\": ga_client_id,\n        \"ga_session_id\": ga_session_id,\n        \"form_id\": form_id,\n        \"submission_status\": current_status,\n        \"status_change_reason\": reason,\n        \"created_at\": datetime(2023, 1, 10, 10, 0, 0, tzinfo=timezone.utc).isoformat(),\n        \"updated_at\": datetime(2023, 1, 10, 11, 0, 0, tzinfo=timezone.utc).isoformat(),\n    }\n\ndef helper_mock_ga_config_dict(form_id: str = \"form-xyz\") -> Dict[str, Any]:\n    return {\n        \"form_id\": form_id,\n        \"ga4_measurement_id\": \"G-GA4VALIDID\",\n        \"ga4_api_secret\": \"valid_secret_for_ga4\",\n        \"description\": \"GA Config for \" + form_id,\n        \"created_at\": datetime(2023, 1, 1, 0, 0, 0, tzinfo=timezone.utc).isoformat(),\n        \"updated_at\": datetime(2023, 1, 1, 0, 0, 0, tzinfo=timezone.utc).isoformat(),\n    }\n\n# --- Test Cases for PATCH /api/v1/submissions/{submission_id}/status ---\n\n@patch(\"backend.routers.submission_router.get_current_active_user\", return_value=MOCK_AUTH_USER)\n@patch(\"backend.routers.submission_router.get_supabase_client\")\n@patch(\"backend.services.submission_service.update_submission_status\")\n@patch(\"backend.services.form_ga_config_service.get_ga_configuration\")\n@patch(\"backend.services.ga4_mp_service.send_ga4_event\")\ndef test_update_status_success_sends_ga4_event_for_converted(\n    mock_send_ga4_event, mock_get_ga_config, mock_update_status_svc, mock_get_supabase, mock_auth, client\n):\n    new_status = \"converted\"\n    payload = {\"new_status\": new_status, \"reason\": \"Customer purchased product X.\"}\n\n    mock_supabase_instance = MagicMock(name=\"supabase_mock\")\n    mock_get_supabase.return_value = mock_supabase_instance\n\n    current_submission = helper_mock_submission_dict(current_status=\"qualified\")\n    # Mock the initial fetch of the submission within the endpoint\n    mock_supabase_instance.table.return_value.select.return_value.eq.return_value.single.return_value.execute.return_value = MagicMock(data=current_submission)\n\n    updated_submission_from_service = {**current_submission, \"submission_status\": new_status, \"status_change_reason\": payload[\"reason\"]}\n    mock_update_status_svc.return_value = updated_submission_from_service\n\n    mock_get_ga_config.return_value = helper_mock_ga_config_dict(form_id=current_submission[\"form_id\"])\n    mock_send_ga4_event.return_value = True # Simulate GA4 send success\n\n    response = client.patch(f\"{SUBMISSIONS_API_BASE_PATH}/{TEST_SUBMISSION_ID}/status\", json=payload)\n\n    assert response.status_code == 200\n    resp_data = response.json()\n    assert resp_data[\"submission_status\"] == new_status\n    assert resp_data[\"status_change_reason\"] == payload[\"reason\"]\n\n    mock_update_status_svc.assert_called_once_with(\n        db=mock_supabase_instance, submission_id=TEST_SUBMISSION_ID, new_status=new_status, reason=payload[\"reason\"]\n    )\n    mock_get_ga_config.assert_called_once_with(mock_supabase_instance, current_submission[\"form_id\"])\n\n    expected_ga4_event_name = \"close_convert_lead\"\n    expected_ga4_params = {\n        \"form_id\": current_submission[\"form_id\"],\n        \"session_id\": current_submission[\"ga_session_id\"],\n        \"transaction_id\": str(TEST_SUBMISSION_ID)\n    }\n    mock_send_ga4_event.assert_called_once_with(\n        api_secret=helper_mock_ga_config_dict()[\"ga4_api_secret\"],\n        measurement_id=helper_mock_ga_config_dict()[\"ga4_measurement_id\"],\n        client_id=current_submission[\"ga_client_id\"],\n        events=[{\"name\": expected_ga4_event_name, \"params\": expected_ga4_params}]\n    )\n\n@patch(\"backend.routers.submission_router.get_current_active_user\", return_value=MOCK_AUTH_USER)\n@patch(\"backend.routers.submission_router.get_supabase_client\")\n@patch(\"backend.services.submission_service.update_submission_status\")\n@patch(\"backend.services.ga4_mp_service.send_ga4_event\") # No need to mock get_ga_config if event not sent\ndef test_update_status_success_no_ga4_event_if_status_not_mapped(\n    mock_send_ga4_event, mock_update_status_svc, mock_get_supabase, mock_auth, client\n):\n    new_status = \"new\" # 'new' is not in STATUS_TO_GA4_EVENT_MAP for sending event post-update\n    payload = {\"new_status\": new_status}\n\n    mock_supabase_instance = MagicMock()\n    mock_get_supabase.return_value = mock_supabase_instance\n\n    current_submission = helper_mock_submission_dict(current_status=\"spam\")\n    mock_supabase_instance.table.return_value.select.return_value.eq.return_value.single.return_value.execute.return_value = MagicMock(data=current_submission)\n\n    updated_submission_from_service = {**current_submission, \"submission_status\": new_status}\n    mock_update_status_svc.return_value = updated_submission_from_service\n\n    response = client.patch(f\"{SUBMISSIONS_API_BASE_PATH}/{TEST_SUBMISSION_ID}/status\", json=payload)\n\n    assert response.status_code == 200\n    assert response.json()[\"submission_status\"] == new_status\n    mock_send_ga4_event.assert_not_called()\n\n\n@patch(\"backend.routers.submission_router.get_current_active_user\", return_value=MOCK_AUTH_USER)\n@patch(\"backend.routers.submission_router.get_supabase_client\")\ndef test_update_status_submission_fetch_fails_404(mock_get_supabase, mock_auth, client):\n    payload = {\"new_status\": \"contacted\"}\n    mock_supabase_instance = MagicMock()\n    mock_get_supabase.return_value = mock_supabase_instance\n\n    # Simulate submission not found by initial fetch in router\n    mock_supabase_instance.table.return_value.select.return_value.eq.return_value.single.return_value.execute.return_value = MagicMock(data=None)\n\n    response = client.patch(f\"{SUBMISSIONS_API_BASE_PATH}/{TEST_SUBMISSION_ID}/status\", json=payload)\n    assert response.status_code == 404\n\n\n@patch(\"backend.routers.submission_router.get_current_active_user\", return_value=MOCK_AUTH_USER)\n@patch(\"backend.routers.submission_router.get_supabase_client\")\n@patch(\"backend.services.submission_service.update_submission_status\")\ndef test_update_status_service_layer_fails_update(mock_update_status_svc, mock_get_supabase, mock_auth, client):\n    payload = {\"new_status\": \"contacted\"}\n    mock_supabase_instance = MagicMock()\n    mock_get_supabase.return_value = mock_supabase_instance\n\n    current_submission = helper_mock_submission_dict()\n    mock_supabase_instance.table.return_value.select.return_value.eq.return_value.single.return_value.execute.return_value = MagicMock(data=current_submission)\n\n    mock_update_status_svc.return_value = None # Simulate service layer failing the update\n\n    response = client.patch(f\"{SUBMISSIONS_API_BASE_PATH}/{TEST_SUBMISSION_ID}/status\", json=payload)\n    assert response.status_code == 404 # Changed from 500, as service returning None often means \"not found\" or \"no action\"\n\n@patch(\"backend.routers.submission_router.get_current_active_user\", return_value=MOCK_AUTH_USER)\n@patch(\"backend.routers.submission_router.get_supabase_client\")\n@patch(\"backend.services.form_ga_config_service.get_ga_configuration\")\n@patch(\"backend.services.submission_service.update_submission_status\")\n@patch(\"backend.services.ga4_mp_service.send_ga4_event\")\ndef test_update_status_ga4_config_not_found_skips_ga_event(\n    mock_send_ga4_event, mock_update_status_svc, mock_get_ga_config, mock_get_supabase, mock_auth, client\n):\n    new_status = \"converted\"\n    payload = {\"new_status\": new_status}\n\n    mock_supabase_instance = MagicMock()\n    mock_get_supabase.return_value = mock_supabase_instance\n\n    current_submission = helper_mock_submission_dict(current_status=\"qualified\")\n    mock_supabase_instance.table.return_value.select.return_value.eq.return_value.single.return_value.execute.return_value = MagicMock(data=current_submission)\n\n    updated_submission_from_service = {**current_submission, \"submission_status\": new_status}\n    mock_update_status_svc.return_value = updated_submission_from_service\n\n    mock_get_ga_config.return_value = None # Simulate GA4 config not found for the form_id\n\n    response = client.patch(f\"{SUBMISSIONS_API_BASE_PATH}/{TEST_SUBMISSION_ID}/status\", json=payload)\n\n    assert response.status_code == 200\n    assert response.json()[\"submission_status\"] == new_status\n    mock_send_ga4_event.assert_not_called() # GA4 event should not be sent\n    mock_get_ga_config.assert_called_once_with(mock_supabase_instance, current_submission[\"form_id\"])\n\n# --- Test Cases for GET /api/v1/submissions ---\n\n@patch(\"backend.routers.submission_router.get_current_active_user\", return_value=MOCK_AUTH_USER)\n@patch(\"backend.routers.submission_router.get_supabase_client\")\n@patch(\"backend.services.submission_service.list_submissions\")\ndef test_list_submissions_success_no_filters(mock_list_svc, mock_get_supabase_dep, mock_auth_dep, client): # Renamed mock args\n    mock_supabase_instance = MagicMock(name=\"supabase_mock_list_no_filter\")\n    mock_get_supabase_dep.return_value = mock_supabase_instance\n\n    mock_data = [\n        helper_mock_submission_dict(submission_id=101, form_id=\"formA\"),\n        helper_mock_submission_dict(submission_id=102, form_id=\"formB\"),\n    ]\n    mock_total = 50 # Example total count larger than returned items for pagination\n    mock_list_svc.return_value = (mock_data, mock_total)\n\n    response = client.get(f\"{SUBMISSIONS_API_BASE_PATH}/\") # Ensure trailing slash for query params\n\n    assert response.status_code == 200\n    json_response = response.json()\n    assert len(json_response[\"submissions\"]) == 2\n    assert json_response[\"total_count\"] == mock_total\n    assert json_response[\"skip\"] == 0 # Default skip\n    assert json_response[\"limit\"] == 20 # Default limit\n    assert json_response[\"submissions\"][0][\"id\"] == 101\n\n    mock_list_svc.assert_called_once_with(\n        db=mock_supabase_instance,\n        skip=0, limit=20,\n        form_id=None, submission_status=None, email=None, name=None,\n        start_date=None, end_date=None,\n        sort_by=\"created_at\", sort_order=\"desc\" # Default sort params\n    )\n\n@patch(\"backend.routers.submission_router.get_current_active_user\", return_value=MOCK_AUTH_USER)\n@patch(\"backend.routers.submission_router.get_supabase_client\")\n@patch(\"backend.services.submission_service.list_submissions\")\ndef test_list_submissions_with_all_filters_pagination_sorting(mock_list_svc, mock_get_supabase_dep, mock_auth_dep, client):\n    mock_supabase_instance = MagicMock(name=\"supabase_mock_list_filters\")\n    mock_get_supabase_dep.return_value = mock_supabase_instance\n\n    mock_data = [helper_mock_submission_dict(submission_id=201, form_id=\"form-filter\")]\n    mock_total = 1\n    mock_list_svc.return_value = (mock_data, mock_total)\n\n    params = {\n        \"form_id\": \"form-filter\", \"submission_status\": \"converted\",\n        \"email\": \"filter@example.com\", \"name\": \"Filter User\",\n        \"start_date\": \"2024-01-01\", \"end_date\": \"2024-01-31\",\n        \"skip\": 10, \"limit\": 5,\n        \"sort_by\": \"name\", \"sort_order\": \"asc\"\n    }\n    response = client.get(f\"{SUBMISSIONS_API_BASE_PATH}/\", params=params)\n\n    assert response.status_code == 200\n    json_response = response.json()\n    assert len(json_response[\"submissions\"]) == 1\n    assert json_response[\"total_count\"] == mock_total\n    assert json_response[\"skip\"] == 10\n    assert json_response[\"limit\"] == 5\n    assert json_response[\"submissions\"][0][\"id\"] == 201\n\n    # FastAPI Query converts date strings to date objects\n    # from datetime import date as date_type # For type checking in assert (already imported at top)\n    mock_list_svc.assert_called_once_with(\n        db=mock_supabase_instance,\n        skip=10, limit=5,\n        form_id=\"form-filter\", submission_status=\"converted\",\n        email=\"filter@example.com\", name=\"Filter User\",\n        start_date=date(2024,1,1), end_date=date(2024,1,31),\n        sort_by=\"name\", sort_order=\"asc\"\n    )\n\n@patch(\"backend.routers.submission_router.get_current_active_user\", return_value=MOCK_AUTH_USER)\n@patch(\"backend.routers.submission_router.get_supabase_client\")\n@patch(\"backend.services.submission_service.list_submissions\")\ndef test_list_submissions_empty_result_from_service(mock_list_svc, mock_get_supabase_dep, mock_auth_dep, client):\n    mock_supabase_instance = MagicMock(name=\"supabase_mock_list_empty\")\n    mock_get_supabase_dep.return_value = mock_supabase_instance\n    mock_list_svc.return_value = ([], 0) # Service returns empty list and 0 total\n\n    response = client.get(f\"{SUBMISSIONS_API_BASE_PATH}/\")\n    assert response.status_code == 200\n    json_response = response.json()\n    assert len(json_response[\"submissions\"]) == 0\n    assert json_response[\"total_count\"] == 0\n\n@patch(\"backend.routers.submission_router.get_current_active_user\", return_value=MOCK_AUTH_USER)\n@patch(\"backend.routers.submission_router.get_supabase_client\")\ndef test_list_submissions_supabase_client_is_none(mock_get_supabase_dep, mock_auth_dep, client):\n    mock_get_supabase_dep.return_value = None # Simulate Supabase client not available\n\n    response = client.get(f\"{SUBMISSIONS_API_BASE_PATH}/\")\n    assert response.status_code == 503\n    assert response.json()[\"detail\"] == \"Supabase client unavailable\" # Match error detail\n\n@patch(\"backend.routers.submission_router.get_current_active_user\", return_value=MOCK_AUTH_USER)\n@patch(\"backend.routers.submission_router.get_supabase_client\")\n@patch(\"backend.services.submission_service.list_submissions\")\ndef test_list_submissions_service_raises_exception(mock_list_svc, mock_get_supabase_dep, mock_auth_dep, client):\n    mock_supabase_instance = MagicMock(name=\"supabase_mock_list_svc_error\")\n    mock_get_supabase_dep.return_value = mock_supabase_instance\n    mock_list_svc.side_effect = Exception(\"Simulated service error\")\n\n    response = client.get(f\"{SUBMISSIONS_API_BASE_PATH}/\")\n    assert response.status_code == 500\n    assert response.json()[\"detail\"] == \"Failed to list submissions.\"\n"
    },
    {
      "path": "backend/tests/test_tenant_api.py",
      "content": "# backend/tests/test_tenant_api.py\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import MagicMock, patch, ANY as AnyMockValue\nfrom uuid import uuid4, UUID # Import UUID for type checks\nfrom datetime import datetime, timezone\nfrom typing import List, Dict, Any, Optional\n\ntry:\n    from backend.contact_api import app\n    from backend.auth import AuthenticatedUser # For mocking user\nexcept ImportError:\n    from contact_api import app # type: ignore\n    # Define dummy AuthenticatedUser if needed for subtask environment\n    class AuthenticatedUser:\n        def __init__(self, id: str, app_role: str, tenant_id: Optional[str] = None, email: Optional[str] = None, full_name: Optional[str] = None):\n            self.id = id\n            self.app_role = app_role\n            self.tenant_id = tenant_id\n            self.email = email\n            self.full_name = full_name\n\n\nclient = TestClient(app)\n\n# --- Mock Data & Helpers ---\nTENANTS_API_BASE_PATH = \"/api/v1/tenants\"\nMOCK_SUPERUSER = AuthenticatedUser(id=\"super-user-id\", app_role=\"superuser\", tenant_id=None)\nMOCK_NON_SUPERUSER = AuthenticatedUser(id=\"normal-user-id\", app_role=\"user\", tenant_id=str(uuid4()))\n\ndef helper_mock_tenant_payload_dict(company_name: str = \"Test Tenant Inc.\", domain: Optional[str] = \"test-tenant.com\") -> Dict[str, Any]:\n    return {\"company_name\": company_name, \"domain\": domain}\n\ndef helper_mock_tenant_db_record_dict(\n    tenant_id: Optional[UUID] = None, # Allow passing None for creation where DB generates it\n    company_name: str = \"Test Tenant Inc.\",\n    domain: Optional[str] = \"test-tenant.com\",\n    is_deleted: bool = False\n) -> Dict[str, Any]:\n    return {\n        \"tenant_id\": str(tenant_id if tenant_id else uuid4()), # Convert UUID to str for JSON comparison\n        \"company_name\": company_name,\n        \"domain\": domain,\n        \"is_deleted\": is_deleted,\n        \"created_at\": datetime.now(timezone.utc).isoformat(),\n        \"updated_at\": datetime.now(timezone.utc).isoformat(),\n    }\n\n# --- Test Cases ---\n\n# CREATE Tenant\n@patch(\"backend.routers.tenant_router.get_current_active_user\", return_value=MOCK_SUPERUSER)\n@patch(\"backend.routers.tenant_router.get_supabase_client\")\n@patch(\"backend.services.tenant_service.create_tenant\")\ndef test_create_tenant_success_as_superuser(mock_create_svc, mock_get_supabase, mock_auth, client):\n    payload = helper_mock_tenant_payload_dict()\n    mock_supabase_instance = MagicMock()\n    mock_get_supabase.return_value = mock_supabase_instance\n\n    # create_tenant service returns a dict representing the DB record\n    db_record = helper_mock_tenant_db_record_dict(**payload) # Pass payload fields\n    mock_create_svc.return_value = db_record\n\n    response = client.post(TENANTS_API_BASE_PATH, json=payload)\n\n    assert response.status_code == 201\n    resp_data = response.json()\n    assert resp_data[\"company_name\"] == payload[\"company_name\"]\n    assert resp_data[\"domain\"] == payload[\"domain\"]\n    assert resp_data[\"is_deleted\"] is False # Default\n    assert \"tenant_id\" in resp_data\n    mock_create_svc.assert_called_once()\n    # Check payload passed to service (Pydantic model in service, dict here is fine if fields match)\n    # The service receives TenantCreatePayload, so its .model_dump() would be passed.\n    # For simplicity, checking if called is often enough if payload structure is simple.\n\n@patch(\"backend.routers.tenant_router.get_current_active_user\", return_value=MOCK_NON_SUPERUSER)\ndef test_create_tenant_fail_as_non_superuser(mock_auth, client):\n    payload = helper_mock_tenant_payload_dict()\n    response = client.post(TENANTS_API_BASE_PATH, json=payload)\n    assert response.status_code == 403\n\n# GET Tenant List\n@patch(\"backend.routers.tenant_router.get_current_active_user\", return_value=MOCK_SUPERUSER)\n@patch(\"backend.routers.tenant_router.get_supabase_client\")\n@patch(\"backend.services.tenant_service.list_tenants\")\ndef test_list_tenants_success_as_superuser(mock_list_svc, mock_get_supabase, mock_auth, client):\n    mock_supabase_instance = MagicMock()\n    mock_get_supabase.return_value = mock_supabase_instance\n\n    mock_tenants_data = [\n        helper_mock_tenant_db_record_dict(company_name=\"Tenant A\"),\n        helper_mock_tenant_db_record_dict(company_name=\"Tenant B\", is_deleted=True)\n    ]\n    mock_total = 2\n    mock_list_svc.return_value = (mock_tenants_data, mock_total)\n\n    response = client.get(TENANTS_API_BASE_PATH, params={\"show_deleted\": True, \"skip\": 0, \"limit\": 10})\n\n    assert response.status_code == 200\n    resp_data = response.json()\n    assert len(resp_data[\"tenants\"]) == 2\n    assert resp_data[\"total_count\"] == mock_total\n    assert resp_data[\"tenants\"][0][\"company_name\"] == \"Tenant A\"\n    mock_list_svc.assert_called_once_with(mock_supabase_instance, 0, 10, True)\n\n# GET Single Tenant\n@patch(\"backend.routers.tenant_router.get_current_active_user\", return_value=MOCK_SUPERUSER)\n@patch(\"backend.routers.tenant_router.get_supabase_client\")\n@patch(\"backend.services.tenant_service.get_tenant\")\ndef test_get_tenant_success_as_superuser(mock_get_svc, mock_get_supabase, mock_auth, client):\n    tenant_id = uuid4()\n    db_record = helper_mock_tenant_db_record_dict(tenant_id=tenant_id)\n    mock_supabase_instance = MagicMock()\n    mock_get_supabase.return_value = mock_supabase_instance\n    mock_get_svc.return_value = db_record\n\n    response = client.get(f\"{TENANTS_API_BASE_PATH}/{str(tenant_id)}\")\n    assert response.status_code == 200\n    assert response.json()[\"tenant_id\"] == str(tenant_id)\n    mock_get_svc.assert_called_once_with(mock_supabase_instance, tenant_id)\n\n@patch(\"backend.routers.tenant_router.get_current_active_user\", return_value=MOCK_SUPERUSER)\n@patch(\"backend.routers.tenant_router.get_supabase_client\")\n@patch(\"backend.services.tenant_service.get_tenant\")\ndef test_get_tenant_not_found_as_superuser(mock_get_svc, mock_get_supabase, mock_auth, client):\n    tenant_id = uuid4()\n    mock_supabase_instance = MagicMock()\n    mock_get_supabase.return_value = mock_supabase_instance\n    mock_get_svc.return_value = None # Simulate not found\n\n    response = client.get(f\"{TENANTS_API_BASE_PATH}/{str(tenant_id)}\")\n    assert response.status_code == 404\n\n# UPDATE Tenant\n@patch(\"backend.routers.tenant_router.get_current_active_user\", return_value=MOCK_SUPERUSER)\n@patch(\"backend.routers.tenant_router.get_supabase_client\")\n@patch(\"backend.services.tenant_service.update_tenant\")\ndef test_update_tenant_success_as_superuser(mock_update_svc, mock_get_supabase, mock_auth, client):\n    tenant_id = uuid4()\n    update_payload = {\"company_name\": \"Updated Tenant Name\", \"is_deleted\": True}\n\n    # Simulate what the service would return after update\n    updated_db_record = helper_mock_tenant_db_record_dict(\n        tenant_id=tenant_id,\n        company_name=\"Updated Tenant Name\",\n        is_deleted=True\n    )\n    mock_supabase_instance = MagicMock()\n    mock_get_supabase.return_value = mock_supabase_instance\n    mock_update_svc.return_value = updated_db_record\n\n    response = client.put(f\"{TENANTS_API_BASE_PATH}/{str(tenant_id)}\", json=update_payload)\n    assert response.status_code == 200\n    resp_data = response.json()\n    assert resp_data[\"company_name\"] == \"Updated Tenant Name\"\n    assert resp_data[\"is_deleted\"] is True\n    # Check that service was called with Pydantic model (or its dict representation)\n    # The router passes TenantUpdatePayload to the service.\n    mock_update_svc.assert_called_once()\n    # More specific check on payload if needed:\n    # from backend.models.tenant_models import TenantUpdatePayload\n    # expected_service_payload = TenantUpdatePayload(**update_payload)\n    # mock_update_svc.assert_called_once_with(mock_supabase_instance, tenant_id, expected_service_payload)\n\n\n# DELETE Tenant (Logical)\n@patch(\"backend.routers.tenant_router.get_current_active_user\", return_value=MOCK_SUPERUSER)\n@patch(\"backend.routers.tenant_router.get_supabase_client\")\n@patch(\"backend.services.tenant_service.delete_tenant\")\ndef test_delete_tenant_logical_success_as_superuser(mock_delete_svc, mock_get_supabase, mock_auth, client):\n    tenant_id = uuid4()\n    mock_supabase_instance = MagicMock()\n    mock_get_supabase.return_value = mock_supabase_instance\n    mock_delete_svc.return_value = True # Simulate successful logical delete\n\n    response = client.delete(f\"{TENANTS_API_BASE_PATH}/{str(tenant_id)}\", params={\"hard_delete\": False})\n    assert response.status_code == 204\n    mock_delete_svc.assert_called_once_with(mock_supabase_instance, tenant_id, False)\n\n# DELETE Tenant (Hard)\n@patch(\"backend.routers.tenant_router.get_current_active_user\", return_value=MOCK_SUPERUSER)\n@patch(\"backend.routers.tenant_router.get_supabase_client\")\n@patch(\"backend.services.tenant_service.delete_tenant\")\ndef test_delete_tenant_hard_success_as_superuser(mock_delete_svc, mock_get_supabase, mock_auth, client):\n    tenant_id = uuid4()\n    mock_supabase_instance = MagicMock()\n    mock_get_supabase.return_value = mock_supabase_instance\n    mock_delete_svc.return_value = True\n\n    response = client.delete(f\"{TENANTS_API_BASE_PATH}/{str(tenant_id)}\", params={\"hard_delete\": True})\n    assert response.status_code == 204\n    mock_delete_svc.assert_called_once_with(mock_supabase_instance, tenant_id, True)\n\n@patch(\"backend.routers.tenant_router.get_current_active_user\", return_value=MOCK_SUPERUSER)\n@patch(\"backend.routers.tenant_router.get_supabase_client\")\n@patch(\"backend.services.tenant_service.delete_tenant\")\ndef test_delete_tenant_not_found_as_superuser(mock_delete_svc, mock_get_supabase, mock_auth, client):\n    tenant_id = uuid4()\n    mock_supabase_instance = MagicMock()\n    mock_get_supabase.return_value = mock_supabase_instance\n    mock_delete_svc.return_value = False # Simulate tenant not found by service\n\n    response = client.delete(f\"{TENANTS_API_BASE_PATH}/{str(tenant_id)}\")\n    assert response.status_code == 404\n"
    },
    {
      "path": "database/contact_form_schema.sql",
      "content": "-- PostgreSQL schema for contact_submissions table, suitable for Supabase\n\n-- Ensure the table is not created if it already exists\nCREATE TABLE IF NOT EXISTS contact_submissions (\n    id BIGSERIAL PRIMARY KEY,\n    created_at TIMESTAMPTZ DEFAULT NOW(),\n    name TEXT NOT NULL,\n    email TEXT NOT NULL,\n    message TEXT NOT NULL,\n    ga_client_id TEXT,\n    ga_session_id TEXT,\n    form_id TEXT -- To associate with the data-form-id from the widget\n);\n\n-- Add comments to columns for better understanding\nCOMMENT ON COLUMN contact_submissions.id IS 'Auto-incrementing unique identifier for each submission';\nCOMMENT ON COLUMN contact_submissions.created_at IS 'Timestamp of when the submission was created';\nCOMMENT ON COLUMN contact_submissions.name IS 'Name of the person submitting the form';\nCOMMENT ON COLUMN contact_submissions.email IS 'Email address of the person submitting the form';\nCOMMENT ON COLUMN contact_submissions.message IS 'The message content from the form submission';\nCOMMENT ON COLUMN contact_submissions.ga_client_id IS 'Google Analytics Client ID, if available';\nCOMMENT ON COLUMN contact_submissions.ga_session_id IS 'Google Analytics Session ID, if available';\nCOMMENT ON COLUMN contact_submissions.form_id IS 'Identifier for the specific form used for this submission (e.g., from data-form-id attribute)';\n\n-- Example of how to enable Row Level Security (RLS) - common in Supabase\n-- This is typically done in the Supabase UI, but can be scripted.\n-- Ensure RLS is enabled on the table.\n-- ALTER TABLE contact_submissions ENABLE ROW LEVEL SECURITY;\n\n-- Example: Allow public read-only access (adjust as needed for your security model)\n-- This policy is very permissive and likely not suitable for production without modification.\n-- CREATE POLICY \"Allow public read access\"\n-- ON contact_submissions\n-- FOR SELECT\n-- USING (true);\n\n-- Example: Allow authenticated users to insert their own data\n-- (This assumes you have a way to link auth.uid() to submissions, which is not part of this basic schema yet)\n-- CREATE POLICY \"Allow authenticated users to insert\"\n-- ON contact_submissions\n-- FOR INSERT\n-- WITH CHECK (auth.role() = 'authenticated');\n\n-- Note: Policies for UPDATE and DELETE would also be needed for full CRUD by users.\n-- Supabase typically handles data insertion via its API using the service_role key,\n-- which bypasses RLS by default, or via specific user roles if RLS is configured for inserts.\n-- For this project, the FastAPI backend will likely use a service role key to insert data,\n-- so insert policies for individual users might not be immediately necessary for the backend.\n"
    },
    {
      "path": "database/form_ga_configurations_schema.sql",
      "content": "-- Schema for form_ga_configurations table\n-- This table stores Google Analytics 4 Measurement Protocol configurations per form_id.\n\nCREATE TABLE IF NOT EXISTS form_ga_configurations (\n    form_id TEXT PRIMARY KEY,\n    ga4_measurement_id TEXT NOT NULL,\n    ga4_api_secret TEXT NOT NULL, -- IMPORTANT: Store encrypted in a real production system\n    description TEXT,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\nCOMMENT ON TABLE form_ga_configurations IS 'Stores GA4 Measurement Protocol configurations for each form.';\nCOMMENT ON COLUMN form_ga_configurations.form_id IS 'Unique identifier for the form (e.g., from data-form-id attribute).';\nCOMMENT ON COLUMN form_ga_configurations.ga4_measurement_id IS 'GA4 Measurement ID (e.g., G-XXXXXXXXXX).';\nCOMMENT ON COLUMN form_ga_configurations.ga4_api_secret IS 'GA4 API Secret for Measurement Protocol. IMPORTANT: This should be encrypted at rest in production.';\nCOMMENT ON COLUMN form_ga_configurations.description IS 'Optional description for this configuration set.';\nCOMMENT ON COLUMN form_ga_configurations.created_at IS 'Timestamp of when this configuration was created.';\nCOMMENT ON COLUMN form_ga_configurations.updated_at IS 'Timestamp of when this configuration was last updated.';\n\n-- Trigger to automatically update updated_at timestamp on row update\n-- This is PostgreSQL specific.\nCREATE OR REPLACE FUNCTION update_updated_at_column_form_ga_config() -- Renamed function to be more specific\nRETURNS TRIGGER AS $$\nBEGIN\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n$$ language 'plpgsql';\n\n-- Ensure the trigger name is unique if similar triggers exist for other tables.\nCREATE TRIGGER trigger_update_form_ga_configurations_updated_at\nBEFORE UPDATE ON form_ga_configurations\nFOR EACH ROW\nEXECUTE FUNCTION update_updated_at_column_form_ga_config(); -- Use renamed function\n"
    },
    {
      "path": "examples/form_widget_loader.ts",
      "content": "(() => {\n  const scriptElement = document.currentScript as HTMLScriptElement | null;\n\n  if (!scriptElement) {\n    console.error(\"Error: Could not find the script element. Make sure this script is not loaded as a module or asynchronously without `async=false`.\");\n    return;\n  }\n\n  const formId = scriptElement.getAttribute(\"data-form-id\");\n  const apiEndpoint = scriptElement.getAttribute(\"data-api-endpoint\") || 'https://api.example.com/submit';\n  const theme = scriptElement.getAttribute(\"data-theme\") || 'light';\n  const position = scriptElement.getAttribute(\"data-position\") || 'bottom-right';\n  const title = scriptElement.getAttribute(\"data-title\") || 'ãŠå•ã„åˆã‚ã›';\n  const buttonText = scriptElement.getAttribute(\"data-button-text\") || 'é€ä¿¡';\n\n  if (!formId) {\n    console.error(\"Error: data-form-id attribute is required and was not found on the script tag.\");\n    return;\n  }\n\n  console.log(\"Contact Form Widget Loader: Attributes collected:\");\n  console.log(\"  Form ID:        \", formId);\n  console.log(\"  API Endpoint:   \", apiEndpoint);\n  console.log(\"  Theme:          \", theme);\n  console.log(\"  Position:       \", position);\n  console.log(\"  Title:          \", title);\n  console.log(\"  Button Text:    \", buttonText);\n\n  const placeholderDiv = document.createElement('div');\n  placeholderDiv.id = `contact-form-widget-placeholder-${formId}`;\n  placeholderDiv.textContent = `Contact form widget (form-id: ${formId}) will be loaded here. Position: ${position}, Theme: ${theme}, Title: \"${title}\", Button: \"${buttonText}\", API: \"${apiEndpoint}\"`;\n  placeholderDiv.style.cssText = `\n    padding: 20px;\n    margin: 10px 0;\n    border: 1px dashed #ccc;\n    background-color: #f9f9f9;\n    text-align: center;\n    font-family: sans-serif;\n  `;\n  document.body.appendChild(placeholderDiv);\n\n})();\n"
    },
    {
      "path": "examples/usage_examples.html",
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Contact Form Widget Usage Examples</title>\n    <style>\n        body { \n            font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\n            padding: 20px; \n            line-height: 1.6;\n            color: #333;\n            background-color: #fdfdfd;\n        }\n        .container {\n            max-width: 800px;\n            margin: 0 auto;\n        }\n        .example-container { \n            margin-bottom: 40px; \n            padding: 20px; \n            border: 1px solid #e0e0e0; \n            border-radius: 8px;\n            background-color: #ffffff;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.05);\n        }\n        h1 {\n            border-bottom: 2px solid #007bff;\n            padding-bottom: 10px;\n            color: #007bff;\n        }\n        h2 { \n            margin-top: 0; \n            color: #333;\n            border-bottom: 1px solid #eee;\n            padding-bottom: 8px;\n        }\n        p {\n            margin-bottom: 15px;\n        }\n        code { \n            font-family: \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n            background-color: #f0f0f0; \n            padding: 2px 6px; \n            border-radius: 4px; \n            font-size: 0.9em;\n        }\n        pre { \n            background-color: #f5f5f5; \n            padding: 15px; \n            border-radius: 6px; \n            overflow-x: auto;\n            border: 1px solid #ddd;\n        }\n        pre code {\n            background-color: transparent; /* Avoid double background for code inside pre */\n            padding: 0;\n            font-size: 0.85em;\n        }\n        .note {\n            font-style: italic;\n            color: #555;\n            background-color: #fffbe6;\n            border-left: 4px solid #ffc107;\n            padding: 10px 15px;\n            border-radius: 4px;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Contact Form Widget Examples</h1>\n        <p>This page demonstrates how to embed the contact form widget on your website. The widget loader script (<code>form_widget_loader.js</code>) will read the <code>data-*</code> attributes from the script tag and create a placeholder element where the actual form will be rendered (or indicate what will be rendered).</p>\n        \n        <p>To use the widget, include the <code>form_widget_loader.js</code> script in your HTML and provide the necessary <code>data-*</code> attributes.</p>\n\n        <div class=\"example-container\">\n            <h2>Minimal Configuration</h2>\n            <p>This example uses only the required <code>data-form-id</code> attribute. The loader script will use default values for other settings like title, theme, and API endpoint.</p>\n            <p><strong>Code:</strong></p>\n            <pre><code>&lt;script src=\"form_widget_loader.js\" data-form-id=\"default-contact-form\"&gt;&lt;/script&gt;</code></pre>\n            <p><strong>Live Example (Placeholder):</strong></p>\n            <!-- Actual script tag for testing -->\n            <script src=\"form_widget_loader.js\" data-form-id=\"default-contact-form\"></script>\n        </div>\n\n        <div class=\"example-container\">\n            <h2>Customized Configuration</h2>\n            <p>This example demonstrates using various <code>data-*</code> attributes to customize the widget's appearance and behavior.</p>\n            <p><strong>Code:</strong></p>\n            <pre><code>&lt;script src=\"form_widget_loader.js\" \n        data-form-id=\"product-inquiry-001\"\n        data-api-endpoint=\"https://your-custom-api.com/submit-inquiry\"\n        data-theme=\"dark\"\n        data-position=\"bottom-left\"\n        data-title=\"Product Inquiry\"\n        data-button-text=\"Send Inquiry\"&gt;&lt;/script&gt;</code></pre>\n            <p><strong>Live Example (Placeholder):</strong></p>\n            <!-- Actual script tag for testing -->\n            <script src=\"form_widget_loader.js\" \n                    data-form-id=\"product-inquiry-001\"\n                    data-api-endpoint=\"https://your-custom-api.com/submit-inquiry\"\n                    data-theme=\"dark\"\n                    data-position=\"bottom-left\"\n                    data-title=\"Product Inquiry\"\n                    data-button-text=\"Send Inquiry\"></script>\n        </div>\n\n        <p class=\"note\"><em><strong>Important:</strong> For these examples to function correctly, the <code>form_widget_loader.ts</code> file (located in the same <code>examples</code> directory) must be compiled into JavaScript as <code>form_widget_loader.js</code> and be accessible at the same path relative to this HTML file. The current loader script only creates a placeholder div and logs attributes to the console; it does not yet render the actual React form widget.</em></p>\n\n        <hr>\n        <p>Some other content on this page to simulate a real website structure.</p>\n        <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p>\n    </div>\n</body>\n</html>\n"
    },
    {
      "path": "frontend/src/components/ContactFormWidget.tsx",
      "content": "import React, { useState, useEffect } from 'react';\n\ninterface ContactFormWidgetProps {\n  formTitle?: string;\n  submitButtonText?: string;\n  // apiEndpoint?: string; // To be added later\n}\n\nconst getGAClientId = (): string => {\n  // In a real scenario, you might try to get this from cookies or a GA API\n  // For example, by looking for a cookie like _ga or _ga_YOUR_MEASUREMENT_ID\n  // Or if using analytics.js (Universal Analytics):\n  // if (typeof ga === 'function' && ga.getAll && ga.getAll()[0]) {\n  //   return ga.getAll()[0].get('clientId');\n  // }\n  // For gtag.js (GA4), it's more complex and often involves parsing cookies like _ga_MEASUREMENTID\n  // or custom event tracking.\n  return \"CLIENT_ID_PLACEHOLDER\";\n};\n\nconst getGASessionId = (): string => {\n  // Similar to client ID, session ID retrieval is complex.\n  // For gtag.js (GA4), you might use:\n  // gtag('get', 'YOUR_MEASUREMENT_ID', 'session_id', (sessionId) => { /* use sessionId */ });\n  // Or parse it from cookies like _ga_MEASUREMENTID (e.g., G1.1.123456789.1678901234 where 1678901234 might be a session identifier)\n  return \"SESSION_ID_PLACEHOLDER\";\n};\n\nconst ContactFormWidget: React.FC<ContactFormWidgetProps> = ({\n  formTitle = 'ãŠå•ã„åˆã‚ã›',\n  submitButtonText = 'é€ä¿¡',\n}) => {\n  const [name, setName] = useState('');\n  const [email, setEmail] = useState('');\n  const [message, setMessage] = useState('');\n  const [gaClientId, setGaClientId] = useState('');\n  const [gaSessionId, setGaSessionId] = useState('');\n\n  useEffect(() => {\n    setGaClientId(getGAClientId());\n    setGaSessionId(getGASessionId());\n  }, []);\n\n  const handleSubmit = (event: React.FormEvent) => {\n    event.preventDefault();\n    // Actual submission logic will be added later.\n    // This will involve sending data to apiEndpoint.\n    console.log(\"Form submitted with data:\", {\n      name,\n      email,\n      message,\n      ga_client_id: gaClientId,\n      ga_session_id: gaSessionId,\n    });\n    // alert(\"Form submitted (see console for data). Actual API call not implemented yet.\");\n  };\n\n  const styles = {\n    container: {\n      border: '1px solid #ccc',\n      padding: '20px',\n      borderRadius: '8px',\n      backgroundColor: '#f9f9f9',\n      maxWidth: '500px',\n      fontFamily: 'Arial, sans-serif',\n    },\n    heading: {\n      textAlign: 'center' as 'center',\n      color: '#333',\n      marginBottom: '20px',\n    },\n    formGroup: {\n      marginBottom: '15px',\n    },\n    label: {\n      display: 'block',\n      marginBottom: '5px',\n      color: '#555',\n      fontSize: '14px',\n    },\n    input: {\n      width: 'calc(100% - 20px)',\n      padding: '10px',\n      border: '1px solid #ddd',\n      borderRadius: '4px',\n      fontSize: '16px',\n    },\n    textarea: {\n      width: 'calc(100% - 20px)',\n      padding: '10px',\n      border: '1px solid #ddd',\n      borderRadius: '4px',\n      fontSize: '16px',\n      minHeight: '80px',\n      resize: 'vertical' as 'vertical',\n    },\n    button: {\n      width: '100%',\n      padding: '10px 15px',\n      backgroundColor: '#007bff',\n      color: 'white',\n      border: 'none',\n      borderRadius: '4px',\n      fontSize: '16px',\n      cursor: 'pointer',\n      transition: 'background-color 0.2s ease-in-out',\n    },\n    // buttonHover: { // Note: Inline styles don't directly support pseudo-classes like :hover\n    //   backgroundColor: '#0056b3',\n    // }\n  };\n\n  return (\n    <div style={styles.container}>\n      <h2 style={styles.heading}>{formTitle}</h2>\n      <form onSubmit={handleSubmit}>\n        <div style={styles.formGroup}>\n          <label htmlFor=\"contact-name\" style={styles.label}>Name</label>\n          <input\n            type=\"text\"\n            id=\"contact-name\"\n            name=\"name\"\n            value={name}\n            onChange={(e) => setName(e.target.value)}\n            required\n            style={styles.input}\n          />\n        </div>\n\n        <div style={styles.formGroup}>\n          <label htmlFor=\"contact-email\" style={styles.label}>Email</label>\n          <input\n            type=\"email\"\n            id=\"contact-email\"\n            name=\"email\"\n            value={email}\n            onChange={(e) => setEmail(e.target.value)}\n            required\n            style={styles.input}\n          />\n        </div>\n\n        <div style={styles.formGroup}>\n          <label htmlFor=\"contact-message\" style={styles.label}>Message</label>\n          <textarea\n            id=\"contact-message\"\n            name=\"message\"\n            value={message}\n            onChange={(e) => setMessage(e.target.value)}\n            required\n            style={styles.textarea}\n          />\n        </div>\n\n        <input type=\"hidden\" name=\"ga_client_id\" value={gaClientId} />\n        <input type=\"hidden\" name=\"ga_session_id\" value={gaSessionId} />\n\n        <button type=\"submit\" style={styles.button}>\n          {submitButtonText}\n        </button>\n      </form>\n    </div>\n  );\n};\n\nexport default ContactFormWidget;\n"
    }
  ]
}
