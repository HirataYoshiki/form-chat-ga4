{
  "files": [
    {
      "path": ".env.example",
      "content": "# .env.example - Environment variables for the Contact Form Widget application\n\n# --- AI Agent Settings ---\n\n# Specifies the Gemini model to be used by the AI agent.\n# Default is \"gemini-1.5-flash-latest\" if not set here and not overridden in code.\nGEMINI_MODEL_NAME=\"gemini-1.5-flash-latest\"\n\n# Google API Key for accessing Google Cloud services, including the Gemini API.\n# This is optional if Application Default Credentials (ADC) are already set up\n# in the environment where the application runs, as the Google ADK might pick those up.\n# If you have a specific API key you need to use, uncomment the line below and provide your key.\n# GOOGLE_API_KEY=\"\"\n\n# --- Supabase Connection Settings (Ensure these are set if using Supabase) ---\n# SUPABASE_URL=\"YOUR_SUPABASE_URL\"\n# SUPABASE_SERVICE_ROLE_KEY=\"YOUR_SUPABASE_SERVICE_ROLE_KEY\"\n\n# --- Supabase Auth Settings ---\n# JWKS URI for verifying Supabase JWTs. Usually: YOUR_SUPABASE_URL/auth/v1/jwks\n# SUPABASE_JWKS_URI=\"YOUR_SUPABASE_PROJECT_URL/.well-known/jwks.json\" # Or YOUR_SUPABASE_URL/auth/v1/jwks\n\n# Supabase JWT Audience (usually 'authenticated')\nSUPABASE_JWT_AUDIENCE=\"authenticated\"\n# Supabase JWT Issuer (e.g., https://your-project-ref.supabase.co/auth/v1)\n# This can often be derived from SUPABASE_URL, but explicit is fine too.\n# If your SUPABASE_URL is https://<project-ref>.supabase.co, then issuer is SUPABASE_URL + /auth/v1\n# SUPABASE_JWT_ISSUER=\"YOUR_SUPABASE_PROJECT_URL/auth/v1\"\n\n# --- AI Agent Retry Settings ---\n# Maximum number of retry attempts for AI agent calls\nAI_AGENT_RETRY_ATTEMPTS=3\n# Initial wait time in seconds before the first retry\nAI_AGENT_RETRY_WAIT_INITIAL_SECONDS=1\n# Maximum wait time in seconds between retries (using exponential backoff)\nAI_AGENT_RETRY_WAIT_MAX_SECONDS=10\n# Multiplier for exponential backoff (e.g., 2 means 1s, 2s, 4s, ...)\nAI_AGENT_RETRY_WAIT_MULTIPLIER=2\n\n# --- Other Potential Settings (Examples - Not currently in use by config.py but good for future) ---\n# DATABASE_URL=\"postgresql://user:pass@host:port/dbname\"\n# LOG_LEVEL=\"INFO\"\n"
    },
    {
      "path": ".gitignore",
      "content": "# Environment variables\n.env\n\n# Python bytecode\n__pycache__/\n*.pyc\n*.pyo\n*.pyd\n\n# OS-specific\n.DS_Store\nThumbs.db\n\n# IDE specific\n.vscode/\n.idea/\n"
    },
    {
      "path": ".sample.env",
      "content": "# .sample.env\n# Rename this file to .env and fill in your actual values.\n# Do NOT commit your .env file to version control.\n\n# Configuration for the AI Agent\nGEMINI_MODEL_NAME=\"gemini-2.0-flash\"\n\n# Google Cloud API Key (if using API key authentication for Gemini)\n# Ensure this key has permissions for the Gemini API or Vertex AI API.\nGOOGLE_API_KEY=\"YOUR_GOOGLE_API_KEY_HERE\"\n\n# Alternatively, for Application Default Credentials (ADC), \n# you might set GOOGLE_APPLICATION_CREDENTIALS in your environment\n# to point to your service account JSON key file.\n# GOOGLE_APPLICATION_CREDENTIALS=\"/path/to/your/service-account-file.json\"\n"
    },
    {
      "path": "Makefile",
      "content": "# Makefile for Contact Form Widget Project\n\n.PHONY: dev build test clean logs restart help\n\ndev:\n\t@echo \"Makefile: Starting development environment (placeholder)...\"\n\t@echo \"Typically, this would run: docker-compose up --build -d\"\n\t@echo \"Then you might want to tail logs with 'make logs'\"\n\nbuild:\n\t@echo \"Makefile: Building production assets (placeholder)...\"\n\t@echo \"For frontend: cd frontend && npm install && npm run build (or yarn build)\"\n\t@echo \"For backend: Potentially 'docker build -t contact-widget-backend backend' and 'docker build -t contact-widget-frontend frontend'\"\n\t@echo \"This target might also include steps like code generation or other pre-compilation tasks.\"\n\ntest:\n\t@echo \"Makefile: Running tests (placeholder)...\"\n\t@echo \"For frontend: cd frontend && npm test (or yarn test)\"\n\t@echo \"For backend: cd backend && pytest (or your chosen Python test runner)\"\n\t@echo \"Consider running linters and formatters here too.\"\n\nclean:\n\t@echo \"Makefile: Cleaning up (e.g., removing Docker containers, build artifacts, caches) (placeholder)...\"\n\t@echo \"Typically, this would run: docker-compose down -v --remove-orphans\"\n\t@echo \"Also consider removing: node_modules, __pycache__, .pytest_cache, build artifacts etc.\"\n\t@echo \"Example: rm -rf frontend/node_modules frontend/dist backend/__pycache__\"\n\nlogs:\n\t@echo \"Makefile: Tailing logs from services (placeholder)...\"\n\t@echo \"Typically, this would run: docker-compose logs -f\"\n\t@echo \"You can also target specific services, e.g., 'docker-compose logs -f backend_service'\"\n\nrestart:\n\t@echo \"Makefile: Restarting services (placeholder)...\"\n\t@echo \"Typically, this would run: docker-compose restart\"\n\t@echo \"Or for specific services: docker-compose restart backend_service frontend_service\"\n\nhelp:\n\t@echo \"Available commands for Contact Form Widget Project:\"\n\t@echo \"\"\n\t@echo \"  Development:\"\n\t@echo \"    make dev      - Start the development environment (e.g., using Docker Compose).\"\n\t@echo \"    make logs     - View live logs from running services.\"\n\t@echo \"    make restart  - Restart all or specific services.\"\n\t@echo \"    make clean    - Stop services, remove containers, volumes, and build artifacts.\"\n\t@echo \"\"\n\t@echo \"  Build & Test:\"\n\t@echo \"    make build    - Build frontend and backend assets for production.\"\n\t@echo \"    make test     - Run automated tests for frontend and backend.\"\n\t@echo \"\"\n\t@echo \"  General:\"\n\t@echo \"    make help     - Show this help message.\"\n\t@echo \"\"\n\t@echo \"Note: Most commands are currently placeholders. Actual commands will be added later.\"\n"
    },
    {
      "path": "README.md",
      "content": "# 📝 Contact Form Widget\n\n**1行のコードで埋め込み可能なお問い合わせフォームウィジェット**\n\n零細中小企業向けに設計された、簡単導入・高機能なお問い合わせフォームサービスです。\n\n## ✨ 特徴\n\n- 🚀 **1行埋め込み**: `<script>`タグ1つで即座に導入完了\n- 📱 **レスポンシブ対応**: モバイル・デスクトップ自動調整\n- 🎨 **カスタマイズ可能**: テーマ・位置・文言を自由設定\n- ✅ **リアルタイムバリデーション**: 入力エラーを即座に表示\n- 📧 **自動通知**: Slack・メール・自動返信に対応\n- 🛡️ **スタイル隔離**: Shadow DOMで既存サイトと干渉しない\n- 💾 **データ保存**: Supabase連携で確実にデータを保管\n- 📈 **GA4連携**: Google Analytics 4へのイベント送信（Measurement Protocol経由）に対応し、リード獲得状況や顧客エンゲージメントをトラッキング。\n- ⚡ **高速表示**: 最適化されたバンドルサイズ\n\n## 🚀 クイックスタート\n\n### 1. 基本的な埋め込み\n\nお客様のサイトに以下の1行を追加するだけ：\n\n```html\n<script src=\"https://yourservice.com/contact-widget.js\" data-form-id=\"default-form\"></script>\n```\n\n### 2. カスタマイズした埋め込み\n\n```html\n<script src=\"https://yourservice.com/contact-widget.js\" \n        data-form-id=\"product-inquiry\"\n        data-theme=\"dark\"\n        data-position=\"bottom-left\"\n        data-title=\"製品について\"\n        data-button-text=\"製品を問い合わせる\"></script>\n```\n\n## 📋 設定オプション\n\n| オプション | 説明 | デフォルト値 | 例 |\n|-----------|------|-------------|-----|\n| `data-form-id` | フォームID（必須） | - | `\"default-form\"` |\n| `data-api-endpoint` | APIエンドポイント | 本番URL | `\"https://api.example.com\"` |\n| `data-theme` | テーマ | `\"light\"` | `\"light\"` / `\"dark\"` |\n| `data-position` | 表示位置 | `\"bottom-right\"` | `\"bottom-right\"` / `\"bottom-left\"` / `\"center\"` |\n| `data-title` | フォームタイトル | `\"お問い合わせ\"` | `\"製品について\"` |\n| `data-button-text` | ボタンテキスト | `\"お問い合わせ\"` | `\"今すぐ相談\"` |\n\n## 💻 JavaScript API\n\nプログラマティックな制御も可能：\n\n```javascript\n// フォームを表示\nwindow.ContactFormWidget.init({\n  formId: 'dynamic-form',\n  theme: 'light',\n  position: 'center',\n  title: 'お問い合わせ',\n  buttonText: 'お問い合わせする'\n});\n\n// フォームを非表示\nwindow.ContactFormWidget.destroy();\n```\n\n## 🎯 使用例\n\n### WordPress\n```php\n// functions.phpに追加\nfunction add_contact_form_widget() {\n    echo '<script src=\"https://yourservice.com/contact-widget.js\" data-form-id=\"wordpress-form\"></script>';\n}\nadd_action('wp_footer', 'add_contact_form_widget');\n```\n\n### Shopify\n```html\n<!-- theme.liquidに追加 -->\n<script src=\"https://yourservice.com/contact-widget.js\" \n        data-form-id=\"shopify-form\"\n        data-title=\"商品について\"></script>\n```\n\n### 条件付き表示\n```javascript\n// 10秒後に自動表示\nsetTimeout(() => {\n  window.ContactFormWidget.init({\n    formId: 'auto-popup',\n    title: 'まだお探しですか？'\n  });\n}, 10000);\n```\n\n## 🔧 開発環境セットアップ\n\n### 前提条件\n\n- Node.js 18+\n- Python 3.11+\n- Docker & Docker Compose\n\n### 1. リポジトリをクローン\n\n```bash\ngit clone https://github.com/yourcompany/contact-form-widget.git\ncd contact-form-widget\n```\n\n### 2. 環境変数を設定\n\n```bash\ncp .env.example .env\n# .envファイルを編集してSupabaseの接続情報やその他のAPIキーを設定\n# 例:\n# SUPABASE_URL=\"YOUR_SUPABASE_URL\"\n# SUPABASE_SERVICE_ROLE_KEY=\"YOUR_SUPABASE_SERVICE_ROLE_KEY\"\n# GEMINI_MODEL_NAME=\"gemini-1.5-flash-latest\"\n# # GOOGLE_API_KEY=\"YOUR_GOOGLE_API_KEY\" # (AI Agent用、ADCがなければ)\n# # GA4関連のAPIキーと測定IDは、API経由でフォームごとに設定します。\n```\n\n### 3. 開発環境を起動\n\n```bash\n# Docker Composeで起動\nmake dev\n\n# または手動で起動\ndocker-compose up --build\n```\n\n### 4. アクセス確認\n\n- **フロントエンド（管理画面）**: http://localhost:3000\n- **ウィジェット開発サーバー**: http://localhost:5173\n- **バックエンドAPI**: http://localhost:8000\n- **API ドキュメント**: http://localhost:8000/docs\n\n## 🔗 APIエンドポイント概要\n\n主要なAPIエンドポイントは以下の通りです。詳細は `/docs` (Swagger UI) を参照してください。\n\n-   **`POST /submit`**:\n    -   お問い合わせフォームからのデータを受け付け、データベースに保存します。\n    -   保存成功後、GA4に `generate_lead` イベントを送信します（フォームにGA4設定がされている場合）。\n-   **`POST /chat`**:\n    -   AIチャットボットとの対話メッセージを処理します。\n-   **`POST /api/v1/ga_configurations`**:\n    -   新しいフォームに対するGA4設定（測定ID、APIシークレット等）を登録します。\n-   **`GET /api/v1/ga_configurations`**:\n    -   登録されている全てのフォームGA4設定をリストします。\n-   **`GET /api/v1/ga_configurations/{form_id}`**:\n    -   指定された `form_id` のGA4設定を取得します。\n-   **`PUT /api/v1/ga_configurations/{form_id}`**:\n    -   指定された `form_id` のGA4設定を更新します。\n-   **`DELETE /api/v1/ga_configurations/{form_id}`**:\n    -   指定された `form_id` のGA4設定を削除します。\n-   **`PATCH /api/v1/submissions/{submission_id}/status`**:\n    -   指定された問い合わせ (`submission_id`) のステータスを更新します。\n    -   ステータス変更に応じて、適切なイベントをGA4に送信します（フォームにGA4設定がされている場合）。\n\n## 📁 プロジェクト構成\n\n```\ncontact-form-widget/\n├── frontend/                          # React フロントエンド\n│   └── src/ # ... (詳細は省略)\n├── backend/\n│   ├── routers/\n│   │   ├── form_ga_config_router.py   # GA4設定管理APIルーター\n│   │   └── submission_router.py       # 問い合わせステータス管理APIルーター\n│   ├── services/\n│   │   ├── form_ga_config_service.py  # GA4設定管理サービス\n│   │   ├── ga4_mp_service.py          # GA4 MPイベント送信サービス\n│   │   └── submission_service.py      # 問い合わせステータス管理サービス\n│   ├── models/\n│   │   ├── ga4_config_models.py       # GA4設定API用Pydanticモデル\n│   │   └── submission_models.py       # 問い合わせステータスAPI用Pydanticモデル\n│   ├── contact_api.py                 # FastAPIメインアプリケーション\n│   ├── ai_agent.py                    # AIチャットボットロジック\n│   ├── config.py                      # 環境変数・設定管理\n│   ├── db.py                          # Supabaseクライアント初期化\n│   └── requirements.txt               # Python依存関係\n├── database/\n│   ├── contact_form_schema.sql        # 問い合わせデータテーブルスキーマ\n│   └── form_ga_configurations_schema.sql # GA4設定テーブルスキーマ (Added)\n├── examples/                          # 各プラットフォームでの使用例\n│   ├── form_widget_loader.ts\n│   └── usage_examples.html\n├── docker-compose.yml                 # Docker Compose設定\n├── Makefile                           # 開発用Makefile\n└── README.md                          # 本ドキュメント\n```\n\n## 🛠️ 利用可能なコマンド\n\n```bash\nmake dev          # 開発環境起動\nmake build        # 本番ビルド\nmake test         # テスト実行\nmake clean        # コンテナ削除\nmake logs         # ログ確認\nmake restart      # 再起動\n```\n\n## 🚀 デプロイ\n\n### Vercel (フロントエンド)\n\n```bash\ncd frontend\nvercel --prod\n```\n\n### Railway (バックエンド)\n\n```bash\ncd backend\nrailway deploy\n```\n\n### Supabase (データベース)\n\n1. [Supabase](https://supabase.com)でプロジェクト作成\n2. `database/contact_form_schema.sql`を実行\n3. 環境変数にURL・KEYを設定\n\n## 📊 機能一覧\n\n### フォーム機能\n- [x] 基本項目（名前・メール・会社・電話・メッセージ）\n- [x] リアルタイムバリデーション\n- [x] 送信中・完了状態の表示\n- [x] レスポンシブデザイン\n\n### 通知機能\n- [ ] 管理者メール通知 (開発優先度 低)\n- [ ] 顧客自動返信メール (開発優先度 低)\n- [ ] Slack通知 (開発優先度 低)\n- [ ] SMS通知 (開発優先度 低)\n- [ ] Discord通知 (開発優先度 低)\n\n### 管理機能\n- [x] 送信データの保存\n- [ ] データ分析 (GA4連携により高度な分析が可能)\n- [ ] 管理画面UI（開発中）\n- [ ] 詳細分析 (GA4を活用)\n\n### 📈 GA4連携機能\n- [x] フォーム送信時に `generate_lead` イベントをGA4に送信 (Measurement Protocol経由)\n- [x] 問い合わせステータス変更時に対応するGA4イベントを送信 (例: `working_lead`, `qualify_lead`, `close_convert_lead`)\n- [x] フォームごとのGA4測定ID・APIシークレット設定機能 (専用API経由で管理)\n\n\n\n---\n\n**Made with ❤️ for small businesses**\n"
    },
    {
      "path": "docker-compose.yml",
      "content": "version: '3.8'\n\n# This is a basic placeholder docker-compose.yml for development.\n#\n# Key considerations for a real setup:\n# 1. Dockerfiles: Each service (frontend, backend) will need its own Dockerfile\n#    (e.g., Dockerfile.dev or simply Dockerfile) in its respective directory.\n#    These files define how the application image is built, dependencies installed,\n#    and how the application starts.\n# 2. Build vs. Image: The commented-out 'build' sections are what you'd use\n#    when you have Dockerfiles. For this placeholder, pre-built images are used.\n# 3. Volumes: Volumes are crucial for development as they map your local code\n#    into the container, allowing for live reloading.\n# 4. Environment Variables: Use .env files for sensitive or environment-specific\n#    configurations and reference them here.\n# 5. Networking: For services to communicate by name (e.g., frontend calling backend),\n#    Docker Compose sets up a default network. More complex network configurations\n#    can be defined if needed.\n# 6. Database: A database service (e.g., Postgres for Supabase compatibility)\n#    could be defined here if you were running it locally. Since this project\n#    targets Supabase, the database is external.\n# 7. Production: For production, you'd typically have a separate docker-compose.prod.yml\n#    or use different settings within the Dockerfiles (multi-stage builds).\n\nservices:\n  frontend:\n    # build:\n    #   context: ./frontend\n    #   dockerfile: Dockerfile.dev  # Placeholder: Dockerfile needs to be created in ./frontend\n    image: node:18-alpine  # Using a pre-built Node.js image for placeholder\n    container_name: contact_form_frontend_dev\n    command: sh -c \"echo 'Frontend container running (placeholder). In a real setup, this would run your dev server (e.g., npm start).' && tail -f /dev/null\"\n    ports:\n      - \"3000:3000\"  # Standard port for React/Vue/Angular dev servers\n    volumes:\n      # Mount the local frontend directory into the container for live reloading.\n      # The Dockerfile would typically set /app as the working directory and copy package.json, run npm install, etc.\n      - ./frontend:/app\n      # Example for node_modules (can improve performance on some systems, but often not needed initially):\n      # - /app/node_modules\n    working_dir: /app # Assumes your frontend Dockerfile sets this up and runs npm install\n    environment:\n      - NODE_ENV=development\n      # Add other frontend specific environment variables here\n      # e.g., REACT_APP_API_URL=http://localhost:8000/api\n    restart: unless-stopped\n\n  backend:\n    # build:\n    #   context: ./backend\n    #   dockerfile: Dockerfile.dev  # Placeholder: Dockerfile needs to be created in ./backend\n    image: python:3.11-slim  # Using a pre-built Python image for placeholder\n    container_name: contact_form_backend_dev\n    command: sh -c \"echo 'Backend container running (placeholder). In a real setup, this would run your FastAPI/uvicorn server.' && tail -f /dev/null\"\n    ports:\n      - \"8000:8000\"  # Standard port for Python web frameworks like FastAPI/Flask\n    volumes:\n      # Mount the local backend directory into the container for live reloading.\n      # The Dockerfile would typically set /app as the working directory, copy requirements.txt, run pip install, etc.\n      - ./backend:/app\n    working_dir: /app # Assumes your backend Dockerfile sets this up and runs pip install\n    environment:\n      - PYTHONUNBUFFERED=1 # Ensures print statements and logs are sent straight to terminal\n      - APP_ENV=development\n      # Add other backend specific environment variables here\n      # e.g., DATABASE_URL, API_KEYS (preferably via .env file and docker-compose env_file property)\n    restart: unless-stopped\n\n# Notes on further development:\n# - Create Dockerfile.dev for both frontend and backend.\n# - Frontend Dockerfile: Copy package.json, run npm install, expose port, set CMD for dev server.\n# - Backend Dockerfile: Copy requirements.txt, run pip install, expose port, set CMD for uvicorn.\n# - Consider adding a database service if local testing against Postgres is desired.\n# - For production, create Dockerfile (optimized for smaller size, security) and potentially a\n#   separate docker-compose.prod.yml or override file.\n"
    },
    {
      "path": "backend/README.md",
      "content": "# Contact Form Widget - Backend\n\nこのドキュメントは、Contact Form Widgetプロジェクトのバックエンドアプリケーションに関する技術的な詳細、セットアップ手順、API仕様について説明します。\n\n## 1. 概要 (Overview)\n\nバックエンドアプリケーションは、Contact Form Widgetから送信されるお問い合わせデータの受付、保存、および管理機能を提供します。マルチテナントアーキテクチャを採用しており、クライアント企業（テナント）ごとにデータを分離・管理できます。また、AIチャットボット機能、Google Analytics 4 (GA4) へのイベント送信機能も担います。\n\n主な機能は以下の通りです。\n\n-   **マルチテナント対応**: 各テナントは自身のフォーム、問い合わせデータ、GA4設定を独立して管理できます。\n-   **フォームデータ処理**: フロントエンドウィジェットからの問い合わせデータ（名前、メールアドレス、メッセージ等）を受信し、テナントごとにデータベースに保存します。\n-   **AIチャットボット連携**: ユーザーからの質問に対してAI（Geminiモデルを利用）が応答するチャット機能を提供します。AIとの通信時には、設定に基づいたリトライ処理が実行され、一時的な通信エラーに対する堅牢性を高めています。\n-   **GA4 Measurement Protocol連携**: フォーム送信時や問い合わせステータス変更時に、リードジェネレーション関連のイベントをGA4に送信します。この機能もテナントごとに設定可能です。\n-   **GA4設定管理**: テナント内のフォームごとにGA4の測定IDとAPIシークレットを設定・管理するためのAPIを提供します。\n-   **問い合わせステータス管理**: 問い合わせの進捗ステータス（新規、連絡済み、成約など）を管理し、ステータス変更を行うためのAPIをテナントごとに提供します。\n-   **テナント管理 (スーパーユーザー限定)**: スーパーユーザー向けに、テナント（クライアント企業アカウント）の作成、一覧表示、更新、削除を行うAPIを提供します。\n\nこのバックエンドは、フロントエンドの埋め込みウィジェットと連携して動作するように設計されています。認証はSupabase Authを利用したJWTベースで行われ、ユーザーロール（`user`, `superuser`）に応じたアクセス制御が適用されます。\n\n## 2. 技術スタック (Tech Stack)\n\nバックエンドシステムは以下の主要な技術で構成されています。\n\n-   **プログラミング言語**: Python 3.11+\n-   **フレームワーク**: FastAPI - 高パフォーマンスな非同期Webフレームワーク。\n-   **データベース**: Supabase (PostgreSQL) - `supabase-py` クライアントライブラリを通じて連携。\n-   **データバリデーション**: Pydantic V2 - APIリクエスト/レスポンスの型定義とバリデーション。\n-   **HTTPクライアント**: `httpx` - GA4 Measurement Protocol APIなど、外部APIとの非同期通信に使用。\n-   **AI連携**: Google Agent Development Kit (ADK) - Geminiモデルを利用したAIエージェント機能。\n-   **認証**: Supabase Auth (JWTベースの認証)\n-   **JWT処理**: python-jose[cryptography] (JWTのデコードと検証)\n-   **リトライ処理**: tenacity - AI Agentなどの外部API呼び出しにおけるリトライ処理に使用。\n-   **ASGIサーバー**: Uvicorn - FastAPIアプリケーションの実行。\n-   **依存関係管理**: `pip` と `requirements.txt`。\n\n## 3. プロジェクト構造 (Project Structure)\n\n`backend/` ディレクトリ内の主要なサブディレクトリとファイルの役割は以下の通りです。\n\n```\nbackend/\n├── .gitkeep                     # 空ディレクトリをGit管理するためのプレースホルダ (あれば)\n├── ai_agent.py                  # AIチャットボットのロジック（ADK、Gemini連携）\n├── auth.py                      # JWT認証・認可ロジック\n├── config.py                    # 環境変数管理（Pydantic Settingsによる設定読み込み）\n├── contact_api.py               # メインFastAPIアプリケーション定義、主要エンドポイント（/submit, /chat）、ルーター登録\n├── db.py                        # Supabaseクライアントの初期化とFastAPI依存性注入の提供\n├── models/                      # Pydanticモデル定義用ディレクトリ\n│   ├── ga4_config_models.py     # GA4設定管理API用のリクエスト/レスポンスモデル\n│   ├── submission_models.py     # 問い合わせステータス更新API用のリクエストモデル\n│   └── tenant_models.py         # テナント管理API用のリクエスト/レスポンスモデル\n├── requirements.txt             # Pythonの依存パッケージリスト\n├── routers/                     # APIルーターモジュール用ディレクトリ\n│   ├── form_ga_config_router.py # GA4設定管理APIのエンドポイント定義\n│   ├── submission_router.py     # 問い合わせステータス更新APIのエンドポイント定義\n│   └── tenant_router.py         # テナント管理APIのエンドポイント定義\n├── services/                    # ビジネスロジック層用ディレクトリ\n│   ├── form_ga_config_service.py# GA4設定のCRUD処理ロジック\n│   ├── ga4_mp_service.py        # GA4 Measurement Protocol APIへのイベント送信ロジック\n│   ├── submission_service.py    # 問い合わせステータス更新処理ロジック\n│   └── tenant_service.py        # テナント管理のCRUD処理ロジック\n└── tests/                       # 自動テスト用ディレクトリ\n    ├── test_contact_api.py      # /submit API (/chat APIは未実装) のテスト\n    ├── test_form_ga_config_api.py # GA4設定管理APIのテスト\n    ├── test_submission_api.py   # ステータス更新・一覧取得APIのテスト\n    ├── test_ai_agent.py         # AI Agent関連ロジックのテスト\n    └── test_tenant_api.py       # テナント管理APIのテスト\n```\n\n-   **`contact_api.py`**: FastAPIアプリケーションのインスタンス (`app`) を生成し、ミドルウェアの設定、主要なエンドポイント（`/submit`, `/chat`）、および各機能ルーターの登録を行います。認証機能 (`get_current_active_user`) は `auth.py` からインポートして利用します。\n-   **`config.py`**: `.env` ファイルから環境変数を読み込み、アプリケーション全体で利用可能な設定オブジェクトを提供します。\n-   **`db.py`**: Supabaseクライアントを初期化し、APIエンドポイントでデータベース接続を利用するためのFastAPI依存性注入関数 (`get_supabase_client`) を提供します。\n-   **`auth.py`**: JWTベースの認証・認可処理を実装します。Supabaseから発行されたJWTの検証、ユーザー情報の取得（`public.users` テーブル経由）、ロールベースアクセス制御（RBAC）のための依存性注入関数 (`get_current_active_user`, `require_superuser_role` など) を提供します。\n-   **`ai_agent.py`**: Google ADKを利用したAIチャットボットの応答生成ロジックを実装しています。\n-   **`models/`**: APIのリクエストボディやレスポンスボディの構造を定義するPydanticモデルを格納します。`tenant_models.py` が追加されました。\n-   **`routers/`**: 各機能グループに対応するAPIエンドポイント（パスオペレーション）を定義した `APIRouter` モジュールを格納します。`tenant_router.py` が追加されました。\n-   **`services/`**: APIエンドポイントから呼び出されるビジネスロジックやデータベース操作をカプセル化した関数/クラスを格納します。`tenant_service.py` が追加されました。\n-   **`tests/`**: `pytest` を利用した自動テストコードを格納します。各APIルーターや主要なサービスに対応するテストファイルが含まれます。`test_tenant_api.py` が追加されました。\n\n## 4. ローカル開発環境セットアップ (Local Development Setup)\n\nバックエンドアプリケーションをローカル環境でセットアップし、実行するための手順です。\n\n### 前提条件\n-   Python 3.11 以降\n-   `pip` (Python パッケージインストーラ)\n-   Supabaseプロジェクト（詳細はプロジェクトルートのREADME.mdを参照し、セットアップ済みであること）\n-   (推奨) Python仮想環境 (`venv`, `conda` など)\n\n### セットアップ手順\n1.  **リポジトリのクローン** (まだの場合):\n    ```bash\n    # git clone <repository_url>\n    # cd <repository_name>/backend\n    # (リポジトリをクローン後、backendディレクトリに移動している想定で以降を記述)\n    ```\n\n2.  **(推奨) Python仮想環境の作成と有効化** (例: `backend` ディレクトリ内で):\n    ```bash\n    python -m venv venv\n    source venv/bin/activate  # Linux/macOS\n    # venv\\Scripts\\activate    # Windows (バックスラッシュをエスケープ)\n    ```\n\n3.  **依存関係のインストール**:\n    `backend` ディレクトリ直下で以下を実行します。\n    ```bash\n    pip install -r requirements.txt\n    ```\n\n4.  **`.env` ファイルの作成と設定**:\n    *   プロジェクトのルートディレクトリにある `.env.example` をコピーし、同じくプロジェクトルートに `.env` ファイルとして作成します。\n    *   `.env` ファイルを編集し、以下の必須環境変数を設定してください。\n        ```dotenv\n        SUPABASE_URL=\"YOUR_SUPABASE_PROJECT_URL\"\n        SUPABASE_SERVICE_ROLE_KEY=\"YOUR_SUPABASE_SERVICE_ROLE_KEY\"\n\n        # AI Agent用 (オプション)\n        # GEMINI_MODEL_NAME=\"gemini-1.5-flash-latest\" # config.pyにデフォルト値あり\n        # GOOGLE_API_KEY=\"YOUR_GOOGLE_API_KEY_IF_ADC_IS_NOT_SETUP\"\n\n        # --- Supabase Auth Settings (JWT検証に必須) ---\n        # SupabaseプロジェクトのJWKS URI (例: https://<project-ref>.supabase.co/auth/v1/.well-known/jwks.json)\n        SUPABASE_JWKS_URI=\"YOUR_SUPABASE_JWKS_URI\"\n        # Supabase JWTの期待されるAudience (通常 'authenticated')\n        SUPABASE_JWT_AUDIENCE=\"authenticated\"\n        # オプション: JWTのIssuerを明示的に設定する場合 (通常 SUPABASE_URL + \"/auth/v1\" から導出可能)\n        # SUPABASE_JWT_ISSUER=\"YOUR_SUPABASE_ISSUER_URL\"\n\n        # --- AI Agent Retry Settings (オプション、config.pyにデフォルト値あり) ---\n        # AI AgentのAPI呼び出しリトライ回数の最大値\n        # AI_AGENT_RETRY_ATTEMPTS=3\n        # リトライ時の初回待機秒数\n        # AI_AGENT_RETRY_WAIT_INITIAL_SECONDS=1\n        # リトライ時の最大待機秒数（指数バックオフ利用時）\n        # AI_AGENT_RETRY_WAIT_MAX_SECONDS=10\n        # 指数バックオフの乗数 (例: 1秒後, 2秒後, 4秒後...)\n        # AI_AGENT_RETRY_WAIT_MULTIPLIER=2\n        ```\n        `GEMINI_MODEL_NAME` およびAI Agentリトライ関連の設定は `config.py` でデフォルト値が設定されています。環境変数で上書き可能です。`GOOGLE_API_KEY` はApplication Default Credentials (ADC) が設定されていれば不要な場合があります。GA4関連のAPIキーと測定IDは、API経由でフォームごとにデータベースに設定します。\n\n5.  **データベーススキーマの適用**:\n    SupabaseプロジェクトのSQL Editorを使用して、以下のスキーマファイルを順番に実行し、必要なテーブルとカラムを作成します。\n    (注意: 実際のファイル名はプロジェクトに合わせて確認してください。ファイル名に含まれる番号はマイグレーションの推奨適用順序を示します。)\n    1.  `database/0001_tenants_schema.sql` (テナント管理用テーブル `tenants` 作成)\n    2.  `database/0002_user_profiles_schema.sql` (`public.users` プロファイルテーブル作成、`auth.users` と連携、`tenants` とのFK設定)\n    3.  `database/0003_contact_form_submissions_schema.sql` (旧 `contact_form_schema.sql` - 問い合わせ保存用テーブル `contact_submissions` 作成、`tenant_id` カラム追加とFK設定含む)\n    4.  `database/0004_form_ga_configurations_schema.sql` (旧 `form_ga_configurations_schema.sql` - フォームごとのGA4設定用テーブル `form_ga_configurations` 作成、`tenant_id` カラム追加とFK設定含む)\n    5.  以下のSQL (または各テーブル作成スキーマに統合されていることを確認) を実行して `contact_submissions` およびその他の関連テーブルに `updated_at` カラムと自動更新トリガーを追加:\n        ```sql\n        -- Add updated_at column and auto-update trigger to contact_submissions table (example)\n        ALTER TABLE contact_submissions\n        ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW();\n\n        COMMENT ON COLUMN contact_submissions.updated_at IS 'Timestamp of when this submission record was last updated.';\n\n        CREATE OR REPLACE FUNCTION update_contact_submissions_updated_at_column()\n        RETURNS TRIGGER AS $$\n        BEGIN\n            NEW.updated_at = NOW();\n            RETURN NEW;\n        END;\n        $$ language 'plpgsql';\n\n        CREATE TRIGGER trigger_update_contact_submissions_updated_at\n        BEFORE UPDATE ON contact_submissions\n        FOR EACH ROW\n        EXECUTE FUNCTION update_contact_submissions_updated_at_column();\n        ```\n        (同様のトリガーを `tenants`, `users`, `form_ga_configurations` にも設定することを推奨します。)\n\n6.  **開発サーバーの起動**:\n    プロジェクトのルートディレクトリから（または `PYTHONPATH` が適切に設定されていれば `backend` ディレクトリから）以下のコマンドを実行します。\n    ```bash\n    uvicorn backend.contact_api:app --reload --port 8000\n    ```\n    `--reload` オプションにより、コード変更時にサーバーが自動的に再起動します。\n\n7.  **APIドキュメントへのアクセス**:\n    サーバー起動後、ブラウザで http://localhost:8000/docs にアクセスすると、Swagger UIによるAPIドキュメントが表示され、各エンドポイントを試すことができます。 http://localhost:8000/redoc でもRedoc形式のドキュメントが確認できます。\n\n## 5. 認証・認可 (Authentication & Authorization)\n\nバックエンドAPIの保護されたエンドポイントへのアクセスには、JWT (JSON Web Token) を使用した認証が必要です。\n\n### 認証フロー\n1.  **ユーザー認証**: フロントエンドアプリケーションまたはクライアントは、Supabase Auth (例: `supabase-js`ライブラリ) を使用してユーザーのログイン処理を行います。\n2.  **JWT取得**: 認証成功後、Supabase AuthからJWT（アクセストークン）が発行されます。\n3.  **APIリクエスト**: 保護されたAPIエンドポイントへのリクエスト時、このJWTを `Authorization` HTTPヘッダーに `Bearer <token>` の形式で含めて送信します。\n\n### JWT検証 (バックエンド)\n-   バックエンド (`auth.py` モジュールの `get_current_active_user` 依存性注入関数内) は、受け取ったJWTを検証します。\n-   検証には、SupabaseプロジェクトのJWKS (JSON Web Key Set) URI (`SUPABASE_JWKS_URI` 環境変数で設定) から取得した公開鍵セットを使用します。\n-   JWTの署名、有効期限、発行者 (issuer - `SUPABASE_URL` から派生)、対象者 (audience - `SUPABASE_JWT_AUDIENCE` 環境変数で設定) が検証されます。\n-   検証成功後、トークン内のユーザーID (`sub` クレーム) を使用して、`public.users` テーブルからユーザープロファイル情報（`app_role`, `tenant_id` など）を取得します。\n-   これらの情報を含む `AuthenticatedUser` オブジェクトが、保護されたエンドポイント関数に注入されます。\n\n### ロールベースアクセス制御 (RBAC)\n-   **`app_role`**: ユーザープロファイルに格納されるロール（例: `user`, `admin`, `superuser`）。\n-   **`user` ロール**: 通常のテナントユーザー。自身のテナントに関連するデータ（フォーム設定、問い合わせデータなど）へのアクセスが許可されます。\n-   **`superuser` ロール**: システム管理者。テナント作成・管理など、システム全体に関わる操作が許可されます。\n-   各APIルーターまたは個別のエンドポイントで、必要なロールを持つユーザーのみがアクセスできるように制御されます（例: `tenant_router.py` の `require_superuser_role` 依存性）。\n\n## 6. APIエンドポイント詳細 (API Endpoints)\n\nバックエンドアプリケーションは以下の主要なAPIエンドポイントを提供します。\n詳細なリクエスト/レスポンスのスキーマやパラメータについては、サーバー起動後に `/docs` (Swagger UI) または `/redoc` (Redoc) でご確認ください。\n\n### 6.1. フォーム送信 (Form Submission)\n\n-   **`POST /submit`**\n    -   **説明**: フロントエンドウィジェットからのお問い合わせデータを受け付け、データベースに保存します。保存成功後、GA4が設定されていれば `generate_lead` イベントを送信します。\n    -   **認証**: 不要 (通常、公開エンドポイント)\n    -   **リクエストボディ例**:\n        ```json\n        {\n          \"name\": \"山田 太郎\",\n          \"email\": \"yamada.taro@example.com\",\n          \"message\": \"製品Aについて詳しく知りたいです。\",\n          \"tenant_id\": \"your-tenant-uuid-here\",\n          \"ga_client_id\": \"GA1.2.123456789.1678901234\",\n          \"ga_session_id\": \"1678901234\",\n          \"form_id\": \"product_inquiry_form\"\n        }\n        ```\n    -   **成功レスポンス例 (200 OK)**:\n        ```json\n        {\n          \"id\": 123,\n          \"created_at\": \"2024-03-15T10:30:00Z\",\n          \"name\": \"山田 太郎\",\n          \"email\": \"yamada.taro@example.com\",\n          \"message\": \"製品Aについて詳しく知りたいです。\",\n          \"tenant_id\": \"your-tenant-uuid-here\",\n          \"ga_client_id\": \"GA1.2.123456789.1678901234\",\n          \"ga_session_id\": \"1678901234\",\n          \"form_id\": \"product_inquiry_form\",\n          \"submission_status\": \"new\",\n          \"status_change_reason\": null,\n          \"updated_at\": \"2024-03-15T10:30:00Z\"\n        }\n        ```\n    -   **主なエラーステータス**:\n        -   `422 Unprocessable Entity`: リクエストボディのバリデーションエラー。\n        -   `503 Service Unavailable`: データベースクライアント未初期化など。\n        -   `500 Internal Server Error`: その他のサーバー内部エラー。\n\n### 6.2. AIチャット (AI Chat)\n\n-   **`POST /chat`**\n    -   **説明**: AIチャットボット（Geminiモデル）との対話メッセージを処理し、AIからの応答を返します。\n    -   **認証**: 不要 (通常、公開エンドポイント)\n    -   **リクエストボディ例**:\n        ```json\n        {\n          \"message\": \"このウィジェットの価格は？\",\n          \"session_id\": \"chat-session-789\"\n        }\n        ```\n    -   **成功レスポンス例 (200 OK)**:\n        ```json\n        {\n          \"reply\": \"価格については、料金ページをご覧ください...\",\n          \"session_id\": \"chat-session-789\",\n          \"require_form_after_message\": false\n        }\n        ```\n    -   **主なエラーステータス**:\n        -   `422 Unprocessable Entity`: リクエストボディのバリデーションエラー。\n        -   `500 Internal Server Error`: AIエージェント処理中のエラーなど。\n\n### 6.3. 問い合わせデータ一覧取得 (List Submissions)\n\n-   **`GET /api/v1/submissions`**\n    -   **説明**: 問い合わせデータの一覧を、指定されたフィルター条件、ページネーション、ソート順に基づいて取得します。\n    -   **認証**: 必要 (テナントユーザーは自身のテナントのデータのみアクセス可能)。\n    -   **クエリパラメータ**:\n        -   `form_id: Optional[str]` (フォームID)\n        -   `submission_status: Optional[str]` (ステータス)\n        -   `email: Optional[str]` (メールアドレス、部分一致)\n        -   `name: Optional[str]` (名前、部分一致)\n        -   `start_date: Optional[date]` (作成日範囲始点 YYYY-MM-DD)\n        -   `end_date: Optional[date]` (作成日範囲終点 YYYY-MM-DD)\n        -   `skip: int` (デフォルト `0`, 0以上)\n        -   `limit: int` (デフォルト `20`, 1以上100以下)\n        -   `sort_by: Optional[str]` (デフォルト `created_at`, Enum: `created_at`, `updated_at`, `name`, `submission_status`, `id`, `email`, `form_id`)\n        -   `sort_order: Optional[str]` (デフォルト `desc`, Enum: `asc`, `desc`)\n    -   **成功レスポンス例 (200 OK)**:\n        ```json\n        {\n          \"submissions\": [\n            {\n              \"id\": 123,\n              \"created_at\": \"2024-03-15T10:30:00Z\",\n              \"name\": \"山田 太郎\",\n              \"email\": \"yamada.taro@example.com\",\n              \"message\": \"製品Aについて詳しく知りたいです。\",\n              \"tenant_id\": \"your-tenant-uuid-here\",\n              \"ga_client_id\": \"GA1.2.123456789.1678901234\",\n              \"ga_session_id\": \"1678901234\",\n              \"form_id\": \"product_inquiry_form\",\n              \"submission_status\": \"new\",\n              \"status_change_reason\": null,\n              \"updated_at\": \"2024-03-15T10:30:00Z\"\n            }\n          ],\n          \"total_count\": 1,\n          \"skip\": 0,\n          \"limit\": 20\n        }\n        ```\n    -   **主なエラーステータス**:\n        -   `403 Forbidden`: ユーザーがテナントに紐付いていない場合。\n        -   `422 Unprocessable Entity`: クエリパラメータのバリデーションエラー。\n        -   `503 Service Unavailable`: データベースクライアント未初期化など。\n        -   `500 Internal Server Error`: その他のサーバー内部エラー。\n\n### 6.4. GA4設定管理 (GA4 Form Configurations)\n\nこれらのエンドポイントは、テナント内のフォームごとのGA4測定IDとAPIシークレットを管理します。\n**認証**: 必要 (テナントユーザーは自身のテナントの設定のみ管理可能)。\n\n-   **`POST /api/v1/ga_configurations/{form_id}`**:\n    -   **説明**: 指定された `form_id` に対して新しいGA4設定を登録します。\n    -   **成功レスポンス (201 Created)**: 作成されたGA4設定情報。\n    -   **主なエラーステータス**: `409 Conflict` (指定`form_id`が既に存在する場合), `403`, `422`, `500`, `503`。\n\n-   **`GET /api/v1/ga_configurations`**:\n    -   **説明**: 認証ユーザーのテナントに登録されている全てのフォームGA4設定をリストします（ページネーション対応: `skip`, `limit` クエリパラメータ）。\n    -   **成功レスポンス (200 OK)**: GA4設定のリスト。\n\n-   **`GET /api/v1/ga_configurations/{form_id}`**:\n    -   **説明**: 指定された `form_id` のGA4設定を取得します。\n    -   **成功レスポンス (200 OK)**:該当するGA4設定情報。\n    -   **主なエラーステータス**: `404 Not Found`。\n\n-   **`PUT /api/v1/ga_configurations/{form_id}`**:\n    -   **説明**: 指定された `form_id` のGA4設定を更新します。\n    -   **成功レスポンス (200 OK)**: 更新されたGA4設定情報。\n    -   **主なエラーステータス**: `404 Not Found`, `422`, `500`, `503`。\n\n-   **`DELETE /api/v1/ga_configurations/{form_id}`**:\n    -   **説明**: 指定された `form_id` のGA4設定を削除します。\n    -   **成功レスポンス (204 No Content)**。\n    -   **主なエラーステータス**: `404 Not Found`。\n\n### 6.5. 問い合わせステータス更新 (Submission Status Update)\n\n-   **`PATCH /api/v1/submissions/{submission_id}/status`**\n    -   **説明**: 指定された問い合わせ (`submission_id`) のステータス (`submission_status`と任意で`status_change_reason`) を更新します。ステータス変更に応じて、GA4イベントが送信されます。\n    -   **認証**: 必要 (ユーザーは自身のテナント内の問い合わせのみ更新可能)。\n    -   **リクエストボディ例**:\n        ```json\n        {\n          \"new_status\": \"converted\",\n          \"reason\": \"Lead successfully closed.\"\n        }\n        ```\n    -   **成功レスポンス例 (200 OK)**: 更新された問い合わせレコード全体。\n    -   **主なエラーステータス**: `404 Not Found` (submission_idが見つからない、または他テナントのデータ), `403`, `422`, `500`, `503`。\n\n### 6.6. テナント管理 (Tenant Management - Superuser Only)\n-   **`POST /api/v1/tenants`**: 新規テナント作成。\n-   **`GET /api/v1/tenants`**: テナント一覧取得。\n-   **`GET /api/v1/tenants/{tenant_id}`**: 特定テナント情報取得。\n-   **`PUT /api/v1/tenants/{tenant_id}`**: テナント情報更新。\n-   **`DELETE /api/v1/tenants/{tenant_id}`**: テナント削除（論理/物理）。\n    -   **認証**: スーパーユーザーのみ（`require_superuser_role` 依存性により実施）。\n\n## 7. データベーススキーマ概要 (Database Schema Overview)\n\nバックエンドはSupabase (PostgreSQL) データベースを使用します。主要なテーブルは以下の通りです。\n詳細なスキーマ定義はプロジェクトルートの `database/` ディレクトリ内の各SQLファイルを参照してください（ファイル名に注意し、マイグレーション順序に従ってください）。\n\n-   **`tenants`**:\n    -   **説明**: 各テナント（クライアント企業）の情報を格納します。`tenant_id` (UUID) が主キーです。\n    -   **スキーマファイル**: `database/0001_tenants_schema.sql` (または同等の内容を含むファイル)\n    -   **主要カラム**: `tenant_id`, `company_name`, `domain`, `is_deleted`, `created_at`, `updated_at`。\n\n-   **`users` (in `public` schema, linked to `auth.users`)**:\n    -   **説明**: アプリケーションユーザーのプロファイル情報。Supabaseの `auth.users` テーブルのレコードと `id` (UUID) で1対1に対応します。ユーザーは特定のテナントに所属し、アプリケーション固有のロール（`app_role`）を持ちます。\n    -   **スキーマファイル**: `database/0002_user_profiles_schema.sql` (または同等の内容を含むファイル)\n    -   **主要カラム**: `id` (FK to `auth.users.id`), `app_role` (`user`, `superuser`など), `tenant_id` (FK to `public.tenants.tenant_id`), `full_name`, `created_at`, `updated_at`。\n\n-   **`contact_submissions`**:\n    -   **説明**: お問い合わせフォームから送信されたデータをテナントごとに保存します。`tenant_id` カラムでテナントに紐付けられます。\n    -   **スキーマファイル**: `database/0003_contact_form_submissions_schema.sql` (または同等の内容を含むファイル、`tenant_id` 追加済みであること)\n    -   **主要カラム**: `id`, `created_at`, `updated_at`, `name`, `email`, `message`, `ga_client_id`, `ga_session_id`, `form_id`, `submission_status`, `status_change_reason`, `tenant_id`。\n\n-   **`form_ga_configurations`**:\n    -   **説明**: テナント内のフォームごとのGoogle Analytics 4 Measurement Protocol設定を保存します。`tenant_id` と `form_id` の複合主キーで管理されます。\n    -   **スキーマファイル**: `database/0004_form_ga_configurations_schema.sql` (または同等の内容を含むファイル、`tenant_id` 追加済みであること)\n    -   **主要カラム**: `tenant_id`, `form_id`, `ga4_measurement_id`, `ga4_api_secret`, `description`, `created_at`, `updated_at`。\n\n## 8. Google Analytics 4 (GA4) 連携 (GA4 Integration)\n\nこのバックエンドは、GA4のMeasurement Protocol (v2) を使用して、リードジェネレーションに関連するイベントをGoogle Analyticsに送信します。各テナントは自身のGA4プロパティと連携できます。\n\n### 設定方法\n1.  **GA4プロパティでの準備**: GA4プロパティで「測定ID」と「APIシークレット」を取得します。\n2.  **バックエンドへの設定登録**: `/api/v1/ga_configurations` エンドポイント（「6.4. GA4設定管理」参照）を使用して、テナント内のフォームごと (`form_id` 単位) に取得した測定IDとAPIシークレットを登録します。\n\n### 送信される主要イベント\n-   **`generate_lead`**:\n    -   **トリガー**: `/submit` エンドポイントでフォーム送信が正常に処理された際。\n    -   **主なパラメータ**: `client_id`, `session_id` (フォームから提供された場合), `form_id` (カスタムパラメータ `event_label` として), `event_category: "contact_form"`。\n-   **ステータス変更連動イベント**: `/api/v1/submissions/{submission_id}/status` エンドポイントで問い合わせステータスが変更された際。\n    -   `contacted` 時: `working_lead` (パラメータ `lead_status: "contacted"`)
    -   `qualified` 時: `qualify_lead`
    -   `converted` 時: `close_convert_lead` (パラメータ `transaction_id` に `submission_id` を使用)
    -   `unconverted` 時: `lead_unconverted` (カスタムイベント)
    -   `disqualified` 時: `lead_disqualified` (カスタムイベント)
    -   これらのイベントにも `client_id`, `session_id`, `form_id` などの関連情報が付与されます。

全てのイベントには、固定値として `value: 0`, `currency: "JPY"` が設定されます。
イベント送信処理は `backend/services/ga4_mp_service.py` の `send_ga4_event` 関数が担当します。

## 9. テスト (Testing)

バックエンドのユニットテストおよび結合テストは `pytest` を使用して実行します。

### テストの実行
1.  上記「ローカル開発環境セットアップ」が完了していることを確認してください。
2.  `pytest` が `requirements.txt` に含まれており、インストールされていることを確認してください。
3.  プロジェクトのルートディレクトリで以下のコマンドを実行します。
    ```bash
    pytest backend/tests/
    ```
    または、特定のテストファイルのみを実行する場合:
    ```bash
    pytest backend/tests/test_contact_api.py
    pytest backend/tests/test_form_ga_config_api.py
    pytest backend/tests/test_submission_api.py
    pytest backend/tests/test_ai_agent.py
    pytest backend/tests/test_tenant_api.py
    ```

### テストファイルの場所
テストコードは `backend/tests/` ディレクトリに配置されています。

-   `test_contact_api.py`: `/submit`, `/chat` エンドポイントおよび関連機能のテスト。
-   `test_form_ga_config_api.py`: GA4設定管理API (`/api/v1/ga_configurations/...`) のテスト。
-   `test_submission_api.py`: 問い合わせステータス更新API (`/api/v1/submissions/.../status`) および一覧取得APIのテスト。
-   `test_ai_agent.py`: AI Agentの応答生成ロジック（リトライ処理含む）のテスト。
-   `test_tenant_api.py`: テナント管理API (`/api/v1/tenants/...`) のテスト。

テストは、サービス層のロジックや外部依存（Supabaseクライアントなど）をモックして、各コンポーネントの動作を独立して検証することに主眼を置いています。

## 10. その他 (Miscellaneous)

-   (現時点では特記事項なし)

```

[end of backend/README.md]

[start of backend/ai_agent.py]
from typing import Optional, Tuple
import json # Added json import
import logging # Added logging
from pydantic import BaseModel, Field
from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type, before_sleep_log # Added tenacity
from .config import settings # Added

logger = logging.getLogger(__name__) # Initialized logger

ADK_IMPORTED_SUCCESSFULLY = False
AGENT_INITIALIZED_SUCCESSFULLY = False # New flag

# Attempt to import ADK components. Handle gracefully if not available.
try:
    from google.adk.agents import LlmAgent
    from google.adk.runners import InMemoryRunner
    from google.adk.events import Event
    ADK_IMPORTED_SUCCESSFULLY = True
    logger.debug("ADK components imported successfully.")
except ImportError as e:
    logger.error("Failed to import ADK components: %s. AI Agent will not be available.", e, exc_info=True)
    # Dummy ADK class definitions are below and will be used.
    pass

# --- Pydantic Model for Structured Agent Response ---
class AgentStructuredResponse(BaseModel):
    message: str = Field(description="The chat message response from the AI agent.")
    require_form_after_message: bool = Field(
        description="Indicates if the frontend should suggest or display a contact form after this message."
    )

class LlmAgent:
        def __init__(self, *args, **kwargs):
            # This print is in a dummy class, potentially keep as is or change to logger.warning
            # For now, let's assume these dummy classes' prints are for very specific non-ADK scenarios
            print("WARNING: google-adk-python not installed. AI Agent will not function.")
            pass
    class InMemoryRunner:
        def __init__(self, *args, **kwargs):
            pass
        def run(self, *args, **kwargs) -> 'Event': # type: ignore
            return Event(error_message="ADK components not available. Please install google-adk-python.") # type: ignore
    class Event: # type: ignore
        def __init__(self, error_message: Optional[str] = None):
            self.actions = []
            self.error_message = error_message
            self.session_id = None


# Configure your Google Cloud project and credentials if necessary.
# For Gemini, ensure API keys or ADC (Application Default Credentials) are set up.
# You might need to set GOOGLE_API_KEY environment variable if not using ADC.
# The ADK library should pick up Application Default Credentials automatically if set up.

GEMINI_MODEL_NAME = settings.gemini_model_name
# The GOOGLE_API_KEY is expected to be sourced by the ADK from the environment variables
# (which pydantic-settings helps load from .env) or via ADC.
# We log if it's explicitly set via our application settings, for awareness.
if settings.google_api_key:
    logger.info("Application settings include a GOOGLE_API_KEY.")
else:
    logger.info("GOOGLE_API_KEY is not set in application settings. ADK will rely on ADC or an externally set GOOGLE_API_KEY environment variable.")

# Generate JSON schema string for the agent's structured response
AGENT_RESPONSE_JSON_SCHEMA = json.dumps(AgentStructuredResponse.model_json_schema(), indent=2)

chat_agent = None
agent_runner = None

if ADK_IMPORTED_SUCCESSFULLY:
    try:
        chat_agent = LlmAgent(
            name="structured_chat_agent", # Renamed for clarity
            model=GEMINI_MODEL_NAME,
            instruction=f"""You are a highly intelligent and helpful AI assistant for 'Contact Form Widget Corp'.
Your primary role is to answer user questions about our company, our innovative contact form widgets, related whitepapers, and product information.
You MUST always respond with a JSON object that strictly adheres to the following JSON schema:
```json
{AGENT_RESPONSE_JSON_SCHEMA}
```

Here's how to determine the values for the JSON fields:
- `message`: This field should contain your textual response to the user. Be helpful, concise, and informative.
- `require_form_after_message`: This boolean field determines if the user should be prompted with a contact form or a specific call to action after your message.
    - Set this to `true` if the conversation indicates a strong user interest in our products or services, if they are asking for quotes, detailed product comparisons, or if they seem like a qualified lead ready for the next step. For example, if they ask 'How can I get this widget for my site?' or 'Can you tell me the pricing for enterprise users?'.
    - When setting to `true`, the `message` field should naturally lead to this suggestion. For example: 'That's a great question! For detailed pricing and to discuss your specific needs, I recommend reaching out to our sales team. Would you like me to show you a form to contact them?' or 'Our 'Pro Widget X' seems like a perfect fit for your requirements. You can find more details and a purchase link here: [link]. I can also help you get in touch with our team if you'd like.'
    - In all other cases, or if you are unsure, set `require_form_after_message` to `false`. This includes general inquiries, requests for information you can provide directly, or if the user is not yet showing strong buying signals.
You are an expert in our products and aim to guide users effectively.
""",
        output_schema=AgentStructuredResponse, # Pass the Pydantic model here
        # tools=[] # Explicitly no tools, as output_schema disables them
        )
        agent_runner = InMemoryRunner(agent=chat_agent)
        AGENT_INITIALIZED_SUCCESSFULLY = True
        logger.info("AI Agent initialized successfully.")
    except Exception as e:
        logger.error("Failed to initialize LlmAgent or InMemoryRunner: %s. AI Agent will not be functional.", e, exc_info=True)
        chat_agent = None # Ensure they are None if init fails
        agent_runner = None
        # AGENT_INITIALIZED_SUCCESSFULLY remains False
else:
    logger.warning("ADK components not imported. AI Agent initialization will be skipped.")
    chat_agent = None
    agent_runner = None

@retry(
    stop=stop_after_attempt(settings.ai_agent_retry_attempts),
    wait=wait_exponential(
        multiplier=settings.ai_agent_retry_wait_multiplier,
        min=settings.ai_agent_retry_wait_initial_seconds,
        max=settings.ai_agent_retry_wait_max_seconds
    ),
    retry=retry_if_exception_type(Exception), # Consider refining this later
    before_sleep=before_sleep_log(logger, logging.WARNING) # Log before retrying
)
async def get_chat_response(message: str, session_id: Optional[str] = None) -> Tuple[str, Optional[str], bool]:
    """
    Gets a chat response from the AI agent, with retry logic.
    Returns:
        Tuple[str, Optional[str], bool]: (reply_message, session_id, require_form_flag)
    """
    # Changed level to debug and improved message snippet handling
    logger.debug(
        "get_chat_response called with session_id: %s, message_snippet: %s",
        session_id,
        message[:80] + "..." if message and len(message) > 80 else message
    )

    # Input Validation for 'message'
    if not message or not message.strip():
        logger.warning(
            "Input validation failed for get_chat_response: message is empty or consists only of whitespace. Session_id: %s",
            session_id
        )
        return "Message cannot be empty. Please provide a valid message.", session_id, False

    if not AGENT_INITIALIZED_SUCCESSFULLY:
        fallback_message = ""
        if not ADK_IMPORTED_SUCCESSFULLY:
            fallback_message = "AI Agent is unavailable due to missing dependencies. Please check server logs."
            logger.debug("Serving fallback because ADK components not imported.")
        else:
            # This means ADK was imported, but LlmAgent/InMemoryRunner initialization failed
            fallback_message = "AI Agent is currently experiencing setup issues. Please try again later or contact support."
            logger.debug("Serving fallback because AI Agent failed to initialize.")
        return fallback_message, session_id, False

    if agent_runner is None:
        logger.error("agent_runner is None despite AGENT_INITIALIZED_SUCCESSFULLY being true. This indicates a logic flaw.", exc_info=True)
        return "AI Agent is unexpectedly unavailable. Please contact support.", session_id, False

    reply = "[No response from agent or empty response]" # Default reply
    require_form = False # Default value
    response_session_id = session_id # Default to passed-in session_id

    try:
        # Assuming agent_runner.run() is synchronous.
        # If it were async, it would be `await agent_runner.run_async(...)`.
        # For a sync call in an async def, to avoid blocking, it should ideally be:
        # from fastapi.concurrency import run_in_threadpool
        # event: Event = await run_in_threadpool(agent_runner.run, request=message, session_id=session_id)
        # However, for this subtask, we apply tenacity as requested, assuming direct call first.
        logger.debug(f"Calling agent_runner.run for session_id: {session_id}")
        event: Event = agent_runner.run(request=message, session_id=session_id) # Synchronous call
        logger.debug(f"agent_runner.run completed for session_id: {session_id}")

        # Process the event
        require_form = False # Default value
        response_session_id = session_id # Default to passed-in session_id

        if event.error_message:
            logger.error("Agent event returned error_message: %s", event.error_message)
            reply = f"[Agent Error: {event.error_message}]"
        elif event.actions and event.actions[0].parts:
            action_part = event.actions[0].parts[0]
            if hasattr(action_part, 'text') and action_part.text:
                raw_agent_text = action_part.text
                try:
                    structured_response_data = json.loads(raw_agent_text)
                    parsed_response = AgentStructuredResponse(**structured_response_data)
                    reply = parsed_response.message
                    require_form = parsed_response.require_form_after_message
                except json.JSONDecodeError as jde:
                    logger.error("Failed to decode JSON response from agent. Text was: %s", raw_agent_text, exc_info=True)
                    reply = "[Agent Error: Failed to decode JSON response]"
                except Exception as pydantic_error: # Catch Pydantic validation errors
                    logger.error("Invalid JSON structure from agent. Text was: %s Error: %s", raw_agent_text, pydantic_error, exc_info=True)
                    reply = f"[Agent Error: Invalid JSON structure]"
            else:
                logger.warning("Agent produced no actionable text output. Event details: %s", event)
                reply = "[Agent produced no actionable text output]"
        else:
            logger.warning("Agent event had no error_message and no actionable parts. Event details: %s", event)
            # reply remains "[No response from agent or empty response]"

        if hasattr(event, 'session_id') and event.session_id:
            response_session_id = event.session_id

        logger.debug(
            "Successfully processed AI event. Returning chat response. Session_id: %s, require_form: %s, reply snippet: %.80s",
            response_session_id, require_form, reply
        )
        return reply, response_session_id, require_form

    except Exception as e: # This will catch exceptions if all retries by tenacity fail OR from event processing logic
        logger.error(
            "AI Agent call failed after %s attempts (or error in response processing) for session_id %s: %s",
            settings.ai_agent_retry_attempts,
            session_id,
            e,
            exc_info=True
        )
        # Return a generic error message, specific details are in logs
        return f"[AI Agent Error after retries or processing error: consult logs for details]", session_id, False

# Example of how you might test this function directly (requires ADK and auth)
if __name__ == '__main__':
    if AGENT_INITIALIZED_SUCCESSFULLY: # Check if agent is ready for testing
        print("Testing AI Agent locally (ensure GOOGLE_API_KEY or ADC is set up)...")
        # Test 1: Simple message
        test_message = "Hello, how are you?"
        test_session_id = "local_test_session_123"

        print(f"\nSending message: '{test_message}' with session_id: '{test_session_id}'")
        reply_text, returned_session_id, require_form = get_chat_response(test_message, test_session_id)
        print(f"  Agent Reply: {reply_text}")
        print(f"  Returned Session ID: {returned_session_id}")
        print(f"  Require Form: {require_form}")

        # Test 2: Message without session_id
        test_message_2 = "What's the weather like?"
        print(f"\nSending message: '{test_message_2}' with no session_id")
        reply_text_2, returned_session_id_2, require_form_2 = get_chat_response(test_message_2)
        print(f"  Agent Reply: {reply_text_2}")
        print(f"  Returned Session ID: {returned_session_id_2}")
        print(f"  Require Form: {require_form_2}")

        # Test 3: Potentially problematic (empty message, though ADK might handle it)
        # test_message_3 = ""
        # print(f"\nSending message: '{test_message_3}'")
        # reply_text_3, returned_session_id_3, require_form_3 = get_chat_response(test_message_3)
        # print(f"  Agent Reply: {reply_text_3}")
        # print(f"  Returned Session ID: {returned_session_id_3}")
        # print(f"  Require Form: {require_form_3}")
    elif not ADK_IMPORTED_SUCCESSFULLY:
        print("ADK components not imported. Cannot run local test.")
        reply, sid, req_form = get_chat_response("test message if ADK components not imported")
        print(f"Reply: '{reply}', Session ID: {sid}, Require Form: {req_form}")
    else: # ADK imported but agent not initialized
        print("AI Agent failed to initialize. Cannot run local test.")
        reply, sid, req_form = get_chat_response("test message if AI agent failed to initialize")
        print(f"Reply: '{reply}', Session ID: {sid}, Require Form: {req_form}")

[end of backend/ai_agent.py]

[start of backend/auth.py]
# backend/auth.py
import httpx
import logging
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from jose import JWTError, jwt
from pydantic import BaseModel, ConfigDict, Field
from typing import Optional, Dict, Any, List
from datetime import datetime, timedelta # Added timedelta

from backend.config import settings
from backend.db import get_supabase_client # Supabase client for DB access
from supabase import Client # Type hint for Supabase client

logger = logging.getLogger(__name__)

# --- Pydantic Model for Authenticated User ---
class AuthenticatedUser(BaseModel):
    id: str # UUID from Supabase auth.users.id
    app_role: str
    tenant_id: Optional[str] = None # UUID, as string
    email: Optional[str] = None
    full_name: Optional[str] = None

    # Pydantic V2 config
    model_config = ConfigDict(from_attributes=True)

http_bearer_scheme = HTTPBearer(
    description="Supabase JWT token. Obtain it from Supabase Auth client (e.g., supabase-js after login).",
    bearerFormat="JWT" # OpenAPI: format of the bearer token
)

# --- JWKS (JSON Web Key Set) Caching ---
_jwks_cache: Optional[Dict[str, Any]] = None
_jwks_cache_expiry: Optional[datetime] = None
JWKS_CACHE_TTL_SECONDS = 3600 # Cache JWKS for 1 hour

async def get_jwks() -> Dict[str, Any]:
    global _jwks_cache, _jwks_cache_expiry
    now = datetime.utcnow()

    if _jwks_cache and _jwks_cache_expiry and now < _jwks_cache_expiry:
        logger.debug("Using cached JWKS.")
        return _jwks_cache

    if not settings.supabase_jwks_uri:
        logger.error("Supabase JWKS URI is not configured in settings.")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Authentication system not configured (JWKS URI missing)."
        )

    logger.info(f"Fetching JWKS from: {settings.supabase_jwks_uri}")
    async with httpx.AsyncClient(timeout=10.0) as client:
        try:
            response = await client.get(settings.supabase_jwks_uri)
            response.raise_for_status() # Raises HTTPStatusError for 4xx/5xx responses
            _jwks_cache = response.json()
            _jwks_cache_expiry = now + timedelta(seconds=JWKS_CACHE_TTL_SECONDS)
            logger.info("Successfully fetched and cached JWKS.")
            return _jwks_cache
        except httpx.HTTPStatusError as e:
            logger.error(f"HTTP error fetching JWKS: {e.response.status_code} - {e.response.text}", exc_info=True)
            raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail=f"Failed to fetch JWKS: HTTP {e.response.status_code}")
        except Exception as e: # Includes JSONDecodeError, httpx.RequestError, etc.
            logger.error(f"Failed to fetch or parse JWKS: {e}", exc_info=True)
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Failed to process JWKS: {str(e)}")

async def get_current_active_user(
    auth_creds: HTTPAuthorizationCredentials = Depends(http_bearer_scheme), # Gets Bearer token
    supabase_db: Client = Depends(get_supabase_client) # Renamed to avoid clash with 'supabase' var name
) -> AuthenticatedUser:

    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials or token is invalid/expired.",
        headers={"WWW-Authenticate": "Bearer"},
    )

    token = auth_creds.credentials # The actual token string

    try:
        jwks = await get_jwks()
        unverified_header = jwt.get_unverified_header(token)
        rsa_key = {}
        for key_dict in jwks.get("keys", []): # Added .get with default
            if key_dict.get("kid") == unverified_header.get("kid"): # Added .get
                rsa_key = {
                    "kty": key_dict["kty"], "kid": key_dict["kid"],
                    "use": key_dict["use"], "n": key_dict["n"], "e": key_dict["e"]
                }
                break
        if not rsa_key:
            logger.warning("JWT KID in token header does not match any key in JWKS.")
            raise credentials_exception

        if not settings.supabase_url:
            logger.error("Supabase URL for JWT issuer validation is not configured.")
            raise HTTPException(status_code=500, detail="Auth system config error (issuer URL).")

        expected_issuer = settings.supabase_url + "/auth/v1"

        payload = jwt.decode(
            token,
            rsa_key,
            algorithms=["RS256"],
            audience=settings.supabase_jwt_audience,
            issuer=expected_issuer
        )

        user_id: Optional[str] = payload.get("sub")
        email_from_jwt: Optional[str] = payload.get("email")
        # Supabase default role for authenticated users
        # auth_role_from_jwt: Optional[str] = payload.get("role")

        if user_id is None:
            logger.warning("User ID (sub) not found in JWT payload.")
            raise credentials_exception

    except JWTError as e:
        logger.warning(f"JWT validation/decoding error: {e}", exc_info=True)
        raise credentials_exception
    except HTTPException: # Re-raise HTTPExceptions from get_jwks or config checks
        raise
    except Exception as e: # Catch any other unexpected error during JWT processing
        logger.error(f"Unexpected error during JWT processing: {e}", exc_info=True)
        raise credentials_exception # Treat as validation failure

    # Fetch app-specific user profile from public.users
    if supabase_db is None:
        logger.error("Supabase client (supabase_db) unavailable for fetching user profile.")
        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail="Database client unavailable for user profile.")

    try:
        profile_response = supabase_db.table("users").select("app_role, tenant_id, full_name").eq("id", user_id).maybe_single().execute()

        user_profile = profile_response.data
        if not user_profile:
            logger.warning(f"User profile not found in public.users for user_id: {user_id}. A profile should be created automatically on new user signup.")
            # Depending on policy, could create a default user object here or deny access.
            # For now, deny access if no profile, as tenant_id and app_role are crucial.
            raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="User profile incomplete or not found.")

    except Exception as e:
        logger.error(f"Database error fetching user profile for user_id {user_id}: {e}", exc_info=True)
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Could not fetch user profile details.")

    return AuthenticatedUser(
        id=user_id,
        app_role=user_profile.get("app_role", "user"), # Default to 'user' if somehow missing
        tenant_id=str(user_profile.get("tenant_id")) if user_profile.get("tenant_id") else None,
        email=email_from_jwt, # Email from JWT is generally more reliable/verified
        full_name=user_profile.get("full_name")
    )

[end of backend/auth.py]

[start of backend/config.py]
from pydantic_settings import BaseSettings, SettingsConfigDict
from typing import Optional

class Settings(BaseSettings):
    # AI Agent Settings
    # The default value will be used if the environment variable is not set.
    gemini_model_name: str = "gemini-1.5-flash-latest"

    # API key is optional at this level.
    # Code using this setting should handle the case where it might be None.
    google_api_key: Optional[str] = None

    # Supabase Connection Settings
    supabase_url: Optional[str] = None
    supabase_service_role_key: Optional[str] = None

    # Supabase Auth Settings
    supabase_jwks_uri: Optional[str] = None
    supabase_jwt_audience: str = "authenticated" # Default value
    # supabase_jwt_issuer: Optional[str] = None # Optional: if not set, can be derived from supabase_url

    # AI Agent Retry Settings
    ai_agent_retry_attempts: int = 3
    ai_agent_retry_wait_initial_seconds: int = 1
    ai_agent_retry_wait_max_seconds: int = 10
    ai_agent_retry_wait_multiplier: int = 2

    # Configuration for loading from .env file
    # This uses Pydantic V2 (pydantic-settings) style.
    # For Pydantic V1, you would use:
    # class Config:
    #     env_file = ".env"
    #     env_file_encoding = 'utf-8'
    #     extra = 'ignore' # Allow extra fields in the .env file
    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding='utf-8',
        extra='ignore' # 'extra' allows other environment variables to exist without causing validation errors
    )

# Create a single, importable instance of the settings.
# Other parts of the application will import this instance.
settings = Settings()

# Example of how to use this in other modules:
#
# from backend.config import settings
#
# def some_function():
#     model = settings.gemini_model_name
#     api_key = settings.google_api_key
#     if api_key:
#         print(f"Using API Key: {api_key[:5]}...") # Be careful with logging API keys
#     else:
#         print("Google API Key is not set.")
#     print(f"Using Gemini Model: {model}")

[end of backend/config.py]

[start of backend/contact_api.py]
from fastapi import FastAPI, Depends, HTTPException, status # Added Depends, HTTPException, status
from pydantic import BaseModel, ConfigDict # Added ConfigDict
from fastapi.middleware.cors import CORSMiddleware
import logging
from typing import List, Optional, Any # Ensure List, Optional, Any are imported
from datetime import date, datetime # Ensure date and datetime are imported
# Removed: from sqlalchemy.orm import Session
from supabase import Client # Add this import

# Import the AI agent module
from . import ai_agent
from .config import settings # Ensure settings is imported if used directly
from .db import get_supabase_client # Add this import for the new dependency
from .routers import form_ga_config_router, submission_router, tenant_router # Added tenant_router import
from .services import form_ga_config_service # Added import
from .services import ga4_mp_service # Added import
from .auth import get_current_active_user # Added import for new auth

# Configure basic logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(title="Contact Form API with Chat", version="0.2.0")

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["POST", "GET", "OPTIONS"],
    allow_headers=["*"],
)

# --- Models for /submit endpoint ---
class ContactFormPayload(BaseModel):
    name: str
    email: str
    message: str
    tenant_id: str # Added
    ga_client_id: Optional[str] = None
    ga_session_id: Optional[str] = None
    form_id: Optional[str] = None # Added

class SubmissionResponse(BaseModel): # Newly added
    id: int
    created_at: datetime
    name: str
    email: str
    message: str
    tenant_id: str # Added
    ga_client_id: Optional[str] = None
    ga_session_id: Optional[str] = None
    form_id: Optional[str] = None
    submission_status: Optional[str] = None # Assuming this comes from DB
    status_change_reason: Optional[str] = None # Assuming this comes from DB
    updated_at: Optional[datetime] = None # Assuming this comes from DB

    model_config = ConfigDict(from_attributes=True) # Added for consistency/ORM mode

# --- Models for /chat endpoint ---
class ChatMessage(BaseModel):
    message: str
    session_id: Optional[str] = None

class ChatResponse(BaseModel):
    reply: str
    session_id: Optional[str] = None
    require_form_after_message: bool = False # New field

# --- API Endpoints ---

@app.post("/submit", response_model=SubmissionResponse) # Ensure SubmissionResponse is imported
async def handle_form_submission(
    payload: ContactFormPayload,
    supabase: Optional[Client] = Depends(get_supabase_client)
):
    logger.info(f"Received form submission: {payload.model_dump_json()}") # Use model_dump_json for logging Pydantic V2

    if supabase is None:
        logger.error("Supabase client not available for /submit endpoint.")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Database service is currently unavailable. Please try again later."
        )

    try:
        # For Pydantic V2, use model_dump. For V1, use dict.
        # Assuming Pydantic V2 based on pydantic-settings usage earlier.
        data_to_insert = payload.model_dump(exclude_unset=False)

        # Supabase insert expects a list of dicts, even for a single record
        response = supabase.table("contact_submissions").insert([data_to_insert]).execute()

        if response.data and len(response.data) > 0:
            inserted_record = response.data[0]
            logger.info(f"Successfully inserted submission. ID: {inserted_record.get('id')}")

            # --- GA4 generate_lead イベント送信 ---
            if payload.tenant_id and payload.form_id and payload.ga_client_id: # Added tenant_id check
                try:
                    ga_config_dict = form_ga_config_service.get_ga_configuration(
                        supabase,
                        tenant_id=payload.tenant_id, # Pass tenant_id
                        form_id=payload.form_id
                    )
                    if ga_config_dict:
                        api_secret = ga_config_dict.get("ga4_api_secret")
                        measurement_id = ga_config_dict.get("ga4_measurement_id")

                        if api_secret and measurement_id:
                            event_params = {
                                "event_category": "contact_form",
                                "event_label": payload.form_id,
                            }
                            if payload.ga_session_id:
                                event_params["session_id"] = payload.ga_session_id

                            event_params["value"] = 0  # Added
                            event_params["currency"] = "JPY" # Added

                            ga4_event = {"name": "generate_lead", "params": event_params}

                            logger.info(f"Attempting to send generate_lead event to GA4 for form_id: {payload.form_id}, client_id: {payload.ga_client_id}")
                            ga_sent_successfully = await ga4_mp_service.send_ga4_event(
                                api_secret=api_secret,
                                measurement_id=measurement_id,
                                client_id=payload.ga_client_id,
                                events=[ga4_event]
                            )
                            if not ga_sent_successfully:
                                logger.warning(f"generate_lead event sending to GA4 may have failed for form_id: {payload.form_id} (see previous logs from ga4_mp_service).")
                        else:
                            logger.warning(f"GA4 API secret or Measurement ID missing in config for form_id '{payload.form_id}'. Cannot send generate_lead event.")
                    else:
                        logger.warning(f"GA4 configuration not found for tenant_id '{payload.tenant_id}', form_id '{payload.form_id}'. Cannot send generate_lead event.")
                except Exception as e_ga_setup: # Catch errors during GA config fetch or event construction
                    logger.error(f"Error during GA4 event preparation for generate_lead (tenant_id: {payload.tenant_id}, form_id: {payload.form_id}): {e_ga_setup}", exc_info=True)
            else:
                logger.info("Skipping GA4 generate_lead event: tenant_id, form_id or ga_client_id missing from payload for submission ID: %s.", inserted_record.get('id'))
            # --- GA4 イベント送信ここまで ---

            return SubmissionResponse(**inserted_record)
        else:
            # Log the actual response from Supabase for debugging
            logger.error(
                "Supabase insert operation did not return data as expected. Full response: %s",
                response.model_dump_json() if hasattr(response, 'model_dump_json') else str(response)
            )
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to save submission: No data returned from database operation."
            )

    except HTTPException: # Re-raise HTTPExceptions directly
        raise
    except Exception as e:
        logger.error(f"Error saving submission to Supabase: {e}", exc_info=True)
        # Avoid leaking detailed error messages to the client in production if not desired.
        # For now, including str(e) for easier debugging during development.
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"An error occurred while processing your request." # str(e) removed for security
        )

@app.post("/chat", response_model=ChatResponse)
async def handle_chat(payload: ChatMessage):
    logger.info(f"Received chat message: '{payload.message}', session_id: {payload.session_id}")

    # Call the ai_agent.py function which now returns three values
    agent_reply, response_session_id, require_form = ai_agent.get_chat_response(
        message=payload.message,
        session_id=payload.session_id
    )

    return ChatResponse(
        reply=agent_reply,
        session_id=response_session_id,
        require_form_after_message=require_form # Pass the value from the agent
    )

@app.get("/")
async def read_root():
    return {"message": "Contact Form API with Chat is running. Submit contact data to /submit or chat messages to /chat"}

# To run this app (for development, from the project root directory):
# uvicorn backend.contact_api:app --reload --port 8000
#
# Example of how to test the /chat endpoint with curl:
# curl -X POST "http://localhost:8000/chat" \
# -H "Content-Type: application/json" \
# -d '{
#   "message": "Hello Agent!",
#   "session_id": "user123_chat789"
# }'

# Placeholder for database session dependency
# In a real application, this would be configured with your database connection
# def get_db(): # This function was already removed in a previous step, ensuring it's gone
    # Mock implementation. Replace with your actual database session provider.
    # For example:
    # from .database import SessionLocal # Assuming you have a database.py
    # db = SessionLocal()
    # try:
    #     yield db
    # finally:
    #     db.close()
    # For now, yielding None and endpoints will check for this.
    # A real implementation would yield a SQLAlchemy Session.
    # yield None # Removed stub get_db function

# The get_current_active_user is now imported from backend.auth
# The old placeholder function below is removed.
# async def get_current_active_user() -> Any: # Added return type hint
#     # Mock implementation.
#     # To simulate a protected endpoint that currently doesn't authenticate properly:
#     # raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Not authenticated")
#     # For development, returning a dummy user or None to bypass actual auth.
#     # return {"username": "devuser", "permissions": ["view_analytics"]} # Keeping this for now, might be used by other parts or future tests
#     return {"username": "devuser", "permissions": ["view_analytics"]}

app.include_router(form_ga_config_router.router)
app.include_router(submission_router.router)
app.include_router(tenant_router.router) # Added line to include the new tenant router

[end of backend/contact_api.py]

[start of backend/db.py]
# backend/db.py
import logging
from typing import Optional
from supabase import create_client, Client
from backend.config import settings # Assuming .config is correct relative path

logger = logging.getLogger(__name__)

supabase_url: Optional[str] = settings.supabase_url
supabase_key: Optional[str] = settings.supabase_service_role_key

supabase_client: Optional[Client] = None

if supabase_url and supabase_key:
    try:
        supabase_client = create_client(supabase_url, supabase_key)
        logger.info("Supabase client initialized successfully.")
    except Exception as e:
        logger.error("Failed to initialize Supabase client: %s", e, exc_info=True)
        supabase_client = None
else:
    logger.warning("Supabase URL or Service Role Key is not set in .env. Supabase client cannot be initialized.")

def get_supabase_client() -> Optional[Client]:
    return supabase_client

[end of backend/db.py]

[start of backend/rag_integration.py]

[end of backend/rag_integration.py]

[start of backend/requirements.txt]
fastapi
uvicorn[standard]
google-adk
python-dotenv
supabase-py>=1.0,<2.0
httpx>=0.20.0,<1.0.0
tenacity>=8.2.0,<9.0.0
python-jose[cryptography]>=3.3.0,<4.0.0

[end of backend/requirements.txt]

[start of backend/models/ga4_config_models.py]
# backend/models/ga4_config_models.py
from pydantic import BaseModel, Field, ConfigDict # ConfigDict for Pydantic V2
from typing import Optional, List
from datetime import datetime

class GA4ConfigurationBase(BaseModel):
    ga4_measurement_id: str = Field(
        ...,
        min_length=1,
        description=\"GA4 Measurement ID (e.g., G-XXXXXXXXXX).\",
        examples=[\"G-1234567890\"]
    )
    ga4_api_secret: str = Field(
        ...,
        min_length=1,
        description=\"GA4 API Secret for Measurement Protocol. This is sensitive data.\"
    )
    description: Optional[str] = Field(
        None,
        description=\"Optional human-readable description for this GA4 configuration set.\",
        examples=[\"Main contact form GA4 settings\"]
    )

class GA4ConfigurationCreatePayload(GA4ConfigurationBase):
    \"\"\"
    Payload for creating a new GA4 configuration.
    form_id will be a path parameter, tenant_id from authenticated user.
    \"\"\"
    pass # Inherits all fields from GA4ConfigurationBase, form_id removed

class GA4ConfigurationUpdatePayload(BaseModel):
    \"\"\"
    Payload for updating an existing GA4 configuration.
    All fields are optional; only provided fields will be updated.
    \"\"\"
    ga4_measurement_id: Optional[str] = Field(
        None,
        min_length=1,
        description=\"New GA4 Measurement ID, if changing.\"
    )
    ga4_api_secret: Optional[str] = Field(
        None,
        min_length=1,
        description=\"New GA4 API Secret, if changing. This is sensitive data.\"
    )
    description: Optional[str] = Field(
        None,
        description=\"New or updated description for this GA4 configuration set.\"
    )

class GA4ConfigurationResponse(GA4ConfigurationBase):
    \"\"\"
    Represents a GA4 configuration record as returned by the API.
    Includes database-generated fields like tenant_id, form_id, created_at, and updated_at.
    \"\"\"
    tenant_id: str # Added
    form_id: str
    created_at: datetime
    updated_at: datetime

    model_config = ConfigDict(from_attributes=True)


class GA4ConfigurationListResponse(BaseModel):
    \"\"\"
    Response model for listing multiple GA4 configurations.
    \"\"\"
    configurations: List[GA4ConfigurationResponse]

[end of backend/models/ga4_config_models.py]

[start of backend/models/submission_models.py]
# backend/models/submission_models.py
from pydantic import BaseModel, Field
from typing import Optional, List # Added List
from backend.contact_api import SubmissionResponse # Added import

class SubmissionStatusUpdatePayload(BaseModel):
    \"\"\"
    Payload for updating the status of a submission.
    \"\"\"
    new_status: str = Field(
        ...,
        min_length=1,
        description=\"The new status to set for the submission (e.g., 'contacted', 'converted', 'spam'). This should match one of the predefined status values.\"\n    )
    reason: Optional[str] = Field(
        None,
        description=\"An optional reason for this status change, especially for statuses like 'unconverted' or 'disqualified'.\"\n    )

# Note: The response for a status update will likely be the full updated submission,
# which can reuse the existing `SubmissionResponse` model defined in `backend.contact_api`.
# Therefore, a specific response model for status updates might not be needed here.


class SubmissionListResponse(BaseModel):
    \"\"\"
    Response model for listing contact submissions.
    Contains a list of submission records and pagination details.
    \"\"\"
    submissions: List[SubmissionResponse]
    total_count: int = Field(..., description=\"Total number of submissions matching the filter criteria.\")
    skip: int = Field(..., ge=0, description=\"Number of records skipped (offset).\")
    limit: int = Field(..., ge=1, description=\"Maximum number of records returned in this response.\")

[end of backend/models/submission_models.py]

[start of backend/models/tenant_models.py]
# backend/models/tenant_models.py
from pydantic import BaseModel, Field, UUID4, ConfigDict
from typing import Optional, List
from datetime import datetime

class TenantBase(BaseModel):
    company_name: str = Field(..., min_length=1, description=\"Name of the tenant company.\")
    domain: Optional[str] = Field(
        None,
        description=\"Domain associated with the tenant (e.g., company website). Can be null.\",
        examples=[\"example.com\"]\n    )

class TenantCreatePayload(TenantBase):
    \"\"\"Payload for creating a new tenant.\"\"\"
    pass

class TenantUpdatePayload(BaseModel):
    \"\"\"Payload for updating an existing tenant. All fields are optional.\"\"\"
    company_name: Optional[str] = Field(None, min_length=1, description=\"New company name, if changing.\")
    domain: Optional[str] = Field(None, description=\"New domain, if changing. Set to null to clear.\")
    is_deleted: Optional[bool] = Field(None, description=\"Set to true to logically delete, false to restore.\")

class TenantResponse(TenantBase):
    \"\"\"Response model for a tenant, including database-generated fields.\"\"\"
    tenant_id: UUID4 # UUID type from Pydantic
    is_deleted: bool
    created_at: datetime
    updated_at: datetime

    model_config = ConfigDict(from_attributes=True) # For Pydantic V2 ORM mode

class TenantListResponse(BaseModel):
    \"\"\"Response model for listing tenants with pagination info.\"\"\"
    tenants: List[TenantResponse]
    total_count: int = Field(..., description=\"Total number of tenants matching filter criteria.\")
    skip: int = Field(..., ge=0, description=\"Number of records skipped (offset).\")
    limit: int = Field(..., ge=1, description=\"Maximum number of records returned.\")

[end of backend/models/tenant_models.py]

[start of backend/routers/form_ga_config_router.py]
# backend/routers/form_ga_config_router.py
from fastapi import APIRouter, Depends, HTTPException, status, Body
from typing import List, Optional, Any # Added Any for current_user
from supabase import Client

from backend.db import get_supabase_client
from backend.models.ga4_config_models import (\n    GA4ConfigurationBase, # Changed from GA4ConfigurationCreatePayload\n    GA4ConfigurationUpdatePayload,\n    GA4ConfigurationResponse,\n    GA4ConfigurationListResponse\n)
from backend.services import form_ga_config_service
from backend.auth import AuthenticatedUser, get_current_active_user # Ensure AuthenticatedUser is imported

router = APIRouter(\n    prefix=\"/api/v1/ga_configurations\",\n    tags=[\"GA4 Form Configurations\"],\n    dependencies=[Depends(get_current_active_user)]\n)

@router.post(\"/{form_id}\", response_model=GA4ConfigurationResponse, status_code=status.HTTP_201_CREATED)
async def create_ga_configuration_endpoint(\n    form_id: str, # form_id from path\n    payload: GA4ConfigurationBase, # Use base model for payload\n    supabase: Client = Depends(get_supabase_client),\n    user: AuthenticatedUser = Depends(get_current_active_user)\n):\n    if supabase is None:\n        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail=\"Supabase client unavailable\")\n    if not user.tenant_id:\n        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=\"User does not have a tenant ID.\")\n\n    existing_config = form_ga_config_service.get_ga_configuration(supabase, tenant_id=user.tenant_id, form_id=form_id)\n    if existing_config:\n        raise HTTPException(\n            status_code=status.HTTP_409_CONFLICT,\n            detail=f\"GA4 configuration for tenant '{user.tenant_id}', form_id '{form_id}' already exists.\"\n        )\n\n    created_config_dict = form_ga_config_service.create_ga_configuration(\n        db=supabase,\n        tenant_id=user.tenant_id,\n        form_id=form_id,\n        payload_base=payload\n    )\n    if not created_config_dict:\n        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=\"Failed to create GA4 configuration.\")\n    return GA4ConfigurationResponse(**created_config_dict)


@router.get(\"\", response_model=GA4ConfigurationListResponse)
async def list_ga_configurations_endpoint(\n    skip: int = 0,\n    limit: int = 20,\n    supabase: Client = Depends(get_supabase_client),\n    user: AuthenticatedUser = Depends(get_current_active_user)\n):\n    if supabase is None:\n        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail=\"Supabase client unavailable\")\n    if not user.tenant_id:\n        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=\"User does not have a tenant ID.\")\n\n    configs_list_dict = form_ga_config_service.list_ga_configurations(\n        db=supabase, tenant_id=user.tenant_id, skip=skip, limit=limit\n    )\n    # Ensure GA4ConfigurationResponse model can handle dicts from service (it should with from_attributes=True)\n    response_items = [GA4ConfigurationResponse(**item) for item in configs_list_dict]\n    return GA4ConfigurationListResponse(configurations=response_items)


@router.get(\"/{form_id}\", response_model=GA4ConfigurationResponse)
async def get_ga_configuration_endpoint(\n    form_id: str,\n    supabase: Client = Depends(get_supabase_client),\n    user: AuthenticatedUser = Depends(get_current_active_user)\n):\n    if supabase is None:\n        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail=\"Supabase client unavailable\")\n    if not user.tenant_id:\n        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=\"User does not have a tenant ID.\")\n\n    config_dict = form_ga_config_service.get_ga_configuration(supabase, tenant_id=user.tenant_id, form_id=form_id)\n    if not config_dict:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f\"GA4 configuration for tenant '{user.tenant_id}', form_id '{form_id}' not found.\")\n    return GA4ConfigurationResponse(**config_dict)


@router.put(\"/{form_id}\", response_model=GA4ConfigurationResponse)
async def update_ga_configuration_endpoint(\n    form_id: str,\n    payload: GA4ConfigurationUpdatePayload,\n    supabase: Client = Depends(get_supabase_client),\n    user: AuthenticatedUser = Depends(get_current_active_user)\n):\n    if supabase is None:\n        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail=\"Supabase client unavailable\")\n    if not user.tenant_id:\n        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=\"User does not have a tenant ID.\")\n\n    updated_config_dict = form_ga_config_service.update_ga_configuration(\n        db=supabase, tenant_id=user.tenant_id, form_id=form_id, config_payload=payload\n    )\n    if not updated_config_dict:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f\"GA4 configuration for tenant '{user.tenant_id}', form_id '{form_id}' not found or no update performed.\")\n    return GA4ConfigurationResponse(**updated_config_dict)


@router.delete(\"/{form_id}\", status_code=status.HTTP_204_NO_CONTENT)
async def delete_ga_configuration_endpoint(\n    form_id: str,\n    supabase: Client = Depends(get_supabase_client),\n    user: AuthenticatedUser = Depends(get_current_active_user)\n):\n    if supabase is None:\n        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail=\"Supabase client unavailable\")\n    if not user.tenant_id:\n        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=\"User does not have a tenant ID.\")\n\n    success = form_ga_config_service.delete_ga_configuration(supabase, tenant_id=user.tenant_id, form_id=form_id)\n    if not success:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f\"GA4 configuration for tenant '{user.tenant_id}', form_id '{form_id}' not found or delete failed.\")\n    # No body for 204 response\n"
    },
    {
      "path": "backend/routers/submission_router.py",
      "content": "# backend/routers/submission_router.py\nimport logging\nfrom fastapi import APIRouter, Depends, HTTPException, status, Path, Query # Added Query\nfrom typing import Optional, Any, Dict, List # Added List\nfrom datetime import date # Added date\nfrom supabase import Client\n\nfrom backend.db import get_supabase_client\nfrom backend.models.submission_models import SubmissionStatusUpdatePayload, SubmissionListResponse # Added SubmissionListResponse\nfrom backend.contact_api import SubmissionResponse as SubmissionItemResponse # Reusing existing model from contact_api and aliasing\n\n# Import services\nfrom backend.services import submission_service\nfrom backend.services import form_ga_config_service\nfrom backend.services import ga4_mp_service\nfrom backend.auth import AuthenticatedUser, get_current_active_user # Ensured AuthenticatedUser is imported\n\nlogger = logging.getLogger(__name__)\n\nrouter = APIRouter(\n    prefix=\"/api/v1/submissions\",\n    tags=[\"Submission Status Management\"],\n    dependencies=[Depends(get_current_active_user)]\n)\n\n# Mapping of submission statuses to GA4 event details\n# This could also live in a config file or a dedicated module if it grows.\nSTATUS_TO_GA4_EVENT_MAP: Dict[str, Dict[str, Any]] = {\n    \"contacted\": {\"name\": \"working_lead\", \"params_template\": {\"lead_status\": \"contacted\"}},\n    \"qualified\": {\"name\": \"qualify_lead\", \"params_template\": {}},\n    \"converted\": {\"name\": \"close_convert_lead\", \"params_template\": {}}, # transaction_id to be added dynamically\n    \"unconverted\": {\"name\": \"lead_unconverted\", \"params_template\": {}}, # Custom event\n    \"disqualified\": {\"name\": \"lead_disqualified\", \"params_template\": {}}, # Custom event\n}\n\nCONTACT_SUBMISSIONS_TABLE = \"contact_submissions\" # Define table name constant\n\n@router.patch(\"/{submission_id}/status\", response_model=SubmissionItemResponse)\nasync def update_submission_status_endpoint(\n    submission_id: int = Path(..., title=\"The ID of the submission to update\", ge=1),\n    payload: SubmissionStatusUpdatePayload,\n    supabase: Client = Depends(get_supabase_client),\n    user: AuthenticatedUser = Depends(get_current_active_user) # Inject user\n):\n    if supabase is None:\n        logger.error(\"Supabase client unavailable for PATCH /submissions/%s/status\", submission_id)\n        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail=\"Supabase client unavailable\")\n\n    if not user.tenant_id:\n        logger.error(\"User tenant_id missing for PATCH /submissions/%s/status\", submission_id)\n        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=\"User not associated with a tenant.\")\n\n    # 1. Fetch current submission, scoped by tenant_id\n    try:\n        query = (\n            supabase.table(CONTACT_SUBMISSIONS_TABLE)\n            .select(\"id, form_id, ga_client_id, ga_session_id, submission_status, tenant_id\") # Ensure tenant_id is selected\n            .eq(\"id\", submission_id)\n            .eq(\"tenant_id\", user.tenant_id) # Scope to tenant\n            .single()\n        )\n        current_submission_response = query.execute()\n\n        if not current_submission_response.data:\n            logger.warning(f\"Submission with id {submission_id} not found for tenant {user.tenant_id}.\")\n            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f\"Submission with id {submission_id} not found.\")\n        current_submission = current_submission_response.data\n        original_status = current_submission.get(\"submission_status\")\n\n    except Exception as e_fetch:\n        logger.error(f\"Failed to fetch submission {submission_id} for tenant {user.tenant_id}: {e_fetch}\", exc_info=True)\n        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f\"Failed to retrieve submission details for id {submission_id}.\")\n\n    # 2. Update the submission status, scoped by tenant_id\n    updated_submission_dict = await submission_service.update_submission_status(\n        db=supabase,\n        tenant_id=user.tenant_id, # Pass tenant_id\n        submission_id=submission_id,\n        new_status=payload.new_status,\n        reason=payload.reason\n    )\n\n    if not updated_submission_dict:\n        logger.error(f\"Update_submission_status service failed for submission_id: {submission_id}, tenant_id: {user.tenant_id}\")\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f\"Failed to update submission status for id {submission_id}, record may not exist or update failed.\")\n\n    # 3. Send GA4 event if status actually changed and is mapped\n    if original_status != payload.new_status and payload.new_status in STATUS_TO_GA4_EVENT_MAP:\n        form_id = current_submission.get(\"form_id\")\n        ga_client_id = current_submission.get(\"ga_client_id\")\n\n        if form_id and ga_client_id: # tenant_id is confirmed from user object\n            ga_config_dict = form_ga_config_service.get_ga_configuration(\n                db=supabase, tenant_id=user.tenant_id, form_id=form_id # Pass tenant_id\n            )\n\n            if ga_config_dict:\n                api_secret = ga_config_dict.get(\"ga4_api_secret\")\n                measurement_id = ga_config_dict.get(\"ga4_measurement_id\")\n\n                if api_secret and measurement_id:\n                    event_config = STATUS_TO_GA4_EVENT_MAP[payload.new_status]\n                    event_params = {**event_config[\"params_template\"]}\n\n                    event_params[\"value\"] = 0\n                    event_params[\"currency\"] = \"JPY\"\n\n                    event_params[\"form_id\"] = form_id\n                    if current_submission.get(\"ga_session_id\"):\n                        event_params[\"session_id\"] = current_submission.get(\"ga_session_id\")\n                    if payload.new_status == \"converted\":\n                        event_params[\"transaction_id\"] = str(submission_id)\n\n                    ga4_event_payload = {\"name\": event_config[\"name\"], \"params\": event_params}\n\n                    logger.info(\n                        f\"Attempting to send GA4 event '{ga4_event_payload['name']}' for tenant_id: {user.tenant_id}, submission_id: {submission_id}, new_status: {payload.new_status}\"\n                    )\n                    try:\n                        await ga4_mp_service.send_ga4_event(\n                            api_secret=api_secret,\n                            measurement_id=measurement_id,\n                            client_id=ga_client_id,\n                            events=[ga4_event_payload]\n                        )\n                    except Exception as e_ga:\n                        logger.error(\n                            f\"Unhandled error when trying to send GA4 event for tenant_id: {user.tenant_id}, submission_id {submission_id} (status {payload.new_status}): {e_ga}\",\n                            exc_info=True\n                        )\n                else:\n                    logger.warning(f\"GA4 API secret or Measurement ID missing in config for tenant_id '{user.tenant_id}', form_id '{form_id}'. Cannot send '{payload.new_status}' event for submission {submission_id}.\")\n            else:\n                logger.warning(f\"GA4 configuration not found for tenant_id '{user.tenant_id}', form_id '{form_id}'. Cannot send '{payload.new_status}' event for submission {submission_id}.\")\n        else:\n            logger.info(f\"Skipping GA4 '{payload.new_status}' event for tenant_id: {user.tenant_id}, submission {submission_id}: form_id or ga_client_id missing.\")\n\n    return SubmissionItemResponse(**updated_submission_dict)\n\n\n@router.get(\"\", response_model=SubmissionListResponse, tags=[\"Submissions Data\"])\nasync def list_submissions_endpoint(\n    form_id: Optional[str] = Query(None, description=\"Filter by form_id.\"),\n    submission_status: Optional[str] = Query(None, description=\"Filter by submission status.\"),\n    email: Optional[str] = Query(None, description=\"Filter by email (case-insensitive, partial match).\"),\n    name: Optional[str] = Query(None, description=\"Filter by name (case-insensitive, partial match).\"),\n    start_date: Optional[date] = Query(None, description=\"Filter by creation date (start of range, YYYY-MM-DD).\"),\n    end_date: Optional[date] = Query(None, description=\"Filter by creation date (end of range, YYYY-MM-DD).\"),\n    skip: int = Query(0, ge=0, description=\"Number of records to skip.\"),\n    limit: int = Query(20, ge=1, le=100, description=\"Maximum number of records to return.\"),\n    sort_by: Optional[str] = Query(\"created_at\", enum=[\"created_at\", \"updated_at\", \"name\", \"submission_status\", \"id\", \"email\", \"form_id\"], description=\"Column to sort by.\"),\n    sort_order: Optional[str] = Query(\"desc\", enum=[\"asc\", \"desc\"], description=\"Sort order (asc or desc).\"),\n    supabase: Client = Depends(get_supabase_client),\n    user: AuthenticatedUser = Depends(get_current_active_user) # Inject user\n):\n    if supabase is None:\n        logger.error(\"Supabase client unavailable for GET /api/v1/submissions\")\n        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail=\"Supabase client unavailable\")\n\n    if not user.tenant_id:\n        logger.error(\"User tenant_id missing for GET /api/v1/submissions\")\n        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=\"User not associated with a tenant.\")\n\n    try:\n        submissions_list_dicts, total_count = await submission_service.list_submissions(\n            db=supabase,\n            tenant_id=user.tenant_id, # Pass tenant_id\n            skip=skip,\n            limit=limit,\n            form_id=form_id,\n            submission_status=submission_status,\n            email=email,\n            name=name,\n            start_date=start_date,\n            end_date=end_date,\n            sort_by=sort_by,\n            sort_order=sort_order\n        )\n\n        parsed_submissions = [SubmissionItemResponse(**item) for item in submissions_list_dicts]\n\n        return SubmissionListResponse(\n            submissions=parsed_submissions,\n            total_count=total_count,\n            skip=skip,\n            limit=limit\n        )\n    except Exception as e:\n        logger.error(f\"Error listing submissions: {e}\", exc_info=True)\n        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=\"Failed to list submissions.\")\n"
    },
    {
      "path": "backend/routers/tenant_router.py",
      "content": "# backend/routers/tenant_router.py\nimport logging\nfrom uuid import UUID\nfrom fastapi import APIRouter, Depends, HTTPException, status, Query, Path # Added Path\nfrom typing import List, Optional, Any\nfrom supabase import Client\n\nfrom backend.db import get_supabase_client\nfrom backend.models.tenant_models import (\n    TenantCreatePayload,\n    TenantUpdatePayload,\n    TenantResponse,\n    TenantListResponse\n)\nfrom backend.services import tenant_service\nfrom backend.auth import AuthenticatedUser, get_current_active_user # Import from auth.py\n\nlogger = logging.getLogger(__name__)\n\nrouter = APIRouter(\n    prefix=\"/api/v1/tenants\",\n    tags=[\"Tenant Management (Superuser Only)\"] # Tag updated for clarity\n)\n\n# Dependency for superuser check\nasync def require_superuser_role(user: AuthenticatedUser = Depends(get_current_active_user)):\n    # This assumes 'superuser' is a defined app_role for superusers.\n    # And that user.tenant_id might be None for a superuser not tied to a specific tenant context by default.\n    if user.app_role != \"superuser\":\n        logger.warning(f\"User {user.id} (role: {user.app_role}) attempted to access superuser-only tenant API at {router.prefix}.\")\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"You do not have permission to manage tenants.\"\n        )\n    return user\n\n# Apply superuser check to all routes in this router\nrouter.dependencies.append(Depends(require_superuser_role))\n\n\n@router.post(\"\", response_model=TenantResponse, status_code=status.HTTP_201_CREATED)\nasync def create_tenant_endpoint(\n    payload: TenantCreatePayload,\n    supabase: Client = Depends(get_supabase_client)\n    # superuser: AuthenticatedUser = Depends(require_superuser_role) # Covered by router dependency\n):\n    if supabase is None:\n        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail=\"Supabase client unavailable\")\n\n    # Optional: Check if tenant with same company_name or domain already exists if they should be unique\n    # This would require additional service methods like get_tenant_by_name/domain.\n    # For now, relying on DB constraints if any (e.g. unique domain if schema had it).\n\n    created_tenant_dict = await tenant_service.create_tenant(supabase, payload)\n    if not created_tenant_dict:\n        # Consider more specific error if service layer can provide it (e.g. duplicate)\n        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=\"Failed to create tenant. Check server logs for details.\")\n    return TenantResponse(**created_tenant_dict)\n\n\n@router.get(\"\", response_model=TenantListResponse)\nasync def list_tenants_endpoint(\n    skip: int = Query(0, ge=0, description=\"Number of records to skip for pagination.\"),\n    limit: int = Query(20, ge=1, le=100, description=\"Maximum number of records to return.\"),\n    show_deleted: bool = Query(False, description=\"Set to true to include logically deleted tenants.\"),\n    supabase: Client = Depends(get_supabase_client)\n):\n    if supabase is None:\n        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail=\"Supabase client unavailable\")\n\n    tenants_list_dict, total_count = await tenant_service.list_tenants(supabase, skip, limit, show_deleted)\n    return TenantListResponse(\n        tenants=[TenantResponse(**t) for t in tenants_list_dict],\n        total_count=total_count,\n        skip=skip,\n        limit=limit\n    )\n\n@router.get(\"/{tenant_id}\", response_model=TenantResponse)\nasync def get_tenant_endpoint(\n    tenant_id: UUID = Path(..., description=\"The UUID of the tenant to retrieve.\"), # Use Path for path params\n    supabase: Client = Depends(get_supabase_client)\n):\n    if supabase is None:\n        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail=\"Supabase client unavailable\")\n\n    tenant_dict = await tenant_service.get_tenant(supabase, tenant_id)\n    if not tenant_dict:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f\"Tenant with id '{tenant_id}' not found.\")\n    return TenantResponse(**tenant_dict)\n\n@router.put(\"/{tenant_id}\", response_model=TenantResponse)\nasync def update_tenant_endpoint(\n    tenant_id: UUID = Path(..., description=\"The UUID of the tenant to update.\"),\n    payload: TenantUpdatePayload,\n    supabase: Client = Depends(get_supabase_client)\n):\n    if supabase is None:\n        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail=\"Supabase client unavailable\")\n\n    updated_tenant_dict = await tenant_service.update_tenant(supabase, tenant_id, payload)\n    if not updated_tenant_dict:\n        # This could be not found, or an empty update payload that resulted in no change (service returns current)\n        # If service returns None specifically for \"not found\", then 404 is appropriate.\n        # Assuming service returns None if tenant_id not found by update call.\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f\"Tenant with id '{tenant_id}' not found or update resulted in no change/failed.\")\n    return TenantResponse(**updated_tenant_dict)\n\n@router.delete(\"/{tenant_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_tenant_endpoint(\n    tenant_id: UUID = Path(..., description=\"The UUID of the tenant to delete.\"),\n    hard_delete: bool = Query(False, description=\"Set to true to permanently (hard) delete the tenant. Default is logical delete.\"),\n    supabase: Client = Depends(get_supabase_client)\n):\n    if supabase is None:\n        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail=\"Supabase client unavailable\")\n\n    success = await tenant_service.delete_tenant(supabase, tenant_id, hard_delete)\n    if not success:\n        # Service's delete_tenant returns False if record not found (for hard delete)\n        # or if already in the desired state (for logical delete, though service was updated to return True here).\n        # Or if DB error occurs. For simplicity, map to 404 if not successful.\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f\"Tenant with id '{tenant_id}' not found or delete operation failed.\")\n    # For 204, FastAPI expects no return value (or None).\n"
    },
    {
      "path": "backend/services/form_ga_config_service.py",
      "content": "# backend/services/form_ga_config_service.py\nimport logging\nfrom typing import List, Optional, Dict, Any\nfrom supabase import Client\n# GA4ConfigurationCreatePayload is now GA4ConfigurationBase for the service create function\nfrom backend.models.ga4_config_models import GA4ConfigurationBase, GA4ConfigurationUpdatePayload\n\nlogger = logging.getLogger(__name__)\nTABLE_NAME = \"form_ga_configurations\"\n\ndef create_ga_configuration(\n    db: Client,\n    tenant_id: str,\n    form_id: str,\n    payload_base: GA4ConfigurationBase\n) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    Creates a new GA4 configuration for a specific tenant and form_id.\n    Returns the created record as a dictionary, or None if creation failed.\n    \"\"\"\n    try:\n        data_to_insert = payload_base.model_dump()\n        data_to_insert[\"tenant_id\"] = tenant_id\n        data_to_insert[\"form_id\"] = form_id\n\n        response = db.table(TABLE_NAME).insert(data_to_insert).execute()\n        if response.data and len(response.data) > 0:\n            logger.info(f\"GA4 configuration created for tenant_id: {tenant_id}, form_id: {form_id}\")\n            return response.data[0]\n        else:\n            logger.warning(\n                f\"Failed to create GA4 configuration for tenant_id: {tenant_id}, form_id: {form_id}. \"\n                f\"Supabase response: {response.model_dump_json() if hasattr(response, 'model_dump_json') else str(response)}\"\n            )\n            return None\n    except Exception as e: # More specific exceptions could be caught from supabase.exceptions\n        logger.error(\n            f\"Exception creating GA4 configuration for tenant_id: {tenant_id}, form_id {form_id}: {e}\",\n            exc_info=True\n        )\n        return None\n\ndef get_ga_configuration(db: Client, tenant_id: str, form_id: str) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    Retrieves a GA4 configuration by tenant_id and form_id.\n    Returns the record as a dictionary, or None if not found.\n    \"\"\"\n    try:\n        response = (\n            db.table(TABLE_NAME)\n            .select(\"*\")\n            .eq(\"tenant_id\", tenant_id) # Added tenant_id filter\n            .eq(\"form_id\", form_id)\n            .single()\n            .execute()\n        )\n        # single() returns the object directly in .data if found, or raises an error if >1, or data is None if 0\n        if response.data:\n            return response.data\n        else: # Should be caught by PostgrestAPIError if not found with single(), but defensive check\n            logger.info(f\"No GA4 configuration found for tenant_id '{tenant_id}' and form_id '{form_id}'.\")\n            return None\n    except Exception as e: # Catch supabase.exceptions.PostgrestAPIError for \"No rows found\" specifically if desired\n        logger.error(f\"Exception retrieving GA4 configuration for tenant_id '{tenant_id}', form_id '{form_id}': {e}\", exc_info=True)\n        return None\n\ndef list_ga_configurations(db: Client, tenant_id: str, skip: int = 0, limit: int = 100) -> List[Dict[str, Any]]:\n    \"\"\"\n    Lists GA4 configurations for a specific tenant with pagination.\n    Returns a list of records (dictionaries).\n    \"\"\"\n    try:\n        response = (\n            db.table(TABLE_NAME)\n            .select(\"*\")\n            .eq(\"tenant_id\", tenant_id)\n            .range(skip, skip + limit - 1)\n            .execute()\n        )\n        return response.data if response.data else []\n    except Exception as e:\n        logger.error(f\"Exception listing GA4 configurations for tenant_id {tenant_id}: {e}\", exc_info=True)\n        return []\n\ndef update_ga_configuration(\n    db: Client,\n    tenant_id: str,\n    form_id: str,\n    config_payload: GA4ConfigurationUpdatePayload\n) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    Updates an existing GA4 configuration for a given tenant_id and form_id.\n    Only updates fields present in the payload (non-None).\n    Returns the updated record as a dictionary, or None if not found or update failed.\n    \"\"\"\n    try:\n        data_to_update = config_payload.model_dump(exclude_unset=True)\n\n        if not data_to_update:\n            logger.info(f\"No fields to update for GA4 configuration for tenant_id: {tenant_id}, form_id: {form_id}. Returning current record.\")\n            return get_ga_configuration(db, tenant_id, form_id)\n\n        response = (\n            db.table(TABLE_NAME)\n            .update(data_to_update)\n            .eq(\"tenant_id\", tenant_id)\n            .eq(\"form_id\", form_id)\n            .execute()\n        )\n        if response.data and len(response.data) > 0:\n            logger.info(f\"GA4 configuration updated for tenant_id: {tenant_id}, form_id: {form_id}\")\n            return response.data[0]\n        else:\n            logger.warning(\n                f\"Failed to update GA4 configuration for tenant_id: {tenant_id}, form_id: {form_id} (it may not exist or no data returned). \"\n                f\"Supabase response: {response.model_dump_json() if hasattr(response, 'model_dump_json') else str(response)}\"\n            )\n            return None\n    except Exception as e:\n        logger.error(f\"Exception updating GA4 configuration for tenant_id: {tenant_id}, form_id {form_id}: {e}\", exc_info=True)\n        return None\n\ndef delete_ga_configuration(db: Client, tenant_id: str, form_id: str) -> bool:\n    \"\"\"\n    Deletes a GA4 configuration by tenant_id and form_id.\n    Returns True if deletion was successful, False otherwise.\n    \"\"\"\n    try:\n        response = (\n            db.table(TABLE_NAME)\n            .delete()\n            .eq(\"tenant_id\", tenant_id)\n            .eq(\"form_id\", form_id)\n            .execute()\n        )\n        if response.data and len(response.data) > 0:\n            logger.info(f\"GA4 configuration deleted for tenant_id: {tenant_id}, form_id: {form_id}\")\n            return True\n        else:\n            logger.warning(f\"GA4 configuration for tenant_id: {tenant_id}, form_id: {form_id} not found or delete returned no data. Response: {response.model_dump_json() if hasattr(response, 'model_dump_json') else str(response)}\")\n            return False\n    except Exception as e:\n        logger.error(f\"Exception deleting GA4 configuration for tenant_id: {tenant_id}, form_id {form_id}: {e}\", exc_info=True)\n        return False\n"
    },
    {
      "path": "backend/services/ga4_mp_service.py",
      "content": "# backend/services/ga4_mp_service.py\nimport httpx\nimport logging\nfrom typing import List, Dict, Any, Optional\nimport time # For timestamp_micros default\n\nlogger = logging.getLogger(__name__)\n\nGA4_MP_URL = \"https://www.google-analytics.com/mp/collect\"\n# Measurement Protocolリクエストのタイムアウト（秒）\nDEFAULT_MP_TIMEOUT = 10.0\n\nasync def send_ga4_event(\n    api_secret: str,\n    measurement_id: str,\n    client_id: str,\n    events: List[Dict[str, Any]],\n    # session_id is typically part of event params, but can be passed for inclusion\n    # timestamp_micros defaults to current time if not provided\n    timestamp_micros: Optional[int] = None,\n    user_properties: Optional[Dict[str, Any]] = None,\n    non_personalized_ads: bool = False\n) -> bool:\n    \"\"\"\n    Sends one or more events to Google Analytics 4 Measurement Protocol.\n\n    Args:\n        api_secret: The API secret for the GA4 property.\n        measurement_id: The Measurement ID for the GA4 property.\n        client_id: The client ID for the user.\n        events: A list of event objects. Each event object should be a dictionary\n                with 'name' (string) and 'params' (dict) keys.\n        timestamp_micros: Event timestamp in microseconds (UTC).\n                          If None, current time will be used.\n        user_properties: Optional user properties to send.\n        non_personalized_ads: Whether these events are for non-personalized ads.\n\n    Returns:\n        True if the request was successful (2xx status code), False otherwise.\n    \"\"\"\n    if not api_secret or not measurement_id:\n        logger.error(\"GA4 API Secret or Measurement ID is missing. Cannot send event(s) for client_id: %s\", client_id)\n        return False\n    if not client_id:\n        logger.error(\"GA4 Client ID is missing. Cannot send event(s) for measurement_id: %s\", measurement_id)\n        return False\n    if not events:\n        logger.warning(\"No events provided to send to GA4 for client_id: %s, measurement_id: %s.\", client_id, measurement_id)\n        return True # No events to send is not an error of this function.\n\n    # Prepare the main payload\n    payload: Dict[str, Any] = {\n        \"client_id\": client_id,\n        \"non_personalized_ads\": non_personalized_ads,\n        \"events\": events, # Events should already have session_id in their params if needed\n    }\n\n    if timestamp_micros is None:\n        # Default to current time in microseconds if not provided\n        payload[\"timestamp_micros\"] = int(time.time() * 1_000_000)\n    else:\n        payload[\"timestamp_micros\"] = timestamp_micros\n\n    if user_properties:\n        payload[\"user_properties\"] = user_properties\n\n    # Query parameters for the POST request\n    query_params = {\n        \"api_secret\": api_secret,\n        \"measurement_id\": measurement_id,\n    }\n\n    event_names = [event.get(\"name\", \"unknown_event\") for event in events]\n    logger.debug(\n        \"Attempting to send GA4 events. Measurement ID: %s, Client ID: %s, Events: %s, Payload: %s\",\n        measurement_id, client_id, event_names, payload\n    )\n\n    try:\n        async with httpx.AsyncClient(timeout=DEFAULT_MP_TIMEOUT) as http_client: # Renamed client to http_client\n            response = await http_client.post(GA4_MP_URL, params=query_params, json=payload)\n\n        if 200 <= response.status_code < 300:\n            logger.info(\n                \"Successfully sent %d event(s) to GA4: %s (Measurement ID: %s, Client ID: %s)\",\n                len(events), event_names, measurement_id, client_id\n            )\n            # Check for validation messages if the validation server was hit (usually by not using \"www.\")\n            # or if GA4 MP returns them in a successful response.\n            if response.content:\n                try:\n                    validation_data = response.json()\n                    if validation_data and validation_data.get(\"validationMessages\"):\n                        logger.warning(\n                            \"GA4 Measurement Protocol validation messages for Measurement ID %s, Client ID %s: %s\",\n                            measurement_id, client_id, validation_data.get(\"validationMessages\")\n                        )\n                except Exception: # Not a JSON response\n                    logger.debug(\n                        \"GA4 Measurement Protocol response content (non-JSON) for Measurement ID %s, Client ID %s: %s\",\n                        measurement_id, client_id, response.text[:500]\n                    )\n            return True\n        else:\n            logger.error(\n                \"Failed to send event(s) to GA4: %s (Measurement ID: %s, Client ID: %s). Status: %d, Response: %s\",\n                event_names, measurement_id, client_id, response.status_code, response.text[:500]\n            )\n            return False\n    except httpx.TimeoutException:\n        logger.error(\n            \"Timeout sending event(s) to GA4: %s (Measurement ID: %s, Client ID: %s).\",\n            event_names, measurement_id, client_id\n        )\n        return False\n    except httpx.RequestError as e:\n        logger.error(\n            \"RequestError sending event(s) to GA4: %s (Measurement ID: %s, Client ID: %s): %s\",\n            event_names, measurement_id, client_id, e, exc_info=True\n        )\n        return False\n    except Exception as e:\n        logger.error(\n            \"Unexpected error sending event(s) to GA4: %s (Measurement ID: %s, Client ID: %s): %s\",\n            event_names, measurement_id, client_id, e, exc_info=True\n        )\n        return False\n"
    },
    {
      "path": "backend/services/submission_service.py",
      "content": "# backend/services/submission_service.py\nimport logging\nfrom typing import Optional, Dict, Any, Tuple, List # Added Tuple, List\nfrom supabase import Client\nfrom datetime import date, time, datetime # Added date, time, datetime\n\nlogger = logging.getLogger(__name__)\nCONTACT_SUBMISSIONS_TABLE = \"contact_submissions\"\n\nasync def update_submission_status(\n    db: Client,\n    tenant_id: str,\n    submission_id: int,\n    new_status: str,\n    reason: Optional[str] = None\n) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    Updates the 'submission_status' and 'status_change_reason' for a contact submission.\n\n    It's assumed that an 'updated_at' field in the 'contact_submissions' table\n    is handled by a database trigger or will be addressed in a separate schema update.\n    This function does not explicitly set 'updated_at'.\n\n    Args:\n        db: Supabase client instance.\n        submission_id: The ID of the submission to update.\n        new_status: The new status string.\n        reason: Optional reason for the status change. If None, the reason field\n                in the database will be set to NULL (or cleared).\n\n    Returns:\n        A dictionary representing the updated submission record if successful,\n        otherwise None.\n    \"\"\"\n    try:\n        update_data: Dict[str, Any] = {\"submission_status\": new_status}\n\n        # Set status_change_reason, explicitly setting to None if reason is not provided\n        # to ensure it clears any existing reason in the DB.\n        update_data[\"status_change_reason\"] = reason\n\n        response = (\n            db.table(CONTACT_SUBMISSIONS_TABLE)\n            .update(update_data)\n            .eq(\"id\", submission_id)\n            .eq(\"tenant_id\", tenant_id) # Add tenant_id filter\n            .execute()\n        )\n\n        if response.data and len(response.data) > 0:\n            logger.info(f\"Submission status updated for tenant_id: {tenant_id}, id: {submission_id} to '{new_status}'. Reason: '{reason if reason else 'N/A'}'\")\n            return response.data[0]\n        else:\n            logger.warning(\n                f\"Failed to update submission status for tenant_id: {tenant_id}, id: {submission_id}. Record not found or no data returned. \"\n                f\"Supabase response: {response.model_dump_json() if hasattr(response, 'model_dump_json') else str(response)}\"\n            )\n            return None\n    except Exception as e:\n        logger.error(f\"Exception updating submission status for tenant_id: {tenant_id}, id: {submission_id}: {e}\", exc_info=True)\n        return None\n\nasync def list_submissions(\n    db: Client,\n    tenant_id: str, # Added tenant_id\n    skip: int = 0,\n    limit: int = 20,\n    form_id: Optional[str] = None,\n    submission_status: Optional[str] = None,\n    email: Optional[str] = None,\n    name: Optional[str] = None,\n    start_date: Optional[date] = None,\n    end_date: Optional[date] = None,\n    sort_by: Optional[str] = \"created_at\", # Default sort\n    sort_order: Optional[str] = \"desc\",   # Default order\n) -> Tuple[List[Dict[str, Any]], int]:\n    \"\"\"\n    Lists contact submissions for a specific tenant with filtering, pagination, and sorting.\n    Returns a tuple of (list of submission records as dictionaries, total_count).\n    Note: The Supabase client's execute() method is synchronous. For true async\n    behavior in a FastAPI async endpoint, this should be run in a thread pool\n    (e.g., using fastapi.concurrency.run_in_threadpool).\n    \"\"\"\n    try:\n        query = db.table(CONTACT_SUBMISSIONS_TABLE).select(\"*\", count=\"exact\").eq(\"tenant_id\", tenant_id)\n\n        # Apply other filters\n        if form_id:\n            query = query.eq(\"form_id\", form_id)\n        if submission_status:\n            query = query.eq(\"submission_status\", submission_status)\n        if email:\n            query = query.ilike(\"email\", f\"%{email}%\")\n        if name:\n            query = query.ilike(\"name\", f\"%{name}%\")\n\n        if start_date:\n            # Combine with min time and convert to ISO format string for Supabase\n            start_datetime_iso = datetime.combine(start_date, time.min).isoformat()\n            query = query.gte(\"created_at\", start_datetime_iso)\n        if end_date:\n            # Combine with max time and convert to ISO format string\n            end_datetime_iso = datetime.combine(end_date, time.max).isoformat()\n            query = query.lte(\"created_at\", end_datetime_iso)\n\n        # Apply sorting\n        # Ensure sort_by is a valid column name to prevent injection-like issues if it were user-supplied without validation.\n        # Here, it's from a Query(enum=[...]) in the router, so it's relatively safe.\n        if sort_by and sort_order:\n            is_ascending = sort_order.lower() == \"asc\"\n            query = query.order(sort_by, desc=not is_ascending)\n\n        # Apply pagination\n        # Supabase range is inclusive for 'to', so skip + limit - 1\n        query = query.range(skip, skip + limit - 1)\n\n        # Execute the query (synchronous call)\n        response = query.execute()\n\n        submissions = response.data if response.data else []\n        total_count = response.count if response.count is not None else 0 # Get total count from 'exact'\n\n        logger.debug(f\"Listed {len(submissions)} submissions for tenant_id {tenant_id} (skip={skip}, limit={limit}) with total_count {total_count} matching criteria.\")\n        return submissions, total_count\n\n    except Exception as e:\n        logger.error(f\"Exception listing submissions for tenant_id {tenant_id} with criteria (form_id={form_id}, status={submission_status}, etc.): {e}\", exc_info=True)\n        return [], 0\n"
    },
    {
      "path": "backend/services/tenant_service.py",
      "content": "# backend/services/tenant_service.py\nimport logging\nfrom typing import List, Optional, Dict, Any, Tuple\nfrom uuid import UUID # For type hinting UUID\nfrom supabase import Client\nfrom backend.models.tenant_models import TenantCreatePayload, TenantUpdatePayload\n# from datetime import datetime, timezone # Not explicitly setting updated_at here, relying on DB trigger\n\nlogger = logging.getLogger(__name__)\nTENANTS_TABLE = \"tenants\" # Table name constant\n\nasync def create_tenant(db: Client, payload: TenantCreatePayload) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    Creates a new tenant. tenant_id is auto-generated by the database.\n    Returns the created tenant record as a dictionary, or None on failure.\n    \"\"\"\n    try:\n        data_to_insert = payload.model_dump()\n        # tenant_id is expected to be defaulted by gen_random_uuid() in the DB schema\n        response = db.table(TENANTS_TABLE).insert(data_to_insert).execute()\n\n        if response.data and len(response.data) > 0:\n            created_tenant = response.data[0]\n            logger.info(f\"Tenant created: {created_tenant.get('company_name')} (ID: {created_tenant.get('tenant_id')})\")\n            return created_tenant\n        else:\n            logger.error(\n                f\"Failed to create tenant, Supabase response did not contain data. Payload: {payload.model_dump_json()}. \"\n                f\"Response: {response.model_dump_json() if hasattr(response, 'model_dump_json') else str(response)}\"\n            )\n            return None\n    except Exception as e: # Consider catching specific Supabase/PostgREST exceptions if available\n        logger.error(f\"Exception creating tenant ({payload.company_name}): {e}\", exc_info=True)\n        return None\n\nasync def get_tenant(db: Client, tenant_id: UUID) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    Retrieves a specific tenant by its UUID.\n    Returns the tenant record as a dictionary, or None if not found.\n    \"\"\"\n    try:\n        response = db.table(TENANTS_TABLE).select(\"*\").eq(\"tenant_id\", str(tenant_id)).maybe_single().execute()\n        # maybe_single() returns data as dict if found, None if no rows (and no error raised for 0 rows)\n        if response.data:\n            logger.debug(f\"Tenant found: {tenant_id}\")\n            return response.data\n        else:\n            logger.debug(f\"Tenant not found: {tenant_id}\")\n            return None\n    except Exception as e:\n        logger.error(f\"Exception retrieving tenant {tenant_id}: {e}\", exc_info=True)\n        return None\n\nasync def list_tenants(\n    db: Client, skip: int = 0, limit: int = 20, show_deleted: bool = False\n) -> Tuple[List[Dict[str, Any]], int]:\n    \"\"\"\n    Lists tenants with pagination and an option to include logically deleted ones.\n    Returns a tuple: (list of tenant records, total_count).\n    \"\"\"\n    try:\n        query = db.table(TENANTS_TABLE).select(\"*\", count=\"exact\")\n        if not show_deleted:\n            query = query.eq(\"is_deleted\", False)\n\n        query = query.order(\"company_name\", desc=False).range(skip, skip + limit - 1) # Default sort by company_name asc\n        response = query.execute()\n\n        tenants = response.data if response.data else []\n        total_count = response.count if response.count is not None else 0\n        logger.debug(f\"Listed {len(tenants)} tenants (total: {total_count}, skip: {skip}, limit: {limit}, show_deleted: {show_deleted})\")\n        return tenants, total_count\n    except Exception as e:\n        logger.error(f\"Exception listing tenants: {e}\", exc_info=True)\n        return [], 0\n\nasync def update_tenant(\n    db: Client, tenant_id: UUID, payload: TenantUpdatePayload\n) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    Updates an existing tenant. Only fields present in the payload are updated.\n    Returns the updated tenant record as a dictionary, or None if not found or update failed.\n    Assumes updated_at is handled by a DB trigger.\n    \"\"\"\n    try:\n        data_to_update = payload.model_dump(exclude_unset=True)\n        if not data_to_update:\n            logger.info(f\"No fields to update for tenant_id: {tenant_id}. Returning current record.\")\n            return await get_tenant(db, tenant_id)\n\n        response = db.table(TENANTS_TABLE).update(data_to_update).eq(\"tenant_id\", str(tenant_id)).execute()\n\n        if response.data and len(response.data) > 0:\n            updated_tenant = response.data[0]\n            logger.info(f\"Tenant updated: {tenant_id}. New company name: {updated_tenant.get('company_name')}\")\n            return updated_tenant\n        else:\n            logger.warning(\n                f\"Failed to update tenant {tenant_id} (it may not exist or no data returned). \"\n                f\"Update payload: {data_to_update}. Supabase response: {response.model_dump_json() if hasattr(response, 'model_dump_json') else str(response)}\"\n            )\n            return None\n    except Exception as e:\n        logger.error(f\"Exception updating tenant {tenant_id}: {e}\", exc_info=True)\n        return None\n\nasync def delete_tenant(db: Client, tenant_id: UUID, hard_delete: bool = False) -> bool:\n    \"\"\"\n    Logically or physically deletes a tenant.\n    For logical delete, sets is_deleted = True.\n    Returns True if operation was successful (or record already in desired state for logical delete),\n    False on error or if record not found for hard delete.\n    \"\"\"\n    try:\n        if hard_delete:\n            logger.warning(f\"Performing HARD delete for tenant_id: {tenant_id}\")\n            response = db.table(TENANTS_TABLE).delete().eq(\"tenant_id\", str(tenant_id)).execute()\n            # For hard delete, success means data was returned (i.e., something was deleted)\n            if response.data and len(response.data) > 0:\n                 logger.info(f\"Tenant hard deleted: {tenant_id}\")\n                 return True\n            logger.warning(f\"Tenant {tenant_id} not found for hard delete, or no data returned from operation.\")\n            return False # Nothing was deleted\n        else: # Logical delete\n            # Check if already deleted to avoid unnecessary update and log spam\n            current_tenant = await get_tenant(db, tenant_id)\n            if current_tenant is None:\n                logger.warning(f\"Tenant {tenant_id} not found for logical delete.\")\n                return False # Not found\n            if current_tenant.get(\"is_deleted\") is True:\n                logger.info(f\"Tenant {tenant_id} is already logically deleted.\")\n                return True # Already in desired state\n\n            response = db.table(TENANTS_TABLE).update({\"is_deleted\": True}).eq(\"tenant_id\", str(tenant_id)).execute()\n            if response.data and len(response.data) > 0:\n                logger.info(f\"Tenant logically deleted: {tenant_id}\")\n                return True\n            logger.warning(f\"Failed to logically delete tenant {tenant_id} (no data returned from update).\")\n            return False # Update didn't affect any rows as expected\n\n    except Exception as e:\n        logger.error(f\"Exception during delete operation for tenant {tenant_id} (hard_delete={hard_delete}): {e}\", exc_info=True)\n        return False\n"
    },
    {
      "path": "backend/tests/test_ai_agent.py",
      "content": "# backend/tests/test_ai_agent.py\nimport pytest\nfrom unittest.mock import MagicMock, patch, ANY as AnyMockValue, call\nimport logging # For logger type hints and levels if needed by before_sleep_log\n\n# It's assumed that the following can be imported from the SUT (System Under Test)\n# This might require specific PYTHONPATH setup for the test runner.\n# For subtask execution, if these cannot be resolved, the test might rely on patching\n# at a higher level or the subtask might need to adjust paths/mocking.\ntry:\n    from backend.ai_agent import get_chat_response # The SUT\n    from backend.config import Settings # For type hinting mock_settings if needed\n    from google.adk.events import Event # Type used in ai_agent.py\nexcept ImportError as e:\n    # Fallback for subtask environment if imports fail\n    # This indicates a potential issue with how tests would run in the actual project\n    # and should ideally be resolved by proper test environment setup.\n    logging.getLogger(__name__).warning(f\"Import error in test_ai_agent.py: {e}. Using placeholders.\")\n    # Define dummy/placeholder for Event if needed for mock spec, or rely on MagicMock's flexibility\n    class Event: pass\n    # get_chat_response will be patched or tested via API if direct import fails robustly\n\n\n# Fixture to mock ai_agent.settings for controlling retry parameters in tests\n@pytest.fixture\ndef mock_ai_agent_settings(mocker):\n    # Patch the settings instance within the ai_agent module\n    mock_settings_instance = mocker.patch(\"backend.ai_agent.settings\")\n\n    mock_settings_instance.ai_agent_retry_attempts = 3\n    mock_settings_instance.ai_agent_retry_wait_initial_seconds = 0.01 # Very short for testing\n    mock_settings_instance.ai_agent_retry_wait_multiplier = 1 # No exponential backoff for faster tests\n    mock_settings_instance.ai_agent_retry_wait_max_seconds = 0.05 # Short max wait\n    return mock_settings_instance\n\n# Test cases\n@patch(\"backend.ai_agent.agent_runner\") # Mock the global agent_runner in ai_agent.py\n@patch(\"backend.ai_agent.logger\")      # Mock the logger in ai_agent.py\nasync def test_get_chat_response_success_first_try(\n    mock_logger, mock_runner, mock_ai_agent_settings # Fixture is injected\n):\n    # Ensure AGENT_INITIALIZED_SUCCESSFULLY is True for these tests\n    # This is a module-level variable in ai_agent.py\n    with patch(\"backend.ai_agent.AGENT_INITIALIZED_SUCCESSFULLY\", True):\n        mock_event = MagicMock(spec=Event)\n        mock_event.error_message = None\n        # Simulate a valid JSON response structure\n        mock_event.actions = [MagicMock(parts=[MagicMock(text='{\"message\": \"AI Success\", \"require_form_after_message\": false}')])]\n        mock_event.session_id = \"session_success_1st\" # Ensure runner's event can set this\n\n        mock_runner.run.return_value = mock_event\n\n        # Directly import and call the decorated function\n        from backend.ai_agent import get_chat_response\n        reply, session_id, require_form = await get_chat_response(\"hello\", \"session_success_1st_input\")\n\n    assert reply == \"AI Success\"\n    assert session_id == \"session_success_1st\" # Check if session_id from event is used\n    assert require_form is False\n    mock_runner.run.assert_called_once_with(request=\"hello\", session_id=\"session_success_1st_input\")\n    # Check that no retry warning logs were made\n    assert not any(\"Retrying AI Agent call\" in c[0][0] for c in mock_logger.warning.call_args_list if isinstance(c[0][0], str))\n\n\n@patch(\"backend.ai_agent.agent_runner\")\n@patch(\"backend.ai_agent.logger\")\nasync def test_get_chat_response_retry_then_success(\n    mock_logger, mock_runner, mock_ai_agent_settings\n):\n    with patch(\"backend.ai_agent.AGENT_INITIALIZED_SUCCESSFULLY\", True):\n        mock_event_success = MagicMock(spec=Event)\n        mock_event_success.error_message = None\n        mock_event_success.actions = [MagicMock(parts=[MagicMock(text='{\"message\": \"AI Retry Success\", \"require_form_after_message\": true}')])]\n        mock_event_success.session_id = \"session_retry_success\"\n\n        mock_runner.run.side_effect = [\n            RuntimeError(\"Simulated network error\"), # First call fails\n            mock_event_success                     # Second call succeeds\n        ]\n        from backend.ai_agent import get_chat_response\n        reply, session_id, require_form = await get_chat_response(\"retry please\", \"session_retry_input\")\n\n    assert reply == \"AI Retry Success\"\n    assert require_form is True\n    assert session_id == \"session_retry_success\"\n    assert mock_runner.run.call_count == 2 # Initial call + 1 retry\n    # Check if tenacity's before_sleep_log (which logs at WARNING) was called once\n    assert mock_logger.warning.call_count == 1\n    # Example check for log content if needed:\n    # mock_logger.warning.assert_any_call(AnyMockValue(containing=\"Retrying AI Agent call\"))\n\n\n@patch(\"backend.ai_agent.agent_runner\")\n@patch(\"backend.ai_agent.logger\")\nasync def test_get_chat_response_retry_all_attempts_fail(\n    mock_logger, mock_runner, mock_ai_agent_settings\n):\n    with patch(\"backend.ai_agent.AGENT_INITIALIZED_SUCCESSFULLY\", True):\n        # Make all attempts fail\n        mock_runner.run.side_effect = RuntimeError(\"Persistent failure\")\n\n        from backend.ai_agent import get_chat_response\n        reply, session_id, require_form = await get_chat_response(\"this will fail\", \"session_fail_all\")\n\n    assert \"AI Agent Error after retries\" in reply\n    assert require_form is False\n    assert session_id == \"session_fail_all\" # Original session_id should be returned on full failure\n    assert mock_runner.run.call_count == mock_ai_agent_settings.ai_agent_retry_attempts\n    # Number of sleeps (and thus before_sleep_log calls) is attempts - 1\n    assert mock_logger.warning.call_count == mock_ai_agent_settings.ai_agent_retry_attempts - 1\n    # Check for the final error log after all retries are exhausted\n    mock_logger.error.assert_called_once()\n    # More specific check for the error log content\n    args, kwargs = mock_logger.error.call_args\n    assert \"AI Agent call failed after %s attempts\" in args[0]\n    assert args[1] == mock_ai_agent_settings.ai_agent_retry_attempts\n    assert args[2] == \"session_fail_all\"\n\n\n@patch(\"backend.ai_agent.logger\") # Only logger needed for this, agent_runner not called\nasync def test_get_chat_response_agent_not_initialized_import_failed(mock_logger):\n    # Simulate ADK_IMPORTED_SUCCESSFULLY = False, AGENT_INITIALIZED_SUCCESSFULLY = False\n    with patch(\"backend.ai_agent.AGENT_INITIALIZED_SUCCESSFULLY\", False), \\\n         patch(\"backend.ai_agent.ADK_IMPORTED_SUCCESSFULLY\", False):\n        from backend.ai_agent import get_chat_response\n        reply, session_id, require_form = await get_chat_response(\"query to broken agent\", \"session_broken_1\")\n\n    assert \"AI Agent is unavailable due to missing dependencies\" in reply\n    assert require_form is False\n    # Check the debug log for fallback reason\n    # The actual log message in get_chat_response is \"Serving fallback because ADK components not imported.\"\n    # and it's logged via logger.debug, not logger.warning for this specific case.\n    # The prompt has logger.warning.assert_any_call for these, let's adjust if the code uses debug.\n    # Based on ai_agent.py: logger.debug(\"Serving fallback because ADK components not imported.\")\n    # So, this test case should check logger.debug.\n    # However, the prompt's test code uses mock_logger.warning.assert_any_call.\n    # For consistency with the prompt, I'll assume the test logic is what's desired.\n    # If the actual log level is different, this assertion would need to change.\n    # The current ai_agent.py logs these fallback reasons at DEBUG level.\n    # The test prompt specified: mock_logger.warning.assert_any_call\n    # Let's assume for the test that the logger in get_chat_response for this was changed to warning,\n    # or the test intent is to ensure *some* log indicates the fallback.\n    # For now, I will keep the test as per prompt, but this might be a discrepancy.\n    # Looking at the actual code:\n    # logger.debug(\"Serving fallback because ADK components not imported.\")\n    # logger.debug(\"Serving fallback because AI Agent failed to initialize.\")\n    # The tests should check logger.debug for these specific messages.\n    # I will adjust the test to check logger.debug as per the actual implementation.\n\n    # Corrected assertion based on actual implementation logging level\n    found_log = False\n    for call_args in mock_logger.debug.call_args_list:\n        if \"Serving fallback because ADK components not imported.\" in call_args[0][0]:\n            found_log = True\n            break\n    assert found_log, \"Expected debug log for ADK import failure not found.\"\n\n\n@patch(\"backend.ai_agent.logger\") # Only logger needed\nasync def test_get_chat_response_agent_not_initialized_init_failed(mock_logger):\n    # Simulate ADK_IMPORTED_SUCCESSFULLY = True, AGENT_INITIALIZED_SUCCESSFULLY = False\n    with patch(\"backend.ai_agent.AGENT_INITIALIZED_SUCCESSFULLY\", False), \\\n         patch(\"backend.ai_agent.ADK_IMPORTED_SUCCESSFULLY\", True):\n        from backend.ai_agent import get_chat_response\n        reply, session_id, require_form = await get_chat_response(\"query to broken agent\", \"session_broken_2\")\n\n    assert \"AI Agent is currently experiencing setup issues\" in reply\n    assert require_form is False\n    # Corrected assertion based on actual implementation logging level\n    found_log = False\n    for call_args in mock_logger.debug.call_args_list:\n        if \"Serving fallback because AI Agent failed to initialize.\" in call_args[0][0]:\n            found_log = True\n            break\n    assert found_log, \"Expected debug log for AI agent initialization failure not found.\"\n"
    },
    {
      "path": "backend/tests/test_contact_api.py",
      "content": "import pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import MagicMock, patch\nfrom datetime import datetime, timezone # Added timezone for created_at comparison\nfrom typing import Optional, Dict, Any, List\n\n# Attempt to import app and models from the correct location\n# This assumes tests are run from a context where 'backend' is a discoverable module\ntry:\n    from backend.contact_api import app\n    from backend.db import get_supabase_client # For patching\n    from backend.contact_api import ContactFormPayload # For type hints if needed, though not strictly for dicts\nexcept ImportError:\n    # Fallback for subtask execution if direct import fails\n    from contact_api import app # type: ignore\n    from db import get_supabase_client # type: ignore\n    from contact_api import ContactFormPayload # type: ignore\n\nclient = TestClient(app)\n\n# --- Helper Function for Payload ---\ndef get_valid_payload_dict(form_id: Optional[str] = \"test-form-123\") -> Dict[str, Any]:\n    return {\n        \"name\": \"Test User\",\n        \"email\": \"test@example.com\",\n        \"message\": \"This is a test message.\",\n        \"ga_client_id\": \"ga-client-id-example\",\n        \"ga_session_id\": \"ga-session-id-example\",\n        \"form_id\": form_id,\n    }\n\n# --- Test Cases ---\n\ndef test_submit_form_success_sends_ga4_event_when_configured(mocker): # Renamed\n    payload = get_valid_payload_dict() # This includes form_id and ga_client_id\n\n    mock_supabase_client = MagicMock()\n    mock_insert_response = MagicMock()\n    mock_created_at_iso = datetime.now(timezone.utc).isoformat()\n    inserted_record_data = {**payload, \"id\": 1, \"created_at\": mock_created_at_iso}\n    mock_insert_response.data = [inserted_record_data]\n    mock_supabase_client.table.return_value.insert.return_value.execute.return_value = mock_insert_response\n\n    # Mock GA4 services\n    mock_get_ga_config = mocker.patch(\"backend.contact_api.form_ga_config_service.get_ga_configuration\")\n    mock_send_ga4_event = mocker.patch(\"backend.contact_api.ga4_mp_service.send_ga4_event\")\n\n    mock_ga_config_data = {\n        \"form_id\": payload[\"form_id\"],\n        \"ga4_measurement_id\": \"G-VALIDMEASUREMENTID\",\n        \"ga4_api_secret\": \"validapisecret\"\n    }\n    mock_get_ga_config.return_value = mock_ga_config_data\n    mock_send_ga4_event.return_value = True # Simulate successful send\n\n    with patch(\"backend.contact_api.get_supabase_client\", return_value=mock_supabase_client):\n        response = client.post(\"/submit\", json=payload)\n\n    assert response.status_code == 200\n    response_data = response.json()\n    assert response_data[\"id\"] == 1\n\n    mock_supabase_client.table.return_value.insert.assert_called_once_with([payload])\n\n    # Assert GA4 mocks\n    mock_get_ga_config.assert_called_once_with(mock_supabase_client, payload[\"form_id\"])\n\n    expected_event_params = {\n        \"event_category\": \"contact_form\",\n        \"event_label\": payload[\"form_id\"],\n        \"session_id\": payload[\"ga_session_id\"]\n    }\n    mock_send_ga4_event.assert_called_once_with(\n        api_secret=mock_ga_config_data[\"ga4_api_secret\"],\n        measurement_id=mock_ga_config_data[\"ga4_measurement_id\"],\n        client_id=payload[\"ga_client_id\"],\n        events=[{\"name\": \"generate_lead\", \"params\": expected_event_params}]\n    )\n\ndef test_submit_form_success_minimal_fields_skips_ga4_event(mocker): # Updated name and assertions\n    minimal_payload = {\n        \"name\": \"Minimal User\",\n        \"email\": \"minimal@example.com\",\n        \"message\": \"Minimal message.\",\n    }\n    # form_id, ga_client_id, ga_session_id are omitted, will default to None\n\n    mock_supabase_client = MagicMock()\n    mock_insert_response = MagicMock()\n    mock_created_at_iso = datetime.now(timezone.utc).isoformat()\n    data_as_inserted = {\n        \"name\": \"Minimal User\", \"email\": \"minimal@example.com\", \"message\": \"Minimal message.\",\n        \"ga_client_id\": None, \"ga_session_id\": None, \"form_id\": None\n    }\n    inserted_record_data = {**data_as_inserted, \"id\": 2, \"created_at\": mock_created_at_iso}\n    mock_insert_response.data = [inserted_record_data]\n    mock_supabase_client.table.return_value.insert.return_value.execute.return_value = mock_insert_response\n\n    # Mock GA4 services to ensure they are NOT called\n    mock_get_ga_config = mocker.patch(\"backend.contact_api.form_ga_config_service.get_ga_configuration\")\n    mock_send_ga4_event = mocker.patch(\"backend.contact_api.ga4_mp_service.send_ga4_event\")\n\n    with patch(\"backend.contact_api.get_supabase_client\", return_value=mock_supabase_client):\n        response = client.post(\"/submit\", json=minimal_payload)\n\n    assert response.status_code == 200\n    response_data = response.json()\n    assert response_data[\"name\"] == \"Minimal User\"\n    assert response_data[\"id\"] == 2\n    assert response_data[\"form_id\"] is None\n    assert response_data[\"ga_client_id\"] is None\n\n    mock_supabase_client.table.return_value.insert.assert_called_once_with([data_as_inserted])\n\n    # Assert GA4 mocks were NOT called\n    mock_get_ga_config.assert_not_called()\n    mock_send_ga4_event.assert_not_called()\n\n\ndef test_submit_form_success_ga4_config_not_found_skips_event(mocker):\n    payload = get_valid_payload_dict() # This includes form_id and ga_client_id\n\n    mock_supabase_client = MagicMock()\n    mock_insert_response = MagicMock()\n    mock_created_at_iso = datetime.now(timezone.utc).isoformat()\n    inserted_record_data = {**payload, \"id\": 3, \"created_at\": mock_created_at_iso}\n    mock_insert_response.data = [inserted_record_data]\n    mock_supabase_client.table.return_value.insert.return_value.execute.return_value = mock_insert_response\n\n    # Mock GA4 services\n    mock_get_ga_config = mocker.patch(\"backend.contact_api.form_ga_config_service.get_ga_configuration\")\n    mock_send_ga4_event = mocker.patch(\"backend.contact_api.ga4_mp_service.send_ga4_event\")\n\n    mock_get_ga_config.return_value = None # Simulate GA4 config not found\n\n    with patch(\"backend.contact_api.get_supabase_client\", return_value=mock_supabase_client):\n        response = client.post(\"/submit\", json=payload)\n\n    assert response.status_code == 200\n    assert response.json()[\"id\"] == 3\n\n    mock_get_ga_config.assert_called_once_with(mock_supabase_client, payload[\"form_id\"])\n    mock_send_ga4_event.assert_not_called()\n\n\ndef test_submit_form_supabase_client_unavailable(mocker):\n    with patch(\"backend.contact_api.get_supabase_client\", return_value=None):\n        response = client.post(\"/submit\", json=get_valid_payload_dict())\n\n    assert response.status_code == 503\n    assert response.json() == {\"detail\": \"Database service is currently unavailable. Please try again later.\"}\n\ndef test_submit_form_supabase_insert_api_error(mocker): # Renamed for clarity (APIError from Supabase)\n    mock_supabase_client = MagicMock()\n    # Simulate an error from Supabase client, e.g., PostgrestAPIError\n    # For simplicity, just making execute raise a generic Exception here.\n    # A more specific Supabase exception could be mocked if needed.\n    mock_supabase_client.table.return_value.insert.return_value.execute.side_effect = Exception(\"Supabase DB error\")\n\n    with patch(\"backend.contact_api.get_supabase_client\", return_value=mock_supabase_client):\n        response = client.post(\"/submit\", json=get_valid_payload_dict())\n\n    assert response.status_code == 500\n    # The detail message in endpoint is generic for non-HTTPExceptions\n    assert response.json() == {\"detail\": \"An error occurred while processing your request.\"}\n\n\ndef test_submit_form_supabase_insert_returns_no_data(mocker):\n    mock_supabase_client = MagicMock()\n    mock_empty_response = MagicMock()\n    mock_empty_response.data = [] # Supabase returns empty data list\n    mock_supabase_client.table.return_value.insert.return_value.execute.return_value = mock_empty_response\n\n    with patch(\"backend.contact_api.get_supabase_client\", return_value=mock_supabase_client):\n        response = client.post(\"/submit\", json=get_valid_payload_dict())\n\n    assert response.status_code == 500\n    assert response.json() == {\"detail\": \"Failed to save submission: No data returned from database operation.\"}\n\ndef test_submit_form_missing_required_field_name(client): # More specific test name\n    # 'name' is a required field in ContactFormPayload\n    invalid_payload_missing_name = {\n        \"email\": \"invalid@example.com\",\n        \"message\": \"Message for submission missing name.\",\n        \"form_id\": \"form-no-name\"\n    }\n    response = client.post(\"/submit\", json=invalid_payload_missing_name)\n    assert response.status_code == 422 # FastAPI validation error\n    response_data = response.json()\n    assert \"detail\" in response_data\n    # Check if 'name' field is reported as missing\n    field_error_found = False\n    for error in response_data[\"detail\"]:\n        if error.get(\"type\") == \"missing\" and \"name\" in error.get(\"loc\", []):\n            field_error_found = True\n            break\n    assert field_error_found, \"Error detail for missing 'name' field not found.\"\n"
    },
    {
      "path": "backend/tests/test_form_ga_config_api.py",
      "content": "import pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import MagicMock, patch\nfrom datetime import datetime, timezone\nfrom typing import List, Dict, Any, Optional\n\n# Attempt to import app and other necessary components\ntry:\n    from backend.contact_api import app\n    # For patching, we need the actual path to the dependency used in the router\n    # from backend.db import get_supabase_client # Not directly used if router import is patched\n    # from backend.contact_api import get_current_active_user # Same as above\nexcept ImportError:\n    from contact_api import app # type: ignore\n\n\nclient = TestClient(app)\n\n# --- Mock Data & Helpers ---\nBASE_PATH = \"/api/v1/ga_configurations\"\nTEST_FORM_ID = \"test-form-for-ga\"\nMOCK_USER = {\"username\": \"testuser\"}\n\ndef mock_ga_config_payload_dict(form_id_override: Optional[str] = None) -> Dict[str, Any]:\n    return {\n        \"form_id\": form_id_override or TEST_FORM_ID,\n        \"ga4_measurement_id\": \"G-TEST12345\",\n        \"ga4_api_secret\": \"test_api_secret_value\",\n        \"description\": \"Test GA4 Configuration\"\n    }\n\ndef mock_db_record_dict(payload: Dict[str, Any]) -> Dict[str, Any]:\n    now_iso = datetime.now(timezone.utc).isoformat()\n    return {\n        **payload,\n        \"created_at\": now_iso,\n        \"updated_at\": now_iso\n    }\n\n# --- Test Cases ---\n\n@patch(\"backend.routers.form_ga_config_router.get_current_active_user\", return_value=MOCK_USER)\n@patch(\"backend.routers.form_ga_config_router.get_supabase_client\")\n@patch(\"backend.services.form_ga_config_service.create_ga_configuration\")\n@patch(\"backend.services.form_ga_config_service.get_ga_configuration\") # For pre-check\ndef test_create_ga_configuration_success(mock_get_config, mock_create_config, mock_get_supabase, mock_auth, client):\n    payload = mock_ga_config_payload_dict()\n\n    mock_get_supabase.return_value = MagicMock() # Simulate available Supabase client\n    mock_get_config.return_value = None # Simulate no existing config\n    mock_create_config.return_value = mock_db_record_dict(payload)\n\n    response = client.post(BASE_PATH, json=payload)\n\n    assert response.status_code == 201\n    response_data = response.json()\n    assert response_data[\"form_id\"] == TEST_FORM_ID\n    assert response_data[\"ga4_measurement_id\"] == \"G-TEST12345\"\n    mock_create_config.assert_called_once()\n\n@patch(\"backend.routers.form_ga_config_router.get_current_active_user\", return_value=MOCK_USER)\n@patch(\"backend.routers.form_ga_config_router.get_supabase_client\")\n@patch(\"backend.services.form_ga_config_service.get_ga_configuration\")\ndef test_create_ga_configuration_already_exists(mock_get_config, mock_get_supabase, mock_auth, client):\n    payload = mock_ga_config_payload_dict()\n    mock_get_supabase.return_value = MagicMock()\n    mock_get_config.return_value = mock_db_record_dict(payload) # Simulate existing config\n\n    response = client.post(BASE_PATH, json=payload)\n\n    assert response.status_code == 409\n\n@patch(\"backend.routers.form_ga_config_router.get_current_active_user\", return_value=MOCK_USER)\n@patch(\"backend.routers.form_ga_config_router.get_supabase_client\")\n@patch(\"backend.services.form_ga_config_service.get_ga_configuration\")\ndef test_get_ga_configuration_success(mock_get_config, mock_get_supabase, mock_auth, client):\n    db_record = mock_db_record_dict(mock_ga_config_payload_dict())\n    mock_get_supabase.return_value = MagicMock()\n    mock_get_config.return_value = db_record\n\n    response = client.get(f\"{BASE_PATH}/{TEST_FORM_ID}\")\n\n    assert response.status_code == 200\n    response_data = response.json()\n    assert response_data[\"form_id\"] == TEST_FORM_ID\n    assert response_data[\"ga4_measurement_id\"] == db_record[\"ga4_measurement_id\"]\n\n@patch(\"backend.routers.form_ga_config_router.get_current_active_user\", return_value=MOCK_USER)\n@patch(\"backend.routers.form_ga_config_router.get_supabase_client\")\n@patch(\"backend.services.form_ga_config_service.get_ga_configuration\")\ndef test_get_ga_configuration_not_found(mock_get_config, mock_get_supabase, mock_auth, client):\n    mock_get_supabase.return_value = MagicMock()\n    mock_get_config.return_value = None # Simulate not found\n\n    response = client.get(f\"{BASE_PATH}/{TEST_FORM_ID}\")\n\n    assert response.status_code == 404\n\n@patch(\"backend.routers.form_ga_config_router.get_current_active_user\", return_value=MOCK_USER)\n@patch(\"backend.routers.form_ga_config_router.get_supabase_client\")\n@patch(\"backend.services.form_ga_config_service.list_ga_configurations\")\ndef test_list_ga_configurations_success(mock_list_configs, mock_get_supabase, mock_auth, client):\n    mock_get_supabase.return_value = MagicMock()\n    payload1 = mock_ga_config_payload_dict(form_id_override=\"form1\")\n    payload2 = mock_ga_config_payload_dict(form_id_override=\"form2\")\n    db_records = [mock_db_record_dict(payload1), mock_db_record_dict(payload2)]\n    mock_list_configs.return_value = db_records\n\n    response = client.get(BASE_PATH)\n\n    assert response.status_code == 200\n    response_data = response.json()\n    assert len(response_data[\"configurations\"]) == 2\n    assert response_data[\"configurations\"][0][\"form_id\"] == \"form1\"\n\n@patch(\"backend.routers.form_ga_config_router.get_current_active_user\", return_value=MOCK_USER)\n@patch(\"backend.routers.form_ga_config_router.get_supabase_client\")\n@patch(\"backend.services.form_ga_config_service.update_ga_configuration\")\ndef test_update_ga_configuration_success(mock_update_config, mock_get_supabase, mock_auth, client):\n    update_payload = {\"description\": \"Updated Test Description\"}\n    # Original payload for context, though service mock determines outcome\n    original_payload = mock_ga_config_payload_dict()\n    updated_db_record = mock_db_record_dict({**original_payload, **update_payload})\n\n    mock_get_supabase.return_value = MagicMock()\n    mock_update_config.return_value = updated_db_record\n\n    response = client.put(f\"{BASE_PATH}/{TEST_FORM_ID}\", json=update_payload)\n\n    assert response.status_code == 200\n    response_data = response.json()\n    assert response_data[\"description\"] == \"Updated Test Description\"\n    assert response_data[\"form_id\"] == TEST_FORM_ID\n    mock_update_config.assert_called_once()\n\n@patch(\"backend.routers.form_ga_config_router.get_current_active_user\", return_value=MOCK_USER)\n@patch(\"backend.routers.form_ga_config_router.get_supabase_client\")\n@patch(\"backend.services.form_ga_config_service.update_ga_configuration\")\ndef test_update_ga_configuration_not_found(mock_update_config, mock_get_supabase, mock_auth, client):\n    update_payload = {\"description\": \"NonExistent Update\"}\n    mock_get_supabase.return_value = MagicMock()\n    mock_update_config.return_value = None # Simulate not found by service\n\n    response = client.put(f\"{BASE_PATH}/{TEST_FORM_ID}\", json=update_payload)\n\n    assert response.status_code == 404\n\n@patch(\"backend.routers.form_ga_config_router.get_current_active_user\", return_value=MOCK_USER)\n@patch(\"backend.routers.form_ga_config_router.get_supabase_client\")\n@patch(\"backend.services.form_ga_config_service.delete_ga_configuration\")\ndef test_delete_ga_configuration_success(mock_delete_config, mock_get_supabase, mock_auth, client):\n    mock_get_supabase.return_value = MagicMock()\n    mock_delete_config.return_value = True # Simulate successful deletion\n\n    response = client.delete(f\"{BASE_PATH}/{TEST_FORM_ID}\")\n\n    assert response.status_code == 204\n\n@patch(\"backend.routers.form_ga_config_router.get_current_active_user\", return_value=MOCK_USER)\n@patch(\"backend.routers.form_ga_config_router.get_supabase_client\")\n@patch(\"backend.services.form_ga_config_service.delete_ga_configuration\")\ndef test_delete_ga_configuration_not_found(mock_delete_config, mock_get_supabase, mock_auth, client):\n    mock_get_supabase.return_value = MagicMock()\n    mock_delete_config.return_value = False # Simulate record not found or delete failed\n\n    response = client.delete(f\"{BASE_PATH}/{TEST_FORM_ID}\")\n\n    assert response.status_code == 404\n\n# It's important that the patch paths like \"backend.routers.form_ga_config_router.get_supabase_client\"\n# correctly point to where these names are looked up *within the context of the router file*.\n# If get_supabase_client is imported as `from backend.db import get_supabase_client` in the router,\n# then the patch path should be \"backend.routers.form_ga_config_router.get_supabase_client\" if that's how it's referenced,\n# or \"backend.db.get_supabase_client\" if you want to patch it at its source (which affects all uses).\n# Patching where it's *used* (in the router) is often more targeted for testing the router's logic.\n# The current patching style uses decorators, which apply to the whole function.\n# `client` is assumed to be a TestClient instance provided by pytest (e.g. via fixture or global).\n"
    },
    {
      "path": "backend/tests/test_submission_api.py",
      "content": "# backend/tests/test_submission_api.py\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import MagicMock, patch, ANY as AnyMockValue\nfrom datetime import datetime, timezone, date # Ensure date is imported\nfrom typing import Optional, Dict, Any, List\n\n# Attempt to import app and other necessary components\ntry:\n    from backend.contact_api import app\n    # For patching, paths are relative to where they are called in the router/service\nexcept ImportError:\n    from contact_api import app # type: ignore\n\nclient = TestClient(app)\n\n# --- Mock Data & Helpers ---\nSUBMISSIONS_API_BASE_PATH = \"/api/v1/submissions\" # Renamed for clarity\nTEST_SUBMISSION_ID = 123\nMOCK_AUTH_USER = {\"username\": \"test_submission_user\"}\n\ndef helper_mock_submission_dict(\n    submission_id: int = TEST_SUBMISSION_ID,\n    form_id: str = \"form-xyz\",\n    ga_client_id: Optional[str] = \"client-id-123\",\n    ga_session_id: Optional[str] = \"session-id-456\",\n    current_status: str = \"new\",\n    reason: Optional[str] = None\n) -> Dict[str, Any]:\n    return {\n        \"id\": submission_id,\n        \"name\": \"Original Test Name\",\n        \"email\": \"test.user@example.com\",\n        \"message\": \"This is an original test message.\",\n        \"ga_client_id\": ga_client_id,\n        \"ga_session_id\": ga_session_id,\n        \"form_id\": form_id,\n        \"submission_status\": current_status,\n        \"status_change_reason\": reason,\n        \"created_at\": datetime(2023, 1, 10, 10, 0, 0, tzinfo=timezone.utc).isoformat(),\n        \"updated_at\": datetime(2023, 1, 10, 11, 0, 0, tzinfo=timezone.utc).isoformat(),\n    }\n\ndef helper_mock_ga_config_dict(form_id: str = \"form-xyz\") -> Dict[str, Any]:\n    return {\n        \"form_id\": form_id,\n        \"ga4_measurement_id\": \"G-GA4VALIDID\",\n        \"ga4_api_secret\": \"valid_secret_for_ga4\",\n        \"description\": \"GA Config for \" + form_id,\n        \"created_at\": datetime(2023, 1, 1, 0, 0, 0, tzinfo=timezone.utc).isoformat(),\n        \"updated_at\": datetime(2023, 1, 1, 0, 0, 0, tzinfo=timezone.utc).isoformat(),\n    }\n\n# --- Test Cases for PATCH /api/v1/submissions/{submission_id}/status ---\n\n@patch(\"backend.routers.submission_router.get_current_active_user\", return_value=MOCK_AUTH_USER)\n@patch(\"backend.routers.submission_router.get_supabase_client\")\n@patch(\"backend.services.submission_service.update_submission_status\")\n@patch(\"backend.services.form_ga_config_service.get_ga_configuration\")\n@patch(\"backend.services.ga4_mp_service.send_ga4_event\")\ndef test_update_status_success_sends_ga4_event_for_converted(\n    mock_send_ga4_event, mock_get_ga_config, mock_update_status_svc, mock_get_supabase, mock_auth, client\n):\n    new_status = \"converted\"\n    payload = {\"new_status\": new_status, \"reason\": \"Customer purchased product X.\"}\n\n    mock_supabase_instance = MagicMock(name=\"supabase_mock\")\n    mock_get_supabase.return_value = mock_supabase_instance\n\n    current_submission = helper_mock_submission_dict(current_status=\"qualified\")\n    # Mock the initial fetch of the submission within the endpoint\n    mock_supabase_instance.table.return_value.select.return_value.eq.return_value.single.return_value.execute.return_value = MagicMock(data=current_submission)\n\n    updated_submission_from_service = {**current_submission, \"submission_status\": new_status, \"status_change_reason\": payload[\"reason\"]}\n    mock_update_status_svc.return_value = updated_submission_from_service\n\n    mock_get_ga_config.return_value = helper_mock_ga_config_dict(form_id=current_submission[\"form_id\"])\n    mock_send_ga4_event.return_value = True # Simulate GA4 send success\n\n    response = client.patch(f\"{SUBMISSIONS_API_BASE_PATH}/{TEST_SUBMISSION_ID}/status\", json=payload)\n\n    assert response.status_code == 200\n    resp_data = response.json()\n    assert resp_data[\"submission_status\"] == new_status\n    assert resp_data[\"status_change_reason\"] == payload[\"reason\"]\n\n    mock_update_status_svc.assert_called_once_with(\n        db=mock_supabase_instance, submission_id=TEST_SUBMISSION_ID, new_status=new_status, reason=payload[\"reason\"]\n    )\n    mock_get_ga_config.assert_called_once_with(mock_supabase_instance, current_submission[\"form_id\"])\n\n    expected_ga4_event_name = \"close_convert_lead\"\n    expected_ga4_params = {\n        \"form_id\": current_submission[\"form_id\"],\n        \"session_id\": current_submission[\"ga_session_id\"],\n        \"transaction_id\": str(TEST_SUBMISSION_ID)\n    }\n    mock_send_ga4_event.assert_called_once_with(\n        api_secret=helper_mock_ga_config_dict()[\"ga4_api_secret\"],\n        measurement_id=helper_mock_ga_config_dict()[\"ga4_measurement_id\"],\n        client_id=current_submission[\"ga_client_id\"],\n        events=[{\"name\": expected_ga4_event_name, \"params\": expected_ga4_params}]\n    )\n\n@patch(\"backend.routers.submission_router.get_current_active_user\", return_value=MOCK_AUTH_USER)\n@patch(\"backend.routers.submission_router.get_supabase_client\")\n@patch(\"backend.services.submission_service.update_submission_status\")\n@patch(\"backend.services.ga4_mp_service.send_ga4_event\") # No need to mock get_ga_config if event not sent\ndef test_update_status_success_no_ga4_event_if_status_not_mapped(\n    mock_send_ga4_event, mock_update_status_svc, mock_get_supabase, mock_auth, client\n):\n    new_status = \"new\" # 'new' is not in STATUS_TO_GA4_EVENT_MAP for sending event post-update\n    payload = {\"new_status\": new_status}\n\n    mock_supabase_instance = MagicMock()\n    mock_get_supabase.return_value = mock_supabase_instance\n\n    current_submission = helper_mock_submission_dict(current_status=\"spam\")\n    mock_supabase_instance.table.return_value.select.return_value.eq.return_value.single.return_value.execute.return_value = MagicMock(data=current_submission)\n\n    updated_submission_from_service = {**current_submission, \"submission_status\": new_status}\n    mock_update_status_svc.return_value = updated_submission_from_service\n\n    response = client.patch(f\"{SUBMISSIONS_API_BASE_PATH}/{TEST_SUBMISSION_ID}/status\", json=payload)\n\n    assert response.status_code == 200\n    assert response.json()[\"submission_status\"] == new_status\n    mock_send_ga4_event.assert_not_called()\n\n\n@patch(\"backend.routers.submission_router.get_current_active_user\", return_value=MOCK_AUTH_USER)\n@patch(\"backend.routers.submission_router.get_supabase_client\")\ndef test_update_status_submission_fetch_fails_404(mock_get_supabase, mock_auth, client):\n    payload = {\"new_status\": \"contacted\"}\n    mock_supabase_instance = MagicMock()\n    mock_get_supabase.return_value = mock_supabase_instance\n\n    # Simulate submission not found by initial fetch in router\n    mock_supabase_instance.table.return_value.select.return_value.eq.return_value.single.return_value.execute.return_value = MagicMock(data=None)\n\n    response = client.patch(f\"{SUBMISSIONS_API_BASE_PATH}/{TEST_SUBMISSION_ID}/status\", json=payload)\n    assert response.status_code == 404\n\n\n@patch(\"backend.routers.submission_router.get_current_active_user\", return_value=MOCK_AUTH_USER)\n@patch(\"backend.routers.submission_router.get_supabase_client\")\n@patch(\"backend.services.submission_service.update_submission_status\")\ndef test_update_status_service_layer_fails_update(mock_update_status_svc, mock_get_supabase, mock_auth, client):\n    payload = {\"new_status\": \"contacted\"}\n    mock_supabase_instance = MagicMock()\n    mock_get_supabase.return_value = mock_supabase_instance\n\n    current_submission = helper_mock_submission_dict()\n    mock_supabase_instance.table.return_value.select.return_value.eq.return_value.single.return_value.execute.return_value = MagicMock(data=current_submission)\n\n    mock_update_status_svc.return_value = None # Simulate service layer failing the update\n\n    response = client.patch(f\"{SUBMISSIONS_API_BASE_PATH}/{TEST_SUBMISSION_ID}/status\", json=payload)\n    assert response.status_code == 404 # Changed from 500, as service returning None often means \"not found\" or \"no action\"\n\n@patch(\"backend.routers.submission_router.get_current_active_user\", return_value=MOCK_AUTH_USER)\n@patch(\"backend.routers.submission_router.get_supabase_client\")\n@patch(\"backend.services.form_ga_config_service.get_ga_configuration\")\n@patch(\"backend.services.submission_service.update_submission_status\")\n@patch(\"backend.services.ga4_mp_service.send_ga4_event\")\ndef test_update_status_ga4_config_not_found_skips_ga_event(\n    mock_send_ga4_event, mock_update_status_svc, mock_get_ga_config, mock_get_supabase, mock_auth, client\n):\n    new_status = \"converted\"\n    payload = {\"new_status\": new_status}\n\n    mock_supabase_instance = MagicMock()\n    mock_get_supabase.return_value = mock_supabase_instance\n\n    current_submission = helper_mock_submission_dict(current_status=\"qualified\")\n    mock_supabase_instance.table.return_value.select.return_value.eq.return_value.single.return_value.execute.return_value = MagicMock(data=current_submission)\n\n    updated_submission_from_service = {**current_submission, \"submission_status\": new_status}\n    mock_update_status_svc.return_value = updated_submission_from_service\n\n    mock_get_ga_config.return_value = None # Simulate GA4 config not found for the form_id\n\n    response = client.patch(f\"{SUBMISSIONS_API_BASE_PATH}/{TEST_SUBMISSION_ID}/status\", json=payload)\n\n    assert response.status_code == 200\n    assert response.json()[\"submission_status\"] == new_status\n    mock_send_ga4_event.assert_not_called() # GA4 event should not be sent\n    mock_get_ga_config.assert_called_once_with(mock_supabase_instance, current_submission[\"form_id\"])\n\n# --- Test Cases for GET /api/v1/submissions ---\n\n@patch(\"backend.routers.submission_router.get_current_active_user\", return_value=MOCK_AUTH_USER)\n@patch(\"backend.routers.submission_router.get_supabase_client\")\n@patch(\"backend.services.submission_service.list_submissions\")\ndef test_list_submissions_success_no_filters(mock_list_svc, mock_get_supabase_dep, mock_auth_dep, client): # Renamed mock args\n    mock_supabase_instance = MagicMock(name=\"supabase_mock_list_no_filter\")\n    mock_get_supabase_dep.return_value = mock_supabase_instance\n\n    mock_data = [\n        helper_mock_submission_dict(submission_id=101, form_id=\"formA\"),\n        helper_mock_submission_dict(submission_id=102, form_id=\"formB\"),\n    ]\n    mock_total = 50 # Example total count larger than returned items for pagination\n    mock_list_svc.return_value = (mock_data, mock_total)\n\n    response = client.get(f\"{SUBMISSIONS_API_BASE_PATH}/\") # Ensure trailing slash for query params\n\n    assert response.status_code == 200\n    json_response = response.json()\n    assert len(json_response[\"submissions\"]) == 2\n    assert json_response[\"total_count\"] == mock_total\n    assert json_response[\"skip\"] == 0 # Default skip\n    assert json_response[\"limit\"] == 20 # Default limit\n    assert json_response[\"submissions\"][0][\"id\"] == 101\n\n    mock_list_svc.assert_called_once_with(\n        db=mock_supabase_instance,\n        skip=0, limit=20,\n        form_id=None, submission_status=None, email=None, name=None,\n        start_date=None, end_date=None,\n        sort_by=\"created_at\", sort_order=\"desc\" # Default sort params\n    )\n\n@patch(\"backend.routers.submission_router.get_current_active_user\", return_value=MOCK_AUTH_USER)\n@patch(\"backend.routers.submission_router.get_supabase_client\")\n@patch(\"backend.services.submission_service.list_submissions\")\ndef test_list_submissions_with_all_filters_pagination_sorting(mock_list_svc, mock_get_supabase_dep, mock_auth_dep, client):\n    mock_supabase_instance = MagicMock(name=\"supabase_mock_list_filters\")\n    mock_get_supabase_dep.return_value = mock_supabase_instance\n\n    mock_data = [helper_mock_submission_dict(submission_id=201, form_id=\"form-filter\")]\n    mock_total = 1\n    mock_list_svc.return_value = (mock_data, mock_total)\n\n    params = {\n        \"form_id\": \"form-filter\", \"submission_status\": \"converted\",\n        \"email\": \"filter@example.com\", \"name\": \"Filter User\",\n        \"start_date\": \"2024-01-01\", \"end_date\": \"2024-01-31\",\n        \"skip\": 10, \"limit\": 5,\n        \"sort_by\": \"name\", \"sort_order\": \"asc\"\n    }\n    response = client.get(f\"{SUBMISSIONS_API_BASE_PATH}/\", params=params)\n\n    assert response.status_code == 200\n    json_response = response.json()\n    assert len(json_response[\"submissions\"]) == 1\n    assert json_response[\"total_count\"] == mock_total\n    assert json_response[\"skip\"] == 10\n    assert json_response[\"limit\"] == 5\n    assert json_response[\"submissions\"][0][\"id\"] == 201\n\n    # FastAPI Query converts date strings to date objects\n    # from datetime import date as date_type # For type checking in assert (already imported at top)\n    mock_list_svc.assert_called_once_with(\n        db=mock_supabase_instance,\n        skip=10, limit=5,\n        form_id=\"form-filter\", submission_status=\"converted\",\n        email=\"filter@example.com\", name=\"Filter User\",\n        start_date=date(2024,1,1), end_date=date(2024,1,31),\n        sort_by=\"name\", sort_order=\"asc\"\n    )\n\n@patch(\"backend.routers.submission_router.get_current_active_user\", return_value=MOCK_AUTH_USER)\n@patch(\"backend.routers.submission_router.get_supabase_client\")\n@patch(\"backend.services.submission_service.list_submissions\")\ndef test_list_submissions_empty_result_from_service(mock_list_svc, mock_get_supabase_dep, mock_auth_dep, client):\n    mock_supabase_instance = MagicMock(name=\"supabase_mock_list_empty\")\n    mock_get_supabase_dep.return_value = mock_supabase_instance\n    mock_list_svc.return_value = ([], 0) # Service returns empty list and 0 total\n\n    response = client.get(f\"{SUBMISSIONS_API_BASE_PATH}/\")\n    assert response.status_code == 200\n    json_response = response.json()\n    assert len(json_response[\"submissions\"]) == 0\n    assert json_response[\"total_count\"] == 0\n\n@patch(\"backend.routers.submission_router.get_current_active_user\", return_value=MOCK_AUTH_USER)\n@patch(\"backend.routers.submission_router.get_supabase_client\")\ndef test_list_submissions_supabase_client_is_none(mock_get_supabase_dep, mock_auth_dep, client):\n    mock_get_supabase_dep.return_value = None # Simulate Supabase client not available\n\n    response = client.get(f\"{SUBMISSIONS_API_BASE_PATH}/\")\n    assert response.status_code == 503\n    assert response.json()[\"detail\"] == \"Supabase client unavailable\" # Match error detail\n\n@patch(\"backend.routers.submission_router.get_current_active_user\", return_value=MOCK_AUTH_USER)\n@patch(\"backend.routers.submission_router.get_supabase_client\")\n@patch(\"backend.services.submission_service.list_submissions\")\ndef test_list_submissions_service_raises_exception(mock_list_svc, mock_get_supabase_dep, mock_auth_dep, client):\n    mock_supabase_instance = MagicMock(name=\"supabase_mock_list_svc_error\")\n    mock_get_supabase_dep.return_value = mock_supabase_instance\n    mock_list_svc.side_effect = Exception(\"Simulated service error\")\n\n    response = client.get(f\"{SUBMISSIONS_API_BASE_PATH}/\")\n    assert response.status_code == 500\n    assert response.json()[\"detail\"] == \"Failed to list submissions.\"\n"
    },
    {
      "path": "backend/tests/test_tenant_api.py",
      "content": "# backend/tests/test_tenant_api.py\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import MagicMock, patch, ANY as AnyMockValue\nfrom uuid import uuid4, UUID # Import UUID for type checks\nfrom datetime import datetime, timezone\nfrom typing import List, Dict, Any, Optional\n\ntry:\n    from backend.contact_api import app\n    from backend.auth import AuthenticatedUser # For mocking user\nexcept ImportError:\n    from contact_api import app # type: ignore\n    # Define dummy AuthenticatedUser if needed for subtask environment\n    class AuthenticatedUser:\n        def __init__(self, id: str, app_role: str, tenant_id: Optional[str] = None, email: Optional[str] = None, full_name: Optional[str] = None):\n            self.id = id\n            self.app_role = app_role\n            self.tenant_id = tenant_id\n            self.email = email\n            self.full_name = full_name\n\n\nclient = TestClient(app)\n\n# --- Mock Data & Helpers ---\nTENANTS_API_BASE_PATH = \"/api/v1/tenants\"\nMOCK_SUPERUSER = AuthenticatedUser(id=\"super-user-id\", app_role=\"superuser\", tenant_id=None)\nMOCK_NON_SUPERUSER = AuthenticatedUser(id=\"normal-user-id\", app_role=\"user\", tenant_id=str(uuid4()))\n\ndef helper_mock_tenant_payload_dict(company_name: str = \"Test Tenant Inc.\", domain: Optional[str] = \"test-tenant.com\") -> Dict[str, Any]:\n    return {\"company_name\": company_name, \"domain\": domain}\n\ndef helper_mock_tenant_db_record_dict(\n    tenant_id: Optional[UUID] = None, # Allow passing None for creation where DB generates it\n    company_name: str = \"Test Tenant Inc.\",\n    domain: Optional[str] = \"test-tenant.com\",\n    is_deleted: bool = False\n) -> Dict[str, Any]:\n    return {\n        \"tenant_id\": str(tenant_id if tenant_id else uuid4()), # Convert UUID to str for JSON comparison\n        \"company_name\": company_name,\n        \"domain\": domain,\n        \"is_deleted\": is_deleted,\n        \"created_at\": datetime.now(timezone.utc).isoformat(),\n        \"updated_at\": datetime.now(timezone.utc).isoformat(),\n    }\n\n# --- Test Cases ---\n\n# CREATE Tenant\n@patch(\"backend.routers.tenant_router.get_current_active_user\", return_value=MOCK_SUPERUSER)\n@patch(\"backend.routers.tenant_router.get_supabase_client\")\n@patch(\"backend.services.tenant_service.create_tenant\")\ndef test_create_tenant_success_as_superuser(mock_create_svc, mock_get_supabase, mock_auth, client):\n    payload = helper_mock_tenant_payload_dict()\n    mock_supabase_instance = MagicMock()\n    mock_get_supabase.return_value = mock_supabase_instance\n\n    # create_tenant service returns a dict representing the DB record\n    db_record = helper_mock_tenant_db_record_dict(**payload) # Pass payload fields\n    mock_create_svc.return_value = db_record\n\n    response = client.post(TENANTS_API_BASE_PATH, json=payload)\n\n    assert response.status_code == 201\n    resp_data = response.json()\n    assert resp_data[\"company_name\"] == payload[\"company_name\"]\n    assert resp_data[\"domain\"] == payload[\"domain\"]\n    assert resp_data[\"is_deleted\"] is False # Default\n    assert \"tenant_id\" in resp_data\n    mock_create_svc.assert_called_once()\n    # Check payload passed to service (Pydantic model in service, dict here is fine if fields match)\n    # The service receives TenantCreatePayload, so its .model_dump() would be passed.\n    # For simplicity, checking if called is often enough if payload structure is simple.\n\n@patch(\"backend.routers.tenant_router.get_current_active_user\", return_value=MOCK_NON_SUPERUSER)\ndef test_create_tenant_fail_as_non_superuser(mock_auth, client):\n    payload = helper_mock_tenant_payload_dict()\n    response = client.post(TENANTS_API_BASE_PATH, json=payload)\n    assert response.status_code == 403\n\n# GET Tenant List\n@patch(\"backend.routers.tenant_router.get_current_active_user\", return_value=MOCK_SUPERUSER)\n@patch(\"backend.routers.tenant_router.get_supabase_client\")\n@patch(\"backend.services.tenant_service.list_tenants\")\ndef test_list_tenants_success_as_superuser(mock_list_svc, mock_get_supabase, mock_auth, client):\n    mock_supabase_instance = MagicMock()\n    mock_get_supabase.return_value = mock_supabase_instance\n\n    mock_tenants_data = [\n        helper_mock_tenant_db_record_dict(company_name=\"Tenant A\"),\n        helper_mock_tenant_db_record_dict(company_name=\"Tenant B\", is_deleted=True)\n    ]\n    mock_total = 2\n    mock_list_svc.return_value = (mock_tenants_data, mock_total)\n\n    response = client.get(TENANTS_API_BASE_PATH, params={\"show_deleted\": True, \"skip\": 0, \"limit\": 10})\n\n    assert response.status_code == 200\n    resp_data = response.json()\n    assert len(resp_data[\"tenants\"]) == 2\n    assert resp_data[\"total_count\"] == mock_total\n    assert resp_data[\"tenants\"][0][\"company_name\"] == \"Tenant A\"\n    mock_list_svc.assert_called_once_with(mock_supabase_instance, 0, 10, True)\n\n# GET Single Tenant\n@patch(\"backend.routers.tenant_router.get_current_active_user\", return_value=MOCK_SUPERUSER)\n@patch(\"backend.routers.tenant_router.get_supabase_client\")\n@patch(\"backend.services.tenant_service.get_tenant\")\ndef test_get_tenant_success_as_superuser(mock_get_svc, mock_get_supabase, mock_auth, client):\n    tenant_id = uuid4()\n    db_record = helper_mock_tenant_db_record_dict(tenant_id=tenant_id)\n    mock_supabase_instance = MagicMock()\n    mock_get_supabase.return_value = mock_supabase_instance\n    mock_get_svc.return_value = db_record\n\n    response = client.get(f\"{TENANTS_API_BASE_PATH}/{str(tenant_id)}\")\n    assert response.status_code == 200\n    assert response.json()[\"tenant_id\"] == str(tenant_id)\n    mock_get_svc.assert_called_once_with(mock_supabase_instance, tenant_id)\n\n@patch(\"backend.routers.tenant_router.get_current_active_user\", return_value=MOCK_SUPERUSER)\n@patch(\"backend.routers.tenant_router.get_supabase_client\")\n@patch(\"backend.services.tenant_service.get_tenant\")\ndef test_get_tenant_not_found_as_superuser(mock_get_svc, mock_get_supabase, mock_auth, client):\n    tenant_id = uuid4()\n    mock_supabase_instance = MagicMock()\n    mock_get_supabase.return_value = mock_supabase_instance\n    mock_get_svc.return_value = None # Simulate not found\n\n    response = client.get(f\"{TENANTS_API_BASE_PATH}/{str(tenant_id)}\")\n    assert response.status_code == 404\n\n# UPDATE Tenant\n@patch(\"backend.routers.tenant_router.get_current_active_user\", return_value=MOCK_SUPERUSER)\n@patch(\"backend.routers.tenant_router.get_supabase_client\")\n@patch(\"backend.services.tenant_service.update_tenant\")\ndef test_update_tenant_success_as_superuser(mock_update_svc, mock_get_supabase, mock_auth, client):\n    tenant_id = uuid4()\n    update_payload = {\"company_name\": \"Updated Tenant Name\", \"is_deleted\": True}\n\n    # Simulate what the service would return after update\n    updated_db_record = helper_mock_tenant_db_record_dict(\n        tenant_id=tenant_id,\n        company_name=\"Updated Tenant Name\",\n        is_deleted=True\n    )\n    mock_supabase_instance = MagicMock()\n    mock_get_supabase.return_value = mock_supabase_instance\n    mock_update_svc.return_value = updated_db_record\n\n    response = client.put(f\"{TENANTS_API_BASE_PATH}/{str(tenant_id)}\", json=update_payload)\n    assert response.status_code == 200\n    resp_data = response.json()\n    assert resp_data[\"company_name\"] == \"Updated Tenant Name\"\n    assert resp_data[\"is_deleted\"] is True\n    # Check that service was called with Pydantic model (or its dict representation)\n    # The router passes TenantUpdatePayload to the service.\n    mock_update_svc.assert_called_once()\n    # More specific check on payload if needed:\n    # from backend.models.tenant_models import TenantUpdatePayload\n    # expected_service_payload = TenantUpdatePayload(**update_payload)\n    # mock_update_svc.assert_called_once_with(mock_supabase_instance, tenant_id, expected_service_payload)\n\n\n# DELETE Tenant (Logical)\n@patch(\"backend.routers.tenant_router.get_current_active_user\", return_value=MOCK_SUPERUSER)\n@patch(\"backend.routers.tenant_router.get_supabase_client\")\n@patch(\"backend.services.tenant_service.delete_tenant\")\ndef test_delete_tenant_logical_success_as_superuser(mock_delete_svc, mock_get_supabase, mock_auth, client):\n    tenant_id = uuid4()\n    mock_supabase_instance = MagicMock()\n    mock_get_supabase.return_value = mock_supabase_instance\n    mock_delete_svc.return_value = True # Simulate successful logical delete\n\n    response = client.delete(f\"{TENANTS_API_BASE_PATH}/{str(tenant_id)}\", params={\"hard_delete\": False})\n    assert response.status_code == 204\n    mock_delete_svc.assert_called_once_with(mock_supabase_instance, tenant_id, False)\n\n# DELETE Tenant (Hard)\n@patch(\"backend.routers.tenant_router.get_current_active_user\", return_value=MOCK_SUPERUSER)\n@patch(\"backend.routers.tenant_router.get_supabase_client\")\n@patch(\"backend.services.tenant_service.delete_tenant\")\ndef test_delete_tenant_hard_success_as_superuser(mock_delete_svc, mock_get_supabase, mock_auth, client):\n    tenant_id = uuid4()\n    mock_supabase_instance = MagicMock()\n    mock_get_supabase.return_value = mock_supabase_instance\n    mock_delete_svc.return_value = True\n\n    response = client.delete(f\"{TENANTS_API_BASE_PATH}/{str(tenant_id)}\", params={\"hard_delete\": True})\n    assert response.status_code == 204\n    mock_delete_svc.assert_called_once_with(mock_supabase_instance, tenant_id, True)\n\n@patch(\"backend.routers.tenant_router.get_current_active_user\", return_value=MOCK_SUPERUSER)\n@patch(\"backend.routers.tenant_router.get_supabase_client\")\n@patch(\"backend.services.tenant_service.delete_tenant\")\ndef test_delete_tenant_not_found_as_superuser(mock_delete_svc, mock_get_supabase, mock_auth, client):\n    tenant_id = uuid4()\n    mock_supabase_instance = MagicMock()\n    mock_get_supabase.return_value = mock_supabase_instance\n    mock_delete_svc.return_value = False # Simulate tenant not found by service\n\n    response = client.delete(f\"{TENANTS_API_BASE_PATH}/{str(tenant_id)}\")\n    assert response.status_code == 404\n"
    },
    {
      "path": "database/contact_form_schema.sql",
      "content": "-- PostgreSQL schema for contact_submissions table, suitable for Supabase\n\n-- Ensure the table is not created if it already exists\nCREATE TABLE IF NOT EXISTS contact_submissions (\n    id BIGSERIAL PRIMARY KEY,\n    created_at TIMESTAMPTZ DEFAULT NOW(),\n    name TEXT NOT NULL,\n    email TEXT NOT NULL,\n    message TEXT NOT NULL,\n    ga_client_id TEXT,\n    ga_session_id TEXT,\n    form_id TEXT -- To associate with the data-form-id from the widget\n);\n\n-- Add comments to columns for better understanding\nCOMMENT ON COLUMN contact_submissions.id IS 'Auto-incrementing unique identifier for each submission';\nCOMMENT ON COLUMN contact_submissions.created_at IS 'Timestamp of when the submission was created';\nCOMMENT ON COLUMN contact_submissions.name IS 'Name of the person submitting the form';\nCOMMENT ON COLUMN contact_submissions.email IS 'Email address of the person submitting the form';\nCOMMENT ON COLUMN contact_submissions.message IS 'The message content from the form submission';\nCOMMENT ON COLUMN contact_submissions.ga_client_id IS 'Google Analytics Client ID, if available';\nCOMMENT ON COLUMN contact_submissions.ga_session_id IS 'Google Analytics Session ID, if available';\nCOMMENT ON COLUMN contact_submissions.form_id IS 'Identifier for the specific form used for this submission (e.g., from data-form-id attribute)';\n\n-- Example of how to enable Row Level Security (RLS) - common in Supabase\n-- This is typically done in the Supabase UI, but can be scripted.\n-- Ensure RLS is enabled on the table.\n-- ALTER TABLE contact_submissions ENABLE ROW LEVEL SECURITY;\n\n-- Example: Allow public read-only access (adjust as needed for your security model)\n-- This policy is very permissive and likely not suitable for production without modification.\n-- CREATE POLICY \"Allow public read access\"\n-- ON contact_submissions\n-- FOR SELECT\n-- USING (true);\n\n-- Example: Allow authenticated users to insert their own data\n-- (This assumes you have a way to link auth.uid() to submissions, which is not part of this basic schema yet)\n-- CREATE POLICY \"Allow authenticated users to insert\"\n-- ON contact_submissions\n-- FOR INSERT\n-- WITH CHECK (auth.role() = 'authenticated');\n\n-- Note: Policies for UPDATE and DELETE would also be needed for full CRUD by users.\n-- Supabase typically handles data insertion via its API using the service_role key,\n-- which bypasses RLS by default, or via specific user roles if RLS is configured for inserts.\n-- For this project, the FastAPI backend will likely use a service role key to insert data,\n-- so insert policies for individual users might not be immediately necessary for the backend.\n"
    },
    {
      "path": "database/form_ga_configurations_schema.sql",
      "content": "-- Schema for form_ga_configurations table\n-- This table stores Google Analytics 4 Measurement Protocol configurations per form_id.\n\nCREATE TABLE IF NOT EXISTS form_ga_configurations (\n    form_id TEXT PRIMARY KEY,\n    ga4_measurement_id TEXT NOT NULL,\n    ga4_api_secret TEXT NOT NULL, -- IMPORTANT: Store encrypted in a real production system\n    description TEXT,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\nCOMMENT ON TABLE form_ga_configurations IS 'Stores GA4 Measurement Protocol configurations for each form.';\nCOMMENT ON COLUMN form_ga_configurations.form_id IS 'Unique identifier for the form (e.g., from data-form-id attribute).';\nCOMMENT ON COLUMN form_ga_configurations.ga4_measurement_id IS 'GA4 Measurement ID (e.g., G-XXXXXXXXXX).';\nCOMMENT ON COLUMN form_ga_configurations.ga4_api_secret IS 'GA4 API Secret for Measurement Protocol. IMPORTANT: This should be encrypted at rest in production.';\nCOMMENT ON COLUMN form_ga_configurations.description IS 'Optional description for this configuration set.';\nCOMMENT ON COLUMN form_ga_configurations.created_at IS 'Timestamp of when this configuration was created.';\nCOMMENT ON COLUMN form_ga_configurations.updated_at IS 'Timestamp of when this configuration was last updated.';\n\n-- Trigger to automatically update updated_at timestamp on row update\n-- This is PostgreSQL specific.\nCREATE OR REPLACE FUNCTION update_updated_at_column_form_ga_config() -- Renamed function to be more specific\nRETURNS TRIGGER AS $$\nBEGIN\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n$$ language 'plpgsql';\n\n-- Ensure the trigger name is unique if similar triggers exist for other tables.\nCREATE TRIGGER trigger_update_form_ga_configurations_updated_at\nBEFORE UPDATE ON form_ga_configurations\nFOR EACH ROW\nEXECUTE FUNCTION update_updated_at_column_form_ga_config(); -- Use renamed function\n"
    },
    {
      "path": "examples/form_widget_loader.ts",
      "content": "(() => {\n  const scriptElement = document.currentScript as HTMLScriptElement | null;\n\n  if (!scriptElement) {\n    console.error(\"Error: Could not find the script element. Make sure this script is not loaded as a module or asynchronously without `async=false`.\");\n    return;\n  }\n\n  const formId = scriptElement.getAttribute(\"data-form-id\");\n  const apiEndpoint = scriptElement.getAttribute(\"data-api-endpoint\") || 'https://api.example.com/submit';\n  const theme = scriptElement.getAttribute(\"data-theme\") || 'light';\n  const position = scriptElement.getAttribute(\"data-position\") || 'bottom-right';\n  const title = scriptElement.getAttribute(\"data-title\") || 'お問い合わせ';\n  const buttonText = scriptElement.getAttribute(\"data-button-text\") || '送信';\n\n  if (!formId) {\n    console.error(\"Error: data-form-id attribute is required and was not found on the script tag.\");\n    return;\n  }\n\n  console.log(\"Contact Form Widget Loader: Attributes collected:\");\n  console.log(\"  Form ID:        \", formId);\n  console.log(\"  API Endpoint:   \", apiEndpoint);\n  console.log(\"  Theme:          \", theme);\n  console.log(\"  Position:       \", position);\n  console.log(\"  Title:          \", title);\n  console.log(\"  Button Text:    \", buttonText);\n\n  const placeholderDiv = document.createElement('div');\n  placeholderDiv.id = `contact-form-widget-placeholder-${formId}`;\n  placeholderDiv.textContent = `Contact form widget (form-id: ${formId}) will be loaded here. Position: ${position}, Theme: ${theme}, Title: \"${title}\", Button: \"${buttonText}\", API: \"${apiEndpoint}\"`;\n  placeholderDiv.style.cssText = `\n    padding: 20px;\n    margin: 10px 0;\n    border: 1px dashed #ccc;\n    background-color: #f9f9f9;\n    text-align: center;\n    font-family: sans-serif;\n  `;\n  document.body.appendChild(placeholderDiv);\n\n})();\n"
    },
    {
      "path": "examples/usage_examples.html",
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Contact Form Widget Usage Examples</title>\n    <style>\n        body { \n            font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\n            padding: 20px; \n            line-height: 1.6;\n            color: #333;\n            background-color: #fdfdfd;\n        }\n        .container {\n            max-width: 800px;\n            margin: 0 auto;\n        }\n        .example-container { \n            margin-bottom: 40px; \n            padding: 20px; \n            border: 1px solid #e0e0e0; \n            border-radius: 8px;\n            background-color: #ffffff;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.05);\n        }\n        h1 {\n            border-bottom: 2px solid #007bff;\n            padding-bottom: 10px;\n            color: #007bff;\n        }\n        h2 { \n            margin-top: 0; \n            color: #333;\n            border-bottom: 1px solid #eee;\n            padding-bottom: 8px;\n        }\n        p {\n            margin-bottom: 15px;\n        }\n        code { \n            font-family: \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n            background-color: #f0f0f0; \n            padding: 2px 6px; \n            border-radius: 4px; \n            font-size: 0.9em;\n        }\n        pre { \n            background-color: #f5f5f5; \n            padding: 15px; \n            border-radius: 6px; \n            overflow-x: auto;\n            border: 1px solid #ddd;\n        }\n        pre code {\n            background-color: transparent; /* Avoid double background for code inside pre */\n            padding: 0;\n            font-size: 0.85em;\n        }\n        .note {\n            font-style: italic;\n            color: #555;\n            background-color: #fffbe6;\n            border-left: 4px solid #ffc107;\n            padding: 10px 15px;\n            border-radius: 4px;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Contact Form Widget Examples</h1>\n        <p>This page demonstrates how to embed the contact form widget on your website. The widget loader script (<code>form_widget_loader.js</code>) will read the <code>data-*</code> attributes from the script tag and create a placeholder element where the actual form will be rendered (or indicate what will be rendered).</p>\n        \n        <p>To use the widget, include the <code>form_widget_loader.js</code> script in your HTML and provide the necessary <code>data-*</code> attributes.</p>\n\n        <div class=\"example-container\">\n            <h2>Minimal Configuration</h2>\n            <p>This example uses only the required <code>data-form-id</code> attribute. The loader script will use default values for other settings like title, theme, and API endpoint.</p>\n            <p><strong>Code:</strong></p>\n            <pre><code>&lt;script src=\"form_widget_loader.js\" data-form-id=\"default-contact-form\"&gt;&lt;/script&gt;</code></pre>\n            <p><strong>Live Example (Placeholder):</strong></p>\n            <!-- Actual script tag for testing -->\n            <script src=\"form_widget_loader.js\" data-form-id=\"default-contact-form\"></script>\n        </div>\n\n        <div class=\"example-container\">\n            <h2>Customized Configuration</h2>\n            <p>This example demonstrates using various <code>data-*</code> attributes to customize the widget's appearance and behavior.</p>\n            <p><strong>Code:</strong></p>\n            <pre><code>&lt;script src=\"form_widget_loader.js\" \n        data-form-id=\"product-inquiry-001\"\n        data-api-endpoint=\"https://your-custom-api.com/submit-inquiry\"\n        data-theme=\"dark\"\n        data-position=\"bottom-left\"\n        data-title=\"Product Inquiry\"\n        data-button-text=\"Send Inquiry\"&gt;&lt;/script&gt;</code></pre>\n            <p><strong>Live Example (Placeholder):</strong></p>\n            <!-- Actual script tag for testing -->\n            <script src=\"form_widget_loader.js\" \n                    data-form-id=\"product-inquiry-001\"\n                    data-api-endpoint=\"https://your-custom-api.com/submit-inquiry\"\n                    data-theme=\"dark\"\n                    data-position=\"bottom-left\"\n                    data-title=\"Product Inquiry\"\n                    data-button-text=\"Send Inquiry\"></script>\n        </div>\n\n        <p class=\"note\"><em><strong>Important:</strong> For these examples to function correctly, the <code>form_widget_loader.ts</code> file (located in the same <code>examples</code> directory) must be compiled into JavaScript as <code>form_widget_loader.js</code> and be accessible at the same path relative to this HTML file. The current loader script only creates a placeholder div and logs attributes to the console; it does not yet render the actual React form widget.</em></p>\n\n        <hr>\n        <p>Some other content on this page to simulate a real website structure.</p>\n        <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p>\n    </div>\n</body>\n</html>\n"
    },
    {
      "path": "frontend/src/components/ContactFormWidget.tsx",
      "content": "import React, { useState, useEffect } from 'react';\n\ninterface ContactFormWidgetProps {\n  formTitle?: string;\n  submitButtonText?: string;\n  // apiEndpoint?: string; // To be added later\n}\n\nconst getGAClientId = (): string => {\n  // In a real scenario, you might try to get this from cookies or a GA API\n  // For example, by looking for a cookie like _ga or _ga_YOUR_MEASUREMENT_ID\n  // Or if using analytics.js (Universal Analytics):\n  // if (typeof ga === 'function' && ga.getAll && ga.getAll()[0]) {\n  //   return ga.getAll()[0].get('clientId');\n  // }\n  // For gtag.js (GA4), it's more complex and often involves parsing cookies like _ga_MEASUREMENTID\n  // or custom event tracking.\n  return \"CLIENT_ID_PLACEHOLDER\";\n};\n\nconst getGASessionId = (): string => {\n  // Similar to client ID, session ID retrieval is complex.\n  // For gtag.js (GA4), you might use:\n  // gtag('get', 'YOUR_MEASUREMENT_ID', 'session_id', (sessionId) => { /* use sessionId */ });\n  // Or parse it from cookies like _ga_MEASUREMENTID (e.g., G1.1.123456789.1678901234 where 1678901234 might be a session identifier)\n  return \"SESSION_ID_PLACEHOLDER\";\n};\n\nconst ContactFormWidget: React.FC<ContactFormWidgetProps> = ({\n  formTitle = 'お問い合わせ',\n  submitButtonText = '送信',\n}) => {\n  const [name, setName] = useState('');\n  const [email, setEmail] = useState('');\n  const [message, setMessage] = useState('');\n  const [gaClientId, setGaClientId] = useState('');\n  const [gaSessionId, setGaSessionId] = useState('');\n\n  useEffect(() => {\n    setGaClientId(getGAClientId());\n    setGaSessionId(getGASessionId());\n  }, []);\n\n  const handleSubmit = (event: React.FormEvent) => {\n    event.preventDefault();\n    // Actual submission logic will be added later.\n    // This will involve sending data to apiEndpoint.\n    console.log(\"Form submitted with data:\", {\n      name,\n      email,\n      message,\n      ga_client_id: gaClientId,\n      ga_session_id: gaSessionId,\n    });\n    // alert(\"Form submitted (see console for data). Actual API call not implemented yet.\");\n  };\n\n  const styles = {\n    container: {\n      border: '1px solid #ccc',\n      padding: '20px',\n      borderRadius: '8px',\n      backgroundColor: '#f9f9f9',\n      maxWidth: '500px',\n      fontFamily: 'Arial, sans-serif',\n    },\n    heading: {\n      textAlign: 'center' as 'center',\n      color: '#333',\n      marginBottom: '20px',\n    },\n    formGroup: {\n      marginBottom: '15px',\n    },\n    label: {\n      display: 'block',\n      marginBottom: '5px',\n      color: '#555',\n      fontSize: '14px',\n    },\n    input: {\n      width: 'calc(100% - 20px)',\n      padding: '10px',\n      border: '1px solid #ddd',\n      borderRadius: '4px',\n      fontSize: '16px',\n    },\n    textarea: {\n      width: 'calc(100% - 20px)',\n      padding: '10px',\n      border: '1px solid #ddd',\n      borderRadius: '4px',\n      fontSize: '16px',\n      minHeight: '80px',\n      resize: 'vertical' as 'vertical',\n    },\n    button: {\n      width: '100%',\n      padding: '10px 15px',\n      backgroundColor: '#007bff',\n      color: 'white',\n      border: 'none',\n      borderRadius: '4px',\n      fontSize: '16px',\n      cursor: 'pointer',\n      transition: 'background-color 0.2s ease-in-out',\n    },\n    // buttonHover: { // Note: Inline styles don't directly support pseudo-classes like :hover\n    //   backgroundColor: '#0056b3',\n    // }\n  };\n\n  return (\n    <div style={styles.container}>\n      <h2 style={styles.heading}>{formTitle}</h2>\n      <form onSubmit={handleSubmit}>\n        <div style={styles.formGroup}>\n          <label htmlFor=\"contact-name\" style={styles.label}>Name</label>\n          <input\n            type=\"text\"\n            id=\"contact-name\"\n            name=\"name\"\n            value={name}\n            onChange={(e) => setName(e.target.value)}\n            required\n            style={styles.input}\n          />\n        </div>\n\n        <div style={styles.formGroup}>\n          <label htmlFor=\"contact-email\" style={styles.label}>Email</label>\n          <input\n            type=\"email\"\n            id=\"contact-email\"\n            name=\"email\"\n            value={email}\n            onChange={(e) => setEmail(e.target.value)}\n            required\n            style={styles.input}\n          />\n        </div>\n\n        <div style={styles.formGroup}>\n          <label htmlFor=\"contact-message\" style={styles.label}>Message</label>\n          <textarea\n            id=\"contact-message\"\n            name=\"message\"\n            value={message}\n            onChange={(e) => setMessage(e.target.value)}\n            required\n            style={styles.textarea}\n          />\n        </div>\n\n        <input type=\"hidden\" name=\"ga_client_id\" value={gaClientId} />\n        <input type=\"hidden\" name=\"ga_session_id\" value={gaSessionId} />\n\n        <button type=\"submit\" style={styles.button}>\n          {submitButtonText}\n        </button>\n      </form>\n    </div>\n  );\n};\n\nexport default ContactFormWidget;\n"
    }
  ]
}
